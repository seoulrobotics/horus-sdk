#ifndef HORUS_PB_RPC_PB_H_
#define HORUS_PB_RPC_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/rpc.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/pb/cow_bytes.h"
#include "horus/pb/logs/logs_pb.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/types/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Message forward declarations

class NoResponse;
class RpcServiceOptions;
class RpcMethodOptions_SubscribeMethod;
class RpcMethodOptions_UnsubscribeMethod;
class RpcMethodOptions;
class DefaultSubscribeRequest;
class DefaultSubscribeResponse;
class DefaultUnsubscribeRequest;
class DefaultUnsubscribeResponse;

// MARK: Message declarations

/// Indicates that no response is expected, and that the client does not need to
///  wait for a response.
///
/// Source: horus/pb/rpc.proto:10:1
class NoResponse final : public PbMessage {
 public:

  /// Constructs a default-initialized `NoResponse`.
  NoResponse() noexcept = default;

  /// Move constructor.
  NoResponse(NoResponse&&) noexcept = default;
  /// Move assignment operator.
  NoResponse& operator=(NoResponse&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit NoResponse(const NoResponse&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  NoResponse& operator=(const NoResponse&) = delete;

  /// Default destructor.
  ~NoResponse() noexcept final = default;

  /// Creates a `NoResponse` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit NoResponse(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.NoResponse`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.NoResponse"; }

  /// The full name of the message: `horus.pb.NoResponse`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Protobuf metadata options specified on RPC services and methods.
///
/// Source: horus/pb/rpc.proto:13:1
class RpcServiceOptions final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcServiceOptions`.
  RpcServiceOptions() noexcept = default;

  /// Move constructor.
  RpcServiceOptions(RpcServiceOptions&&) noexcept = default;
  /// Move assignment operator.
  RpcServiceOptions& operator=(RpcServiceOptions&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcServiceOptions(const RpcServiceOptions& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcServiceOptions& operator=(const RpcServiceOptions&) = delete;

  /// Default destructor.
  ~RpcServiceOptions() noexcept final = default;

  /// Creates a `RpcServiceOptions` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcServiceOptions(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.RpcServiceOptions`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.RpcServiceOptions"; }

  /// The full name of the message: `horus.pb.RpcServiceOptions`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `id` (no 1).
  // -----

  /// The identifier of the service.
  /// 
  ///  Must be unique across all services.
  /// 
  ///  Cannot be 0.
  /// 
  ///  To determine available service IDs for a new service, run
  /// 
  ///    horus cat service_ids.txt
  ///
  /// Field no: 1.
  constexpr std::uint32_t id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return id_;
  }

  /// The identifier of the service.
  /// 
  ///  Must be unique across all services.
  /// 
  ///  Cannot be 0.
  /// 
  ///  To determine available service IDs for a new service, run
  /// 
  ///    horus cat service_ids.txt
  ///
  /// Field no: 1.
  std::uint32_t& mutable_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return id_;
  }

  /// Returns whether `id` (no 1) is set.
  constexpr bool has_id() const noexcept { return set_fields_[0]; }

  /// Clears `id` (no 1).
  void clear_id() & noexcept {
    set_fields_[0] = false;
    id_ = {};
  }

  /// Sets `id` (no 1) and returns `*this`.
  RpcServiceOptions& set_id(std::uint32_t id) & noexcept {
    set_fields_[0] = true;
    id_ = id;
    return *this;
  }
  /// Sets `id` (no 1) and returns `*this`.
  RpcServiceOptions&& set_id(std::uint32_t id) && noexcept {
    return std::move(set_id(id));
  }

  // Field `description` (no 2).
  // -----

  /// The description of the service shown in the generated code.
  ///
  /// Field no: 2.
  constexpr const CowBytes& description() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return description_;
  }

  /// If `description` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes description() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(description_);
  }

  /// The description of the service shown in the generated code.
  ///
  /// Field no: 2.
  CowBytes& mutable_description() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return description_;
  }

  /// Returns whether `description` (no 2) is set.
  constexpr bool has_description() const noexcept { return set_fields_[1]; }

  /// Clears `description` (no 2).
  void clear_description() & noexcept {
    set_fields_[1] = false;
    description_ = {};
  }

  /// Sets `description` (no 2) and returns `*this`.
  RpcServiceOptions& set_description(CowBytes&& description) & noexcept {
    set_fields_[1] = true;
    description_ = std::move(description);
    return *this;
  }
  /// Sets `description` (no 2) and returns `*this`.
  RpcServiceOptions&& set_description(CowBytes&& description) && noexcept {
    return std::move(set_description(std::move(description)));
  }

 private:
  /// @see id()
  std::uint32_t id_{};
  /// @see description()
  CowBytes description_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:31:3
class RpcMethodOptions_SubscribeMethod final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcMethodOptions_SubscribeMethod`.
  RpcMethodOptions_SubscribeMethod() noexcept = default;

  /// Move constructor.
  RpcMethodOptions_SubscribeMethod(RpcMethodOptions_SubscribeMethod&&) noexcept = default;
  /// Move assignment operator.
  RpcMethodOptions_SubscribeMethod& operator=(RpcMethodOptions_SubscribeMethod&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcMethodOptions_SubscribeMethod(const RpcMethodOptions_SubscribeMethod& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcMethodOptions_SubscribeMethod& operator=(const RpcMethodOptions_SubscribeMethod&) = delete;

  /// Default destructor.
  ~RpcMethodOptions_SubscribeMethod() noexcept final = default;

  /// Creates a `RpcMethodOptions_SubscribeMethod` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcMethodOptions_SubscribeMethod(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.RpcMethodOptions.SubscribeMethod`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.RpcMethodOptions.SubscribeMethod"; }

  /// The full name of the message: `horus.pb.RpcMethodOptions.SubscribeMethod`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `subscriber_name` (no 1).
  // -----

  /// The type name of the subscriber.
  ///
  /// Field no: 1.
  constexpr const CowBytes& subscriber_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return subscriber_name_;
  }

  /// If `subscriber_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes subscriber_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(subscriber_name_);
  }

  /// The type name of the subscriber.
  ///
  /// Field no: 1.
  CowBytes& mutable_subscriber_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return subscriber_name_;
  }

  /// Returns whether `subscriber_name` (no 1) is set.
  constexpr bool has_subscriber_name() const noexcept { return set_fields_[0]; }

  /// Clears `subscriber_name` (no 1).
  void clear_subscriber_name() & noexcept {
    set_fields_[0] = false;
    subscriber_name_ = {};
  }

  /// Sets `subscriber_name` (no 1) and returns `*this`.
  RpcMethodOptions_SubscribeMethod& set_subscriber_name(CowBytes&& subscriber_name) & noexcept {
    set_fields_[0] = true;
    subscriber_name_ = std::move(subscriber_name);
    return *this;
  }
  /// Sets `subscriber_name` (no 1) and returns `*this`.
  RpcMethodOptions_SubscribeMethod&& set_subscriber_name(CowBytes&& subscriber_name) && noexcept {
    return std::move(set_subscriber_name(std::move(subscriber_name)));
  }

 private:
  /// @see subscriber_name()
  CowBytes subscriber_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:35:3
class RpcMethodOptions_UnsubscribeMethod final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcMethodOptions_UnsubscribeMethod`.
  RpcMethodOptions_UnsubscribeMethod() noexcept = default;

  /// Move constructor.
  RpcMethodOptions_UnsubscribeMethod(RpcMethodOptions_UnsubscribeMethod&&) noexcept = default;
  /// Move assignment operator.
  RpcMethodOptions_UnsubscribeMethod& operator=(RpcMethodOptions_UnsubscribeMethod&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcMethodOptions_UnsubscribeMethod(const RpcMethodOptions_UnsubscribeMethod& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcMethodOptions_UnsubscribeMethod& operator=(const RpcMethodOptions_UnsubscribeMethod&) = delete;

  /// Default destructor.
  ~RpcMethodOptions_UnsubscribeMethod() noexcept final = default;

  /// Creates a `RpcMethodOptions_UnsubscribeMethod` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcMethodOptions_UnsubscribeMethod(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.RpcMethodOptions.UnsubscribeMethod`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.RpcMethodOptions.UnsubscribeMethod"; }

  /// The full name of the message: `horus.pb.RpcMethodOptions.UnsubscribeMethod`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `subscriber_name` (no 1).
  // -----

  /// The type name of the subscriber.
  ///
  /// Field no: 1.
  constexpr const CowBytes& subscriber_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return subscriber_name_;
  }

  /// If `subscriber_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes subscriber_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(subscriber_name_);
  }

  /// The type name of the subscriber.
  ///
  /// Field no: 1.
  CowBytes& mutable_subscriber_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return subscriber_name_;
  }

  /// Returns whether `subscriber_name` (no 1) is set.
  constexpr bool has_subscriber_name() const noexcept { return set_fields_[0]; }

  /// Clears `subscriber_name` (no 1).
  void clear_subscriber_name() & noexcept {
    set_fields_[0] = false;
    subscriber_name_ = {};
  }

  /// Sets `subscriber_name` (no 1) and returns `*this`.
  RpcMethodOptions_UnsubscribeMethod& set_subscriber_name(CowBytes&& subscriber_name) & noexcept {
    set_fields_[0] = true;
    subscriber_name_ = std::move(subscriber_name);
    return *this;
  }
  /// Sets `subscriber_name` (no 1) and returns `*this`.
  RpcMethodOptions_UnsubscribeMethod&& set_subscriber_name(CowBytes&& subscriber_name) && noexcept {
    return std::move(set_subscriber_name(std::move(subscriber_name)));
  }

 private:
  /// @see subscriber_name()
  CowBytes subscriber_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Protobuf method options for in house-RPC.
///
/// Source: horus/pb/rpc.proto:30:1
class RpcMethodOptions final : public PbMessage {
 public:
  /// @see RpcMethodOptions_SubscribeMethod
  using SubscribeMethod = RpcMethodOptions_SubscribeMethod;
  /// @see RpcMethodOptions_UnsubscribeMethod
  using UnsubscribeMethod = RpcMethodOptions_UnsubscribeMethod;

  /// Constructs a default-initialized `RpcMethodOptions`.
  RpcMethodOptions() noexcept = default;

  /// Move constructor.
  RpcMethodOptions(RpcMethodOptions&&) noexcept = default;
  /// Move assignment operator.
  RpcMethodOptions& operator=(RpcMethodOptions&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcMethodOptions(const RpcMethodOptions& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcMethodOptions& operator=(const RpcMethodOptions&) = delete;

  /// Default destructor.
  ~RpcMethodOptions() noexcept final = default;

  /// Creates a `RpcMethodOptions` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcMethodOptions(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.RpcMethodOptions`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.RpcMethodOptions"; }

  /// The full name of the message: `horus.pb.RpcMethodOptions`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `id` (no 1).
  // -----

  /// The identifier of the method.
  /// 
  ///  Must be unique across methods within a service.
  /// 
  ///  Cannot be 0.
  ///
  /// Field no: 1.
  constexpr std::uint32_t id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return id_;
  }

  /// The identifier of the method.
  /// 
  ///  Must be unique across methods within a service.
  /// 
  ///  Cannot be 0.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return id_;
  }

  /// Returns whether `id` (no 1) is set.
  constexpr bool has_id() const noexcept { return set_fields_[0]; }

  /// Clears `id` (no 1).
  void clear_id() & noexcept {
    set_fields_[0] = false;
    id_ = {};
  }

  /// Sets `id` (no 1) and returns `*this`.
  RpcMethodOptions& set_id(std::uint32_t id) & noexcept {
    set_fields_[0] = true;
    id_ = id;
    return *this;
  }
  /// Sets `id` (no 1) and returns `*this`.
  RpcMethodOptions&& set_id(std::uint32_t id) && noexcept {
    return std::move(set_id(id));
  }

  // Field `description` (no 2).
  // -----

  /// The description of the service or method shown in the generated code.
  ///
  /// Field no: 2.
  constexpr const CowBytes& description() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return description_;
  }

  /// If `description` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes description() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(description_);
  }

  /// The description of the service or method shown in the generated code.
  ///
  /// Field no: 2.
  CowBytes& mutable_description() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return description_;
  }

  /// Returns whether `description` (no 2) is set.
  constexpr bool has_description() const noexcept { return set_fields_[1]; }

  /// Clears `description` (no 2).
  void clear_description() & noexcept {
    set_fields_[1] = false;
    description_ = {};
  }

  /// Sets `description` (no 2) and returns `*this`.
  RpcMethodOptions& set_description(CowBytes&& description) & noexcept {
    set_fields_[1] = true;
    description_ = std::move(description);
    return *this;
  }
  /// Sets `description` (no 2) and returns `*this`.
  RpcMethodOptions&& set_description(CowBytes&& description) && noexcept {
    return std::move(set_description(std::move(description)));
  }

  // Field `subscribe` (no 3).
  // -----

  /// The method is meant to set up a subscription, and will have a default
  ///  implementation in C++.
  ///
  /// Field no: 3.
  constexpr const RpcMethodOptions_SubscribeMethod& subscribe() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return subscribe_;
  }

  /// If `subscribe` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  RpcMethodOptions_SubscribeMethod subscribe() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(subscribe_);
  }

  /// The method is meant to set up a subscription, and will have a default
  ///  implementation in C++.
  ///
  /// Field no: 3.
  RpcMethodOptions_SubscribeMethod& mutable_subscribe() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    clear_type();
    type_ = TypeOneof::kSubscribe;
    set_fields_[2] = true;
    return subscribe_;
  }

  /// Returns whether `subscribe` (no 3) is set.
  constexpr bool has_subscribe() const noexcept { return set_fields_[2]; }

  /// Clears `subscribe` (no 3).
  void clear_subscribe() & noexcept {
    type_ = {};
    set_fields_[2] = false;
    subscribe_ = {};
  }

  /// Sets `subscribe` (no 3) and returns `*this`.
  RpcMethodOptions& set_subscribe(RpcMethodOptions_SubscribeMethod&& subscribe) & noexcept {
    clear_type();
    type_ = TypeOneof::kSubscribe;
    set_fields_[2] = true;
    subscribe_ = std::move(subscribe);
    return *this;
  }
  /// Sets `subscribe` (no 3) and returns `*this`.
  RpcMethodOptions&& set_subscribe(RpcMethodOptions_SubscribeMethod&& subscribe) && noexcept {
    return std::move(set_subscribe(std::move(subscribe)));
  }

  // Field `unsubscribe` (no 4).
  // -----

  /// The method is meant to tear down a subscription, and will have a default
  ///  implementation in C++.
  ///
  /// Field no: 4.
  constexpr const RpcMethodOptions_UnsubscribeMethod& unsubscribe() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return unsubscribe_;
  }

  /// If `unsubscribe` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  RpcMethodOptions_UnsubscribeMethod unsubscribe() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(unsubscribe_);
  }

  /// The method is meant to tear down a subscription, and will have a default
  ///  implementation in C++.
  ///
  /// Field no: 4.
  RpcMethodOptions_UnsubscribeMethod& mutable_unsubscribe() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    clear_type();
    type_ = TypeOneof::kUnsubscribe;
    set_fields_[3] = true;
    return unsubscribe_;
  }

  /// Returns whether `unsubscribe` (no 4) is set.
  constexpr bool has_unsubscribe() const noexcept { return set_fields_[3]; }

  /// Clears `unsubscribe` (no 4).
  void clear_unsubscribe() & noexcept {
    type_ = {};
    set_fields_[3] = false;
    unsubscribe_ = {};
  }

  /// Sets `unsubscribe` (no 4) and returns `*this`.
  RpcMethodOptions& set_unsubscribe(RpcMethodOptions_UnsubscribeMethod&& unsubscribe) & noexcept {
    clear_type();
    type_ = TypeOneof::kUnsubscribe;
    set_fields_[3] = true;
    unsubscribe_ = std::move(unsubscribe);
    return *this;
  }
  /// Sets `unsubscribe` (no 4) and returns `*this`.
  RpcMethodOptions&& set_unsubscribe(RpcMethodOptions_UnsubscribeMethod&& unsubscribe) && noexcept {
    return std::move(set_unsubscribe(std::move(unsubscribe)));
  }

  // Oneof `type`.
  // -----

  /// Return value of `type_case()`.
  enum class TypeOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see subscribe()
    kSubscribe = 3,
    /// @see unsubscribe()
    kUnsubscribe = 4,
  };

  /// Returns the current case set in `type`.
  constexpr TypeOneof type_case() const noexcept {
    return type_;
  }

  /// Clears the oneof value in `type`.
  void clear_type() noexcept {
    switch (type_) {
      case TypeOneof::kSubscribe: {
        clear_subscribe();
        break;
      }
      case TypeOneof::kUnsubscribe: {
        clear_unsubscribe();
        break;
      }
      case TypeOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see id()
  std::uint32_t id_{};
  /// @see description()
  CowBytes description_{};
  /// @see subscribe()
  RpcMethodOptions_SubscribeMethod subscribe_{};
  /// @see unsubscribe()
  RpcMethodOptions_UnsubscribeMethod unsubscribe_{};

  /// @see type_case()
  TypeOneof type_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:69:1
class DefaultSubscribeRequest final : public PbMessage {
 public:

  /// Constructs a default-initialized `DefaultSubscribeRequest`.
  DefaultSubscribeRequest() noexcept = default;

  /// Move constructor.
  DefaultSubscribeRequest(DefaultSubscribeRequest&&) noexcept = default;
  /// Move assignment operator.
  DefaultSubscribeRequest& operator=(DefaultSubscribeRequest&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DefaultSubscribeRequest(const DefaultSubscribeRequest&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DefaultSubscribeRequest& operator=(const DefaultSubscribeRequest&) = delete;

  /// Default destructor.
  ~DefaultSubscribeRequest() noexcept final = default;

  /// Creates a `DefaultSubscribeRequest` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DefaultSubscribeRequest(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DefaultSubscribeRequest`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DefaultSubscribeRequest"; }

  /// The full name of the message: `horus.pb.DefaultSubscribeRequest`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:71:1
class DefaultSubscribeResponse final : public PbMessage {
 public:

  /// Constructs a default-initialized `DefaultSubscribeResponse`.
  DefaultSubscribeResponse() noexcept = default;

  /// Move constructor.
  DefaultSubscribeResponse(DefaultSubscribeResponse&&) noexcept = default;
  /// Move assignment operator.
  DefaultSubscribeResponse& operator=(DefaultSubscribeResponse&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DefaultSubscribeResponse(const DefaultSubscribeResponse& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DefaultSubscribeResponse& operator=(const DefaultSubscribeResponse&) = delete;

  /// Default destructor.
  ~DefaultSubscribeResponse() noexcept final = default;

  /// Creates a `DefaultSubscribeResponse` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DefaultSubscribeResponse(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DefaultSubscribeResponse`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DefaultSubscribeResponse"; }

  /// The full name of the message: `horus.pb.DefaultSubscribeResponse`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `connection_error` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::RpcConnectionError& connection_error() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return connection_error_;
  }

  /// If `connection_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::RpcConnectionError connection_error() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(connection_error_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::RpcConnectionError& mutable_connection_error() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    clear_error();
    error_ = ErrorOneof::kConnectionError;
    set_fields_[0] = true;
    return connection_error_;
  }

  /// Returns whether `connection_error` (no 1) is set.
  constexpr bool has_connection_error() const noexcept { return set_fields_[0]; }

  /// Clears `connection_error` (no 1).
  void clear_connection_error() & noexcept {
    error_ = {};
    set_fields_[0] = false;
    connection_error_ = {};
  }

  /// Sets `connection_error` (no 1) and returns `*this`.
  DefaultSubscribeResponse& set_connection_error(logs::RpcConnectionError&& connection_error) & noexcept {
    clear_error();
    error_ = ErrorOneof::kConnectionError;
    set_fields_[0] = true;
    connection_error_ = std::move(connection_error);
    return *this;
  }
  /// Sets `connection_error` (no 1) and returns `*this`.
  DefaultSubscribeResponse&& set_connection_error(logs::RpcConnectionError&& connection_error) && noexcept {
    return std::move(set_connection_error(std::move(connection_error)));
  }

  // Oneof `error`.
  // -----

  /// Return value of `error_case()`.
  enum class ErrorOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see connection_error()
    kConnectionError = 1,
  };

  /// Returns the current case set in `error`.
  constexpr ErrorOneof error_case() const noexcept {
    return error_;
  }

  /// Clears the oneof value in `error`.
  void clear_error() noexcept {
    switch (error_) {
      case ErrorOneof::kConnectionError: {
        clear_connection_error();
        break;
      }
      case ErrorOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see connection_error()
  logs::RpcConnectionError connection_error_{};

  /// @see error_case()
  ErrorOneof error_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:77:1
class DefaultUnsubscribeRequest final : public PbMessage {
 public:

  /// Constructs a default-initialized `DefaultUnsubscribeRequest`.
  DefaultUnsubscribeRequest() noexcept = default;

  /// Move constructor.
  DefaultUnsubscribeRequest(DefaultUnsubscribeRequest&&) noexcept = default;
  /// Move assignment operator.
  DefaultUnsubscribeRequest& operator=(DefaultUnsubscribeRequest&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DefaultUnsubscribeRequest(const DefaultUnsubscribeRequest&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DefaultUnsubscribeRequest& operator=(const DefaultUnsubscribeRequest&) = delete;

  /// Default destructor.
  ~DefaultUnsubscribeRequest() noexcept final = default;

  /// Creates a `DefaultUnsubscribeRequest` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DefaultUnsubscribeRequest(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DefaultUnsubscribeRequest`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DefaultUnsubscribeRequest"; }

  /// The full name of the message: `horus.pb.DefaultUnsubscribeRequest`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/rpc.proto:79:1
class DefaultUnsubscribeResponse final : public PbMessage {
 public:

  /// Constructs a default-initialized `DefaultUnsubscribeResponse`.
  DefaultUnsubscribeResponse() noexcept = default;

  /// Move constructor.
  DefaultUnsubscribeResponse(DefaultUnsubscribeResponse&&) noexcept = default;
  /// Move assignment operator.
  DefaultUnsubscribeResponse& operator=(DefaultUnsubscribeResponse&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DefaultUnsubscribeResponse(const DefaultUnsubscribeResponse& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DefaultUnsubscribeResponse& operator=(const DefaultUnsubscribeResponse&) = delete;

  /// Default destructor.
  ~DefaultUnsubscribeResponse() noexcept final = default;

  /// Creates a `DefaultUnsubscribeResponse` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DefaultUnsubscribeResponse(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DefaultUnsubscribeResponse`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DefaultUnsubscribeResponse"; }

  /// The full name of the message: `horus.pb.DefaultUnsubscribeResponse`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `disconnection_error` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::RpcDisconnectionError& disconnection_error() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return disconnection_error_;
  }

  /// If `disconnection_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::RpcDisconnectionError disconnection_error() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(disconnection_error_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::RpcDisconnectionError& mutable_disconnection_error() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    clear_error();
    error_ = ErrorOneof::kDisconnectionError;
    set_fields_[0] = true;
    return disconnection_error_;
  }

  /// Returns whether `disconnection_error` (no 1) is set.
  constexpr bool has_disconnection_error() const noexcept { return set_fields_[0]; }

  /// Clears `disconnection_error` (no 1).
  void clear_disconnection_error() & noexcept {
    error_ = {};
    set_fields_[0] = false;
    disconnection_error_ = {};
  }

  /// Sets `disconnection_error` (no 1) and returns `*this`.
  DefaultUnsubscribeResponse& set_disconnection_error(logs::RpcDisconnectionError&& disconnection_error) & noexcept {
    clear_error();
    error_ = ErrorOneof::kDisconnectionError;
    set_fields_[0] = true;
    disconnection_error_ = std::move(disconnection_error);
    return *this;
  }
  /// Sets `disconnection_error` (no 1) and returns `*this`.
  DefaultUnsubscribeResponse&& set_disconnection_error(logs::RpcDisconnectionError&& disconnection_error) && noexcept {
    return std::move(set_disconnection_error(std::move(disconnection_error)));
  }

  // Oneof `error`.
  // -----

  /// Return value of `error_case()`.
  enum class ErrorOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see disconnection_error()
    kDisconnectionError = 1,
  };

  /// Returns the current case set in `error`.
  constexpr ErrorOneof error_case() const noexcept {
    return error_;
  }

  /// Clears the oneof value in `error`.
  void clear_error() noexcept {
    switch (error_) {
      case ErrorOneof::kDisconnectionError: {
        clear_disconnection_error();
        break;
      }
      case ErrorOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see disconnection_error()
  logs::RpcDisconnectionError disconnection_error_{};

  /// @see error_case()
  ErrorOneof error_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_RPC_PB_H_
