#ifndef HORUS_PB_PROFILING_PB_H_
#define HORUS_PB_PROFILING_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/profiling.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/config/metadata_pb.h"
#include "horus/pb/cow_bytes.h"
#include "horus/pb/cow_repeated.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/pb/types.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Enum declarations

/// No documentation.
///
/// Source: horus/pb/profiling.proto:9:3
enum class ProfilingSet_ProfiledService : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kServiceUnspecified = 0,
  /// No documentation.
  kPreprocessingService = 1,
  /// No documentation.
  kDetectionService = 2,

  /// Unknown value read from the wire.
  kUnknownWireValue = 3,
};

/// No documentation.
///
/// Source: horus/pb/profiling.proto:17:7
enum class ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// No documentation.
  kIncrease = 1,
  /// No documentation.
  kDecrease = 2,

  /// Unknown value read from the wire.
  kUnknownWireValue = 3,
};

// MARK: Message forward declarations

class ProfilingSet_ProfiledDuration_PerformanceHint;
class ProfilingSet_ProfiledDuration;
class ProfilingSet_ProfiledDurationMapEntry;
class ProfilingSet_ResourceUsage;
class ProfilingSet;
class ServiceProfiling;
class PreprocessingServicePointCloudProfiling;
class FrameProfiling;
class BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry;
class BundledFrameProfilingSet;
class ProfilingInfo;

// MARK: Message declarations

/// No documentation.
///
/// Source: horus/pb/profiling.proto:16:5
class ProfilingSet_ProfiledDuration_PerformanceHint final : public PbMessage {
 public:
  /// @see ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction
  using ConfigParameterAction = ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction;

  /// Constructs a default-initialized `ProfilingSet_ProfiledDuration_PerformanceHint`.
  ProfilingSet_ProfiledDuration_PerformanceHint() noexcept = default;

  /// Move constructor.
  ProfilingSet_ProfiledDuration_PerformanceHint(ProfilingSet_ProfiledDuration_PerformanceHint&&) noexcept = default;
  /// Move assignment operator.
  ProfilingSet_ProfiledDuration_PerformanceHint& operator=(ProfilingSet_ProfiledDuration_PerformanceHint&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingSet_ProfiledDuration_PerformanceHint(const ProfilingSet_ProfiledDuration_PerformanceHint& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingSet_ProfiledDuration_PerformanceHint& operator=(const ProfilingSet_ProfiledDuration_PerformanceHint&) = delete;

  /// Default destructor.
  ~ProfilingSet_ProfiledDuration_PerformanceHint() noexcept final = default;

  /// Creates a `ProfilingSet_ProfiledDuration_PerformanceHint` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingSet_ProfiledDuration_PerformanceHint(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDuration.PerformanceHint`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingSet.ProfiledDuration.PerformanceHint"; }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDuration.PerformanceHint`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `config_parameter_action` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction config_parameter_action() const& noexcept HORUS_LIFETIME_BOUND {
    return config_parameter_action_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction& mutable_config_parameter_action() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return config_parameter_action_;
  }

  /// Returns whether `config_parameter_action` (no 1) is set.
  constexpr bool has_config_parameter_action() const noexcept { return set_fields_[0]; }

  /// Clears `config_parameter_action` (no 1).
  void clear_config_parameter_action() & noexcept {
    set_fields_[0] = false;
    config_parameter_action_ = {};
  }

  /// Sets `config_parameter_action` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDuration_PerformanceHint& set_config_parameter_action(ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction config_parameter_action) & noexcept {
    set_fields_[0] = true;
    config_parameter_action_ = config_parameter_action;
    return *this;
  }
  /// Sets `config_parameter_action` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDuration_PerformanceHint&& set_config_parameter_action(ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction config_parameter_action) && noexcept {
    return std::move(set_config_parameter_action(config_parameter_action));
  }

  // Field `config_parameter_name` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& config_parameter_name() const& noexcept HORUS_LIFETIME_BOUND {
    return config_parameter_name_;
  }

  /// If `config_parameter_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes config_parameter_name() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(config_parameter_name_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_config_parameter_name() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return config_parameter_name_;
  }

  /// Returns whether `config_parameter_name` (no 2) is set.
  constexpr bool has_config_parameter_name() const noexcept { return set_fields_[1]; }

  /// Clears `config_parameter_name` (no 2).
  void clear_config_parameter_name() & noexcept {
    set_fields_[1] = false;
    config_parameter_name_ = {};
  }

  /// Sets `config_parameter_name` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDuration_PerformanceHint& set_config_parameter_name(CowBytes&& config_parameter_name) & noexcept {
    set_fields_[1] = true;
    config_parameter_name_ = std::move(config_parameter_name);
    return *this;
  }
  /// Sets `config_parameter_name` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDuration_PerformanceHint&& set_config_parameter_name(CowBytes&& config_parameter_name) && noexcept {
    return std::move(set_config_parameter_name(std::move(config_parameter_name)));
  }

 private:
  /// @see config_parameter_action()
  ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction config_parameter_action_{};
  /// @see config_parameter_name()
  CowBytes config_parameter_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/profiling.proto:15:3
class ProfilingSet_ProfiledDuration final : public PbMessage {
 public:
  /// @see ProfilingSet_ProfiledDuration_PerformanceHint
  using PerformanceHint = ProfilingSet_ProfiledDuration_PerformanceHint;

  /// Constructs a default-initialized `ProfilingSet_ProfiledDuration`.
  ProfilingSet_ProfiledDuration() noexcept = default;

  /// Move constructor.
  ProfilingSet_ProfiledDuration(ProfilingSet_ProfiledDuration&&) noexcept = default;
  /// Move assignment operator.
  ProfilingSet_ProfiledDuration& operator=(ProfilingSet_ProfiledDuration&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingSet_ProfiledDuration(const ProfilingSet_ProfiledDuration& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingSet_ProfiledDuration& operator=(const ProfilingSet_ProfiledDuration&) = delete;

  /// Default destructor.
  ~ProfilingSet_ProfiledDuration() noexcept final = default;

  /// Creates a `ProfilingSet_ProfiledDuration` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingSet_ProfiledDuration(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDuration`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingSet.ProfiledDuration"; }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDuration`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `duration` (no 1).
  // -----

  /// / The duration of the profiled section.
  ///
  /// Field no: 1.
  constexpr const Duration& duration() const& noexcept HORUS_LIFETIME_BOUND {
    return duration_;
  }

  /// If `duration` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  Duration duration() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(duration_);
  }

  /// / The duration of the profiled section.
  ///
  /// Field no: 1.
  Duration& mutable_duration() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return duration_;
  }

  /// Returns whether `duration` (no 1) is set.
  constexpr bool has_duration() const noexcept { return set_fields_[0]; }

  /// Clears `duration` (no 1).
  void clear_duration() & noexcept {
    set_fields_[0] = false;
    duration_ = {};
  }

  /// Sets `duration` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDuration& set_duration(Duration&& duration) & noexcept {
    set_fields_[0] = true;
    duration_ = std::move(duration);
    return *this;
  }
  /// Sets `duration` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDuration&& set_duration(Duration&& duration) && noexcept {
    return std::move(set_duration(std::move(duration)));
  }

  // Field `performance_hints` (no 2).
  // -----

  /// / A list of hints on how to improve the profiled section.
  ///
  /// Field no: 2.
  constexpr const CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint>& performance_hints() const& noexcept HORUS_LIFETIME_BOUND {
    return performance_hints_;
  }

  /// If `performance_hints` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint> performance_hints() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(performance_hints_);
  }

  /// / A list of hints on how to improve the profiled section.
  ///
  /// Field no: 2.
  CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint>& mutable_performance_hints() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return performance_hints_;
  }

  /// Returns whether `performance_hints` (no 2) is set.
  constexpr bool has_performance_hints() const noexcept { return set_fields_[1]; }

  /// Clears `performance_hints` (no 2).
  void clear_performance_hints() & noexcept {
    set_fields_[1] = false;
    performance_hints_ = {};
  }

  /// Sets `performance_hints` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDuration& set_performance_hints(CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint>&& performance_hints) & noexcept {
    set_fields_[1] = true;
    performance_hints_ = std::move(performance_hints);
    return *this;
  }
  /// Sets `performance_hints` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDuration&& set_performance_hints(CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint>&& performance_hints) && noexcept {
    return std::move(set_performance_hints(std::move(performance_hints)));
  }

 private:
  /// @see duration()
  Duration duration_{};
  /// @see performance_hints()
  CowRepeated<ProfilingSet_ProfiledDuration_PerformanceHint> performance_hints_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// / A map of profiling measurements id to profiled durations.
///
/// Source: horus/pb/profiling.proto:36:3
class ProfilingSet_ProfiledDurationMapEntry final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProfilingSet_ProfiledDurationMapEntry`.
  ProfilingSet_ProfiledDurationMapEntry() noexcept = default;

  /// Move constructor.
  ProfilingSet_ProfiledDurationMapEntry(ProfilingSet_ProfiledDurationMapEntry&&) noexcept = default;
  /// Move assignment operator.
  ProfilingSet_ProfiledDurationMapEntry& operator=(ProfilingSet_ProfiledDurationMapEntry&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingSet_ProfiledDurationMapEntry(const ProfilingSet_ProfiledDurationMapEntry& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingSet_ProfiledDurationMapEntry& operator=(const ProfilingSet_ProfiledDurationMapEntry&) = delete;

  /// Default destructor.
  ~ProfilingSet_ProfiledDurationMapEntry() noexcept final = default;

  /// Creates a `ProfilingSet_ProfiledDurationMapEntry` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingSet_ProfiledDurationMapEntry(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDurationMapEntry`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingSet.ProfiledDurationMapEntry"; }

  /// The full name of the message: `horus.pb.ProfilingSet.ProfiledDurationMapEntry`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `key` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& key() const& noexcept HORUS_LIFETIME_BOUND {
    return key_;
  }

  /// If `key` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes key() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(key_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_key() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return key_;
  }

  /// Returns whether `key` (no 1) is set.
  constexpr bool has_key() const noexcept { return set_fields_[0]; }

  /// Clears `key` (no 1).
  void clear_key() & noexcept {
    set_fields_[0] = false;
    key_ = {};
  }

  /// Sets `key` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDurationMapEntry& set_key(CowBytes&& key) & noexcept {
    set_fields_[0] = true;
    key_ = std::move(key);
    return *this;
  }
  /// Sets `key` (no 1) and returns `*this`.
  ProfilingSet_ProfiledDurationMapEntry&& set_key(CowBytes&& key) && noexcept {
    return std::move(set_key(std::move(key)));
  }

  // Field `value` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const ProfilingSet_ProfiledDuration& value() const& noexcept HORUS_LIFETIME_BOUND {
    return value_;
  }

  /// If `value` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  ProfilingSet_ProfiledDuration value() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(value_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  ProfilingSet_ProfiledDuration& mutable_value() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return value_;
  }

  /// Returns whether `value` (no 2) is set.
  constexpr bool has_value() const noexcept { return set_fields_[1]; }

  /// Clears `value` (no 2).
  void clear_value() & noexcept {
    set_fields_[1] = false;
    value_ = {};
  }

  /// Sets `value` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDurationMapEntry& set_value(ProfilingSet_ProfiledDuration&& value) & noexcept {
    set_fields_[1] = true;
    value_ = std::move(value);
    return *this;
  }
  /// Sets `value` (no 2) and returns `*this`.
  ProfilingSet_ProfiledDurationMapEntry&& set_value(ProfilingSet_ProfiledDuration&& value) && noexcept {
    return std::move(set_value(std::move(value)));
  }

 private:
  /// @see key()
  CowBytes key_{};
  /// @see value()
  ProfilingSet_ProfiledDuration value_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/profiling.proto:39:3
class ProfilingSet_ResourceUsage final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProfilingSet_ResourceUsage`.
  ProfilingSet_ResourceUsage() noexcept = default;

  /// Move constructor.
  ProfilingSet_ResourceUsage(ProfilingSet_ResourceUsage&&) noexcept = default;
  /// Move assignment operator.
  ProfilingSet_ResourceUsage& operator=(ProfilingSet_ResourceUsage&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingSet_ResourceUsage(const ProfilingSet_ResourceUsage& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingSet_ResourceUsage& operator=(const ProfilingSet_ResourceUsage&) = delete;

  /// Default destructor.
  ~ProfilingSet_ResourceUsage() noexcept final = default;

  /// Creates a `ProfilingSet_ResourceUsage` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingSet_ResourceUsage(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingSet.ResourceUsage`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingSet.ResourceUsage"; }

  /// The full name of the message: `horus.pb.ProfilingSet.ResourceUsage`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `cpu_usage_percentage` (no 1).
  // -----

  /// / CPU usage of the service in percentage.
  /// / The percentage can be above 100% if multiple cores are used.
  ///
  /// Field no: 1.
  constexpr std::uint32_t cpu_usage_percentage() const& noexcept HORUS_LIFETIME_BOUND {
    return cpu_usage_percentage_;
  }

  /// / CPU usage of the service in percentage.
  /// / The percentage can be above 100% if multiple cores are used.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_cpu_usage_percentage() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return cpu_usage_percentage_;
  }

  /// Returns whether `cpu_usage_percentage` (no 1) is set.
  constexpr bool has_cpu_usage_percentage() const noexcept { return set_fields_[0]; }

  /// Clears `cpu_usage_percentage` (no 1).
  void clear_cpu_usage_percentage() & noexcept {
    set_fields_[0] = false;
    cpu_usage_percentage_ = {};
  }

  /// Sets `cpu_usage_percentage` (no 1) and returns `*this`.
  ProfilingSet_ResourceUsage& set_cpu_usage_percentage(std::uint32_t cpu_usage_percentage) & noexcept {
    set_fields_[0] = true;
    cpu_usage_percentage_ = cpu_usage_percentage;
    return *this;
  }
  /// Sets `cpu_usage_percentage` (no 1) and returns `*this`.
  ProfilingSet_ResourceUsage&& set_cpu_usage_percentage(std::uint32_t cpu_usage_percentage) && noexcept {
    return std::move(set_cpu_usage_percentage(cpu_usage_percentage));
  }

  // Field `memory_usage` (no 2).
  // -----

  /// / Memory usage of the service in bytes.
  ///
  /// Field no: 2.
  constexpr std::uint64_t memory_usage() const& noexcept HORUS_LIFETIME_BOUND {
    return memory_usage_;
  }

  /// / Memory usage of the service in bytes.
  ///
  /// Field no: 2.
  std::uint64_t& mutable_memory_usage() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return memory_usage_;
  }

  /// Returns whether `memory_usage` (no 2) is set.
  constexpr bool has_memory_usage() const noexcept { return set_fields_[1]; }

  /// Clears `memory_usage` (no 2).
  void clear_memory_usage() & noexcept {
    set_fields_[1] = false;
    memory_usage_ = {};
  }

  /// Sets `memory_usage` (no 2) and returns `*this`.
  ProfilingSet_ResourceUsage& set_memory_usage(std::uint64_t memory_usage) & noexcept {
    set_fields_[1] = true;
    memory_usage_ = memory_usage;
    return *this;
  }
  /// Sets `memory_usage` (no 2) and returns `*this`.
  ProfilingSet_ResourceUsage&& set_memory_usage(std::uint64_t memory_usage) && noexcept {
    return std::move(set_memory_usage(memory_usage));
  }

 private:
  /// @see cpu_usage_percentage()
  std::uint32_t cpu_usage_percentage_{};
  /// @see memory_usage()
  std::uint64_t memory_usage_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// / A profiling set.
///
/// Source: horus/pb/profiling.proto:8:1
class ProfilingSet final : public PbMessage {
 public:
  /// @see ProfilingSet_ProfiledDuration
  using ProfiledDuration = ProfilingSet_ProfiledDuration;
  /// @see ProfilingSet_ProfiledDurationMapEntry
  using ProfiledDurationMapEntry = ProfilingSet_ProfiledDurationMapEntry;
  /// @see ProfilingSet_ProfiledService
  using ProfiledService = ProfilingSet_ProfiledService;
  /// @see ProfilingSet_ResourceUsage
  using ResourceUsage = ProfilingSet_ResourceUsage;

  /// Constructs a default-initialized `ProfilingSet`.
  ProfilingSet() noexcept = default;

  /// Move constructor.
  ProfilingSet(ProfilingSet&&) noexcept = default;
  /// Move assignment operator.
  ProfilingSet& operator=(ProfilingSet&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingSet(const ProfilingSet& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingSet& operator=(const ProfilingSet&) = delete;

  /// Default destructor.
  ~ProfilingSet() noexcept final = default;

  /// Creates a `ProfilingSet` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingSet(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingSet`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingSet"; }

  /// The full name of the message: `horus.pb.ProfilingSet`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `profiled_service` (no 1).
  // -----

  /// / The profiled service.
  ///
  /// Field no: 1.
  constexpr ProfilingSet_ProfiledService profiled_service() const& noexcept HORUS_LIFETIME_BOUND {
    return profiled_service_;
  }

  /// / The profiled service.
  ///
  /// Field no: 1.
  ProfilingSet_ProfiledService& mutable_profiled_service() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return profiled_service_;
  }

  /// Returns whether `profiled_service` (no 1) is set.
  constexpr bool has_profiled_service() const noexcept { return set_fields_[0]; }

  /// Clears `profiled_service` (no 1).
  void clear_profiled_service() & noexcept {
    set_fields_[0] = false;
    profiled_service_ = {};
  }

  /// Sets `profiled_service` (no 1) and returns `*this`.
  ProfilingSet& set_profiled_service(ProfilingSet_ProfiledService profiled_service) & noexcept {
    set_fields_[0] = true;
    profiled_service_ = profiled_service;
    return *this;
  }
  /// Sets `profiled_service` (no 1) and returns `*this`.
  ProfilingSet&& set_profiled_service(ProfilingSet_ProfiledService profiled_service) && noexcept {
    return std::move(set_profiled_service(profiled_service));
  }

  // Field `processing_times` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowRepeated<ProfilingSet_ProfiledDurationMapEntry>& processing_times() const& noexcept HORUS_LIFETIME_BOUND {
    return processing_times_;
  }

  /// If `processing_times` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowRepeated<ProfilingSet_ProfiledDurationMapEntry> processing_times() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(processing_times_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowRepeated<ProfilingSet_ProfiledDurationMapEntry>& mutable_processing_times() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return processing_times_;
  }

  /// Returns whether `processing_times` (no 2) is set.
  constexpr bool has_processing_times() const noexcept { return set_fields_[1]; }

  /// Clears `processing_times` (no 2).
  void clear_processing_times() & noexcept {
    set_fields_[1] = false;
    processing_times_ = {};
  }

  /// Sets `processing_times` (no 2) and returns `*this`.
  ProfilingSet& set_processing_times(CowRepeated<ProfilingSet_ProfiledDurationMapEntry>&& processing_times) & noexcept {
    set_fields_[1] = true;
    processing_times_ = std::move(processing_times);
    return *this;
  }
  /// Sets `processing_times` (no 2) and returns `*this`.
  ProfilingSet&& set_processing_times(CowRepeated<ProfilingSet_ProfiledDurationMapEntry>&& processing_times) && noexcept {
    return std::move(set_processing_times(std::move(processing_times)));
  }

  // Field `resource_usage` (no 3).
  // -----

  /// / Resource usage profiling of the service.
  ///
  /// Field no: 3.
  constexpr const ProfilingSet_ResourceUsage& resource_usage() const& noexcept HORUS_LIFETIME_BOUND {
    return resource_usage_;
  }

  /// If `resource_usage` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  ProfilingSet_ResourceUsage resource_usage() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(resource_usage_);
  }

  /// / Resource usage profiling of the service.
  ///
  /// Field no: 3.
  ProfilingSet_ResourceUsage& mutable_resource_usage() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return resource_usage_;
  }

  /// Returns whether `resource_usage` (no 3) is set.
  constexpr bool has_resource_usage() const noexcept { return set_fields_[2]; }

  /// Clears `resource_usage` (no 3).
  void clear_resource_usage() & noexcept {
    set_fields_[2] = false;
    resource_usage_ = {};
  }

  /// Sets `resource_usage` (no 3) and returns `*this`.
  ProfilingSet& set_resource_usage(ProfilingSet_ResourceUsage&& resource_usage) & noexcept {
    set_fields_[2] = true;
    resource_usage_ = std::move(resource_usage);
    return *this;
  }
  /// Sets `resource_usage` (no 3) and returns `*this`.
  ProfilingSet&& set_resource_usage(ProfilingSet_ResourceUsage&& resource_usage) && noexcept {
    return std::move(set_resource_usage(std::move(resource_usage)));
  }

 private:
  /// @see profiled_service()
  ProfilingSet_ProfiledService profiled_service_{};
  /// @see processing_times()
  CowRepeated<ProfilingSet_ProfiledDurationMapEntry> processing_times_{};
  /// @see resource_usage()
  ProfilingSet_ResourceUsage resource_usage_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// / The profiling of a service including the total service latency (total
/// / processing time + total idle time) and the profiling details.
///
/// Source: horus/pb/profiling.proto:53:1
class ServiceProfiling final : public PbMessage {
 public:

  /// Constructs a default-initialized `ServiceProfiling`.
  ServiceProfiling() noexcept = default;

  /// Move constructor.
  ServiceProfiling(ServiceProfiling&&) noexcept = default;
  /// Move assignment operator.
  ServiceProfiling& operator=(ServiceProfiling&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ServiceProfiling(const ServiceProfiling& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ServiceProfiling& operator=(const ServiceProfiling&) = delete;

  /// Default destructor.
  ~ServiceProfiling() noexcept final = default;

  /// Creates a `ServiceProfiling` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ServiceProfiling(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ServiceProfiling`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ServiceProfiling"; }

  /// The full name of the message: `horus.pb.ServiceProfiling`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details_profiling_set` (no 1).
  // -----

  /// / The profiling details.
  ///
  /// Field no: 1.
  constexpr const ProfilingSet& details_profiling_set() const& noexcept HORUS_LIFETIME_BOUND {
    return details_profiling_set_;
  }

  /// If `details_profiling_set` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  ProfilingSet details_profiling_set() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_profiling_set_);
  }

  /// / The profiling details.
  ///
  /// Field no: 1.
  ProfilingSet& mutable_details_profiling_set() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_profiling_set_;
  }

  /// Returns whether `details_profiling_set` (no 1) is set.
  constexpr bool has_details_profiling_set() const noexcept { return set_fields_[0]; }

  /// Clears `details_profiling_set` (no 1).
  void clear_details_profiling_set() & noexcept {
    set_fields_[0] = false;
    details_profiling_set_ = {};
  }

  /// Sets `details_profiling_set` (no 1) and returns `*this`.
  ServiceProfiling& set_details_profiling_set(ProfilingSet&& details_profiling_set) & noexcept {
    set_fields_[0] = true;
    details_profiling_set_ = std::move(details_profiling_set);
    return *this;
  }
  /// Sets `details_profiling_set` (no 1) and returns `*this`.
  ServiceProfiling&& set_details_profiling_set(ProfilingSet&& details_profiling_set) && noexcept {
    return std::move(set_details_profiling_set(std::move(details_profiling_set)));
  }

  // Field `total_service_latency` (no 2).
  // -----

  /// / The total service latency which is a sum of the total idle time and the
  /// / total processing time (when the data is actually being processed)
  ///
  /// Field no: 2.
  constexpr const Duration& total_service_latency() const& noexcept HORUS_LIFETIME_BOUND {
    return total_service_latency_;
  }

  /// If `total_service_latency` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  Duration total_service_latency() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(total_service_latency_);
  }

  /// / The total service latency which is a sum of the total idle time and the
  /// / total processing time (when the data is actually being processed)
  ///
  /// Field no: 2.
  Duration& mutable_total_service_latency() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return total_service_latency_;
  }

  /// Returns whether `total_service_latency` (no 2) is set.
  constexpr bool has_total_service_latency() const noexcept { return set_fields_[1]; }

  /// Clears `total_service_latency` (no 2).
  void clear_total_service_latency() & noexcept {
    set_fields_[1] = false;
    total_service_latency_ = {};
  }

  /// Sets `total_service_latency` (no 2) and returns `*this`.
  ServiceProfiling& set_total_service_latency(Duration&& total_service_latency) & noexcept {
    set_fields_[1] = true;
    total_service_latency_ = std::move(total_service_latency);
    return *this;
  }
  /// Sets `total_service_latency` (no 2) and returns `*this`.
  ServiceProfiling&& set_total_service_latency(Duration&& total_service_latency) && noexcept {
    return std::move(set_total_service_latency(std::move(total_service_latency)));
  }

  // Field `idle_time_before_processing` (no 4).
  // -----

  /// / The idle time before the service starts processing the data, i.e. from
  /// / bundle time to the first processing time.
  ///
  /// Field no: 4.
  constexpr const Duration& idle_time_before_processing() const& noexcept HORUS_LIFETIME_BOUND {
    return idle_time_before_processing_;
  }

  /// If `idle_time_before_processing` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  Duration idle_time_before_processing() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(idle_time_before_processing_);
  }

  /// / The idle time before the service starts processing the data, i.e. from
  /// / bundle time to the first processing time.
  ///
  /// Field no: 4.
  Duration& mutable_idle_time_before_processing() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return idle_time_before_processing_;
  }

  /// Returns whether `idle_time_before_processing` (no 4) is set.
  constexpr bool has_idle_time_before_processing() const noexcept { return set_fields_[2]; }

  /// Clears `idle_time_before_processing` (no 4).
  void clear_idle_time_before_processing() & noexcept {
    set_fields_[2] = false;
    idle_time_before_processing_ = {};
  }

  /// Sets `idle_time_before_processing` (no 4) and returns `*this`.
  ServiceProfiling& set_idle_time_before_processing(Duration&& idle_time_before_processing) & noexcept {
    set_fields_[2] = true;
    idle_time_before_processing_ = std::move(idle_time_before_processing);
    return *this;
  }
  /// Sets `idle_time_before_processing` (no 4) and returns `*this`.
  ServiceProfiling&& set_idle_time_before_processing(Duration&& idle_time_before_processing) && noexcept {
    return std::move(set_idle_time_before_processing(std::move(idle_time_before_processing)));
  }

  // Field `intra_component_idle_time` (no 5).
  // -----

  /// / The intra idle time of the service (when the data is not being processed
  /// / between two processing times).
  ///
  /// Field no: 5.
  constexpr const Duration& intra_component_idle_time() const& noexcept HORUS_LIFETIME_BOUND {
    return intra_component_idle_time_;
  }

  /// If `intra_component_idle_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 5.
  Duration intra_component_idle_time() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(intra_component_idle_time_);
  }

  /// / The intra idle time of the service (when the data is not being processed
  /// / between two processing times).
  ///
  /// Field no: 5.
  Duration& mutable_intra_component_idle_time() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return intra_component_idle_time_;
  }

  /// Returns whether `intra_component_idle_time` (no 5) is set.
  constexpr bool has_intra_component_idle_time() const noexcept { return set_fields_[3]; }

  /// Clears `intra_component_idle_time` (no 5).
  void clear_intra_component_idle_time() & noexcept {
    set_fields_[3] = false;
    intra_component_idle_time_ = {};
  }

  /// Sets `intra_component_idle_time` (no 5) and returns `*this`.
  ServiceProfiling& set_intra_component_idle_time(Duration&& intra_component_idle_time) & noexcept {
    set_fields_[3] = true;
    intra_component_idle_time_ = std::move(intra_component_idle_time);
    return *this;
  }
  /// Sets `intra_component_idle_time` (no 5) and returns `*this`.
  ServiceProfiling&& set_intra_component_idle_time(Duration&& intra_component_idle_time) && noexcept {
    return std::move(set_intra_component_idle_time(std::move(intra_component_idle_time)));
  }

 private:
  /// @see details_profiling_set()
  ProfilingSet details_profiling_set_{};
  /// @see total_service_latency()
  Duration total_service_latency_{};
  /// @see idle_time_before_processing()
  Duration idle_time_before_processing_{};
  /// @see intra_component_idle_time()
  Duration intra_component_idle_time_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/profiling.proto:73:1
class PreprocessingServicePointCloudProfiling final : public PbMessage {
 public:

  /// Constructs a default-initialized `PreprocessingServicePointCloudProfiling`.
  PreprocessingServicePointCloudProfiling() noexcept = default;

  /// Move constructor.
  PreprocessingServicePointCloudProfiling(PreprocessingServicePointCloudProfiling&&) noexcept = default;
  /// Move assignment operator.
  PreprocessingServicePointCloudProfiling& operator=(PreprocessingServicePointCloudProfiling&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit PreprocessingServicePointCloudProfiling(const PreprocessingServicePointCloudProfiling& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  PreprocessingServicePointCloudProfiling& operator=(const PreprocessingServicePointCloudProfiling&) = delete;

  /// Default destructor.
  ~PreprocessingServicePointCloudProfiling() noexcept final = default;

  /// Creates a `PreprocessingServicePointCloudProfiling` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit PreprocessingServicePointCloudProfiling(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.PreprocessingServicePointCloudProfiling`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.PreprocessingServicePointCloudProfiling"; }

  /// The full name of the message: `horus.pb.PreprocessingServicePointCloudProfiling`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service_profiling` (no 1).
  // -----

  /// / The preprocessing service profiling for a given point cloud.
  ///
  /// Field no: 1.
  constexpr const ServiceProfiling& service_profiling() const& noexcept HORUS_LIFETIME_BOUND {
    return service_profiling_;
  }

  /// If `service_profiling` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  ServiceProfiling service_profiling() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(service_profiling_);
  }

  /// / The preprocessing service profiling for a given point cloud.
  ///
  /// Field no: 1.
  ServiceProfiling& mutable_service_profiling() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_profiling_;
  }

  /// Returns whether `service_profiling` (no 1) is set.
  constexpr bool has_service_profiling() const noexcept { return set_fields_[0]; }

  /// Clears `service_profiling` (no 1).
  void clear_service_profiling() & noexcept {
    set_fields_[0] = false;
    service_profiling_ = {};
  }

  /// Sets `service_profiling` (no 1) and returns `*this`.
  PreprocessingServicePointCloudProfiling& set_service_profiling(ServiceProfiling&& service_profiling) & noexcept {
    set_fields_[0] = true;
    service_profiling_ = std::move(service_profiling);
    return *this;
  }
  /// Sets `service_profiling` (no 1) and returns `*this`.
  PreprocessingServicePointCloudProfiling&& set_service_profiling(ServiceProfiling&& service_profiling) && noexcept {
    return std::move(set_service_profiling(std::move(service_profiling)));
  }

  // Field `point_cloud_sending_latency` (no 2).
  // -----

  /// / The latency to send the given point cloud from the preprocessing
  /// / service to the detection service.
  ///
  /// Field no: 2.
  constexpr const Duration& point_cloud_sending_latency() const& noexcept HORUS_LIFETIME_BOUND {
    return point_cloud_sending_latency_;
  }

  /// If `point_cloud_sending_latency` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  Duration point_cloud_sending_latency() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(point_cloud_sending_latency_);
  }

  /// / The latency to send the given point cloud from the preprocessing
  /// / service to the detection service.
  ///
  /// Field no: 2.
  Duration& mutable_point_cloud_sending_latency() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return point_cloud_sending_latency_;
  }

  /// Returns whether `point_cloud_sending_latency` (no 2) is set.
  constexpr bool has_point_cloud_sending_latency() const noexcept { return set_fields_[1]; }

  /// Clears `point_cloud_sending_latency` (no 2).
  void clear_point_cloud_sending_latency() & noexcept {
    set_fields_[1] = false;
    point_cloud_sending_latency_ = {};
  }

  /// Sets `point_cloud_sending_latency` (no 2) and returns `*this`.
  PreprocessingServicePointCloudProfiling& set_point_cloud_sending_latency(Duration&& point_cloud_sending_latency) & noexcept {
    set_fields_[1] = true;
    point_cloud_sending_latency_ = std::move(point_cloud_sending_latency);
    return *this;
  }
  /// Sets `point_cloud_sending_latency` (no 2) and returns `*this`.
  PreprocessingServicePointCloudProfiling&& set_point_cloud_sending_latency(Duration&& point_cloud_sending_latency) && noexcept {
    return std::move(set_point_cloud_sending_latency(std::move(point_cloud_sending_latency)));
  }

 private:
  /// @see service_profiling()
  ServiceProfiling service_profiling_{};
  /// @see point_cloud_sending_latency()
  Duration point_cloud_sending_latency_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// / The frame profiling. It includes important profiling for a frame such as
/// / the overall latency or its bundling time.
///
/// Source: horus/pb/profiling.proto:84:1
class FrameProfiling final : public PbMessage {
 public:

  /// Constructs a default-initialized `FrameProfiling`.
  FrameProfiling() noexcept = default;

  /// Move constructor.
  FrameProfiling(FrameProfiling&&) noexcept = default;
  /// Move assignment operator.
  FrameProfiling& operator=(FrameProfiling&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FrameProfiling(const FrameProfiling& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FrameProfiling& operator=(const FrameProfiling&) = delete;

  /// Default destructor.
  ~FrameProfiling() noexcept final = default;

  /// Creates a `FrameProfiling` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FrameProfiling(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.FrameProfiling`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.FrameProfiling"; }

  /// The full name of the message: `horus.pb.FrameProfiling`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `overall_frame_latency` (no 1).
  // -----

  /// / The overall latency of the frame (from the earliest point cloud arrival
  /// / inside the frame to the publishing of the frame).
  ///
  /// Field no: 1.
  constexpr const Duration& overall_frame_latency() const& noexcept HORUS_LIFETIME_BOUND {
    return overall_frame_latency_;
  }

  /// If `overall_frame_latency` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  Duration overall_frame_latency() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(overall_frame_latency_);
  }

  /// / The overall latency of the frame (from the earliest point cloud arrival
  /// / inside the frame to the publishing of the frame).
  ///
  /// Field no: 1.
  Duration& mutable_overall_frame_latency() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return overall_frame_latency_;
  }

  /// Returns whether `overall_frame_latency` (no 1) is set.
  constexpr bool has_overall_frame_latency() const noexcept { return set_fields_[0]; }

  /// Clears `overall_frame_latency` (no 1).
  void clear_overall_frame_latency() & noexcept {
    set_fields_[0] = false;
    overall_frame_latency_ = {};
  }

  /// Sets `overall_frame_latency` (no 1) and returns `*this`.
  FrameProfiling& set_overall_frame_latency(Duration&& overall_frame_latency) & noexcept {
    set_fields_[0] = true;
    overall_frame_latency_ = std::move(overall_frame_latency);
    return *this;
  }
  /// Sets `overall_frame_latency` (no 1) and returns `*this`.
  FrameProfiling&& set_overall_frame_latency(Duration&& overall_frame_latency) && noexcept {
    return std::move(set_overall_frame_latency(std::move(overall_frame_latency)));
  }

  // Field `frame_bundling_latency` (no 2).
  // -----

  /// / The time we spent waiting for the frame to be bundled (this is an
  /// / important metric as this time does not depend on us but on the lidars
  /// / publishing time).
  /// / It has to be substracted to the overall frame latency to get the total
  /// / overhead of our pipeline for the frame.
  ///
  /// Field no: 2.
  constexpr const Duration& frame_bundling_latency() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_bundling_latency_;
  }

  /// If `frame_bundling_latency` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  Duration frame_bundling_latency() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(frame_bundling_latency_);
  }

  /// / The time we spent waiting for the frame to be bundled (this is an
  /// / important metric as this time does not depend on us but on the lidars
  /// / publishing time).
  /// / It has to be substracted to the overall frame latency to get the total
  /// / overhead of our pipeline for the frame.
  ///
  /// Field no: 2.
  Duration& mutable_frame_bundling_latency() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return frame_bundling_latency_;
  }

  /// Returns whether `frame_bundling_latency` (no 2) is set.
  constexpr bool has_frame_bundling_latency() const noexcept { return set_fields_[1]; }

  /// Clears `frame_bundling_latency` (no 2).
  void clear_frame_bundling_latency() & noexcept {
    set_fields_[1] = false;
    frame_bundling_latency_ = {};
  }

  /// Sets `frame_bundling_latency` (no 2) and returns `*this`.
  FrameProfiling& set_frame_bundling_latency(Duration&& frame_bundling_latency) & noexcept {
    set_fields_[1] = true;
    frame_bundling_latency_ = std::move(frame_bundling_latency);
    return *this;
  }
  /// Sets `frame_bundling_latency` (no 2) and returns `*this`.
  FrameProfiling&& set_frame_bundling_latency(Duration&& frame_bundling_latency) && noexcept {
    return std::move(set_frame_bundling_latency(std::move(frame_bundling_latency)));
  }

 private:
  /// @see overall_frame_latency()
  Duration overall_frame_latency_{};
  /// @see frame_bundling_latency()
  Duration frame_bundling_latency_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/profiling.proto:113:3
class BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry final : public PbMessage {
 public:

  /// Constructs a default-initialized `BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry`.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry() noexcept = default;

  /// Move constructor.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry(BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry&&) noexcept = default;
  /// Move assignment operator.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry& operator=(BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry(const BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry& operator=(const BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry&) = delete;

  /// Default destructor.
  ~BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry() noexcept final = default;

  /// Creates a `BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.BundledFrameProfilingSet.PreprocessingServicePointCloudProfilingMapEntry`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.BundledFrameProfilingSet.PreprocessingServicePointCloudProfilingMapEntry"; }

  /// The full name of the message: `horus.pb.BundledFrameProfilingSet.PreprocessingServicePointCloudProfilingMapEntry`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `key` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& key() const& noexcept HORUS_LIFETIME_BOUND {
    return key_;
  }

  /// If `key` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes key() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(key_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_key() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return key_;
  }

  /// Returns whether `key` (no 1) is set.
  constexpr bool has_key() const noexcept { return set_fields_[0]; }

  /// Clears `key` (no 1).
  void clear_key() & noexcept {
    set_fields_[0] = false;
    key_ = {};
  }

  /// Sets `key` (no 1) and returns `*this`.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry& set_key(CowBytes&& key) & noexcept {
    set_fields_[0] = true;
    key_ = std::move(key);
    return *this;
  }
  /// Sets `key` (no 1) and returns `*this`.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry&& set_key(CowBytes&& key) && noexcept {
    return std::move(set_key(std::move(key)));
  }

  // Field `value` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const PreprocessingServicePointCloudProfiling& value() const& noexcept HORUS_LIFETIME_BOUND {
    return value_;
  }

  /// If `value` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  PreprocessingServicePointCloudProfiling value() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(value_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  PreprocessingServicePointCloudProfiling& mutable_value() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return value_;
  }

  /// Returns whether `value` (no 2) is set.
  constexpr bool has_value() const noexcept { return set_fields_[1]; }

  /// Clears `value` (no 2).
  void clear_value() & noexcept {
    set_fields_[1] = false;
    value_ = {};
  }

  /// Sets `value` (no 2) and returns `*this`.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry& set_value(PreprocessingServicePointCloudProfiling&& value) & noexcept {
    set_fields_[1] = true;
    value_ = std::move(value);
    return *this;
  }
  /// Sets `value` (no 2) and returns `*this`.
  BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry&& set_value(PreprocessingServicePointCloudProfiling&& value) && noexcept {
    return std::move(set_value(std::move(value)));
  }

 private:
  /// @see key()
  CowBytes key_{};
  /// @see value()
  PreprocessingServicePointCloudProfiling value_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// / A bundled profiling set bundling bundled frame profiling set of the
/// / detection service with the profiling sets of each points in the frame
/// / (generated by the preprocessing service).
///
/// Source: horus/pb/profiling.proto:100:1
class BundledFrameProfilingSet final : public PbMessage {
 public:
  /// @see BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry
  using PreprocessingServicePointCloudProfilingMapEntry = BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry;

  /// Constructs a default-initialized `BundledFrameProfilingSet`.
  BundledFrameProfilingSet() noexcept = default;

  /// Move constructor.
  BundledFrameProfilingSet(BundledFrameProfilingSet&&) noexcept = default;
  /// Move assignment operator.
  BundledFrameProfilingSet& operator=(BundledFrameProfilingSet&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BundledFrameProfilingSet(const BundledFrameProfilingSet& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BundledFrameProfilingSet& operator=(const BundledFrameProfilingSet&) = delete;

  /// Default destructor.
  ~BundledFrameProfilingSet() noexcept final = default;

  /// Creates a `BundledFrameProfilingSet` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BundledFrameProfilingSet(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.BundledFrameProfilingSet`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.BundledFrameProfilingSet"; }

  /// The full name of the message: `horus.pb.BundledFrameProfilingSet`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `frame_timestamp` (no 3).
  // -----

  /// / The associated frame timestamp (the point cloud arrival average timestamp
  /// / that the frame contains).
  ///
  /// Field no: 3.
  constexpr const Timestamp& frame_timestamp() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_timestamp_;
  }

  /// If `frame_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  Timestamp frame_timestamp() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(frame_timestamp_);
  }

  /// / The associated frame timestamp (the point cloud arrival average timestamp
  /// / that the frame contains).
  ///
  /// Field no: 3.
  Timestamp& mutable_frame_timestamp() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return frame_timestamp_;
  }

  /// Returns whether `frame_timestamp` (no 3) is set.
  constexpr bool has_frame_timestamp() const noexcept { return set_fields_[0]; }

  /// Clears `frame_timestamp` (no 3).
  void clear_frame_timestamp() & noexcept {
    set_fields_[0] = false;
    frame_timestamp_ = {};
  }

  /// Sets `frame_timestamp` (no 3) and returns `*this`.
  BundledFrameProfilingSet& set_frame_timestamp(Timestamp&& frame_timestamp) & noexcept {
    set_fields_[0] = true;
    frame_timestamp_ = std::move(frame_timestamp);
    return *this;
  }
  /// Sets `frame_timestamp` (no 3) and returns `*this`.
  BundledFrameProfilingSet&& set_frame_timestamp(Timestamp&& frame_timestamp) && noexcept {
    return std::move(set_frame_timestamp(std::move(frame_timestamp)));
  }

  // Field `frame_profiling` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const FrameProfiling& frame_profiling() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_profiling_;
  }

  /// If `frame_profiling` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  FrameProfiling frame_profiling() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(frame_profiling_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  FrameProfiling& mutable_frame_profiling() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return frame_profiling_;
  }

  /// Returns whether `frame_profiling` (no 4) is set.
  constexpr bool has_frame_profiling() const noexcept { return set_fields_[1]; }

  /// Clears `frame_profiling` (no 4).
  void clear_frame_profiling() & noexcept {
    set_fields_[1] = false;
    frame_profiling_ = {};
  }

  /// Sets `frame_profiling` (no 4) and returns `*this`.
  BundledFrameProfilingSet& set_frame_profiling(FrameProfiling&& frame_profiling) & noexcept {
    set_fields_[1] = true;
    frame_profiling_ = std::move(frame_profiling);
    return *this;
  }
  /// Sets `frame_profiling` (no 4) and returns `*this`.
  BundledFrameProfilingSet&& set_frame_profiling(FrameProfiling&& frame_profiling) && noexcept {
    return std::move(set_frame_profiling(std::move(frame_profiling)));
  }

  // Field `detection_service_profiling` (no 5).
  // -----

  /// No documentation.
  ///
  /// Field no: 5.
  constexpr const ServiceProfiling& detection_service_profiling() const& noexcept HORUS_LIFETIME_BOUND {
    return detection_service_profiling_;
  }

  /// If `detection_service_profiling` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 5.
  ServiceProfiling detection_service_profiling() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(detection_service_profiling_);
  }

  /// No documentation.
  ///
  /// Field no: 5.
  ServiceProfiling& mutable_detection_service_profiling() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return detection_service_profiling_;
  }

  /// Returns whether `detection_service_profiling` (no 5) is set.
  constexpr bool has_detection_service_profiling() const noexcept { return set_fields_[2]; }

  /// Clears `detection_service_profiling` (no 5).
  void clear_detection_service_profiling() & noexcept {
    set_fields_[2] = false;
    detection_service_profiling_ = {};
  }

  /// Sets `detection_service_profiling` (no 5) and returns `*this`.
  BundledFrameProfilingSet& set_detection_service_profiling(ServiceProfiling&& detection_service_profiling) & noexcept {
    set_fields_[2] = true;
    detection_service_profiling_ = std::move(detection_service_profiling);
    return *this;
  }
  /// Sets `detection_service_profiling` (no 5) and returns `*this`.
  BundledFrameProfilingSet&& set_detection_service_profiling(ServiceProfiling&& detection_service_profiling) && noexcept {
    return std::move(set_detection_service_profiling(std::move(detection_service_profiling)));
  }

  // Field `preprocessing_service_point_cloud_profiling` (no 7).
  // -----

  /// No documentation.
  ///
  /// Field no: 7.
  constexpr const CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry>& preprocessing_service_point_cloud_profiling() const& noexcept HORUS_LIFETIME_BOUND {
    return preprocessing_service_point_cloud_profiling_;
  }

  /// If `preprocessing_service_point_cloud_profiling` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 7.
  CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry> preprocessing_service_point_cloud_profiling() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(preprocessing_service_point_cloud_profiling_);
  }

  /// No documentation.
  ///
  /// Field no: 7.
  CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry>& mutable_preprocessing_service_point_cloud_profiling() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return preprocessing_service_point_cloud_profiling_;
  }

  /// Returns whether `preprocessing_service_point_cloud_profiling` (no 7) is set.
  constexpr bool has_preprocessing_service_point_cloud_profiling() const noexcept { return set_fields_[3]; }

  /// Clears `preprocessing_service_point_cloud_profiling` (no 7).
  void clear_preprocessing_service_point_cloud_profiling() & noexcept {
    set_fields_[3] = false;
    preprocessing_service_point_cloud_profiling_ = {};
  }

  /// Sets `preprocessing_service_point_cloud_profiling` (no 7) and returns `*this`.
  BundledFrameProfilingSet& set_preprocessing_service_point_cloud_profiling(CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry>&& preprocessing_service_point_cloud_profiling) & noexcept {
    set_fields_[3] = true;
    preprocessing_service_point_cloud_profiling_ = std::move(preprocessing_service_point_cloud_profiling);
    return *this;
  }
  /// Sets `preprocessing_service_point_cloud_profiling` (no 7) and returns `*this`.
  BundledFrameProfilingSet&& set_preprocessing_service_point_cloud_profiling(CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry>&& preprocessing_service_point_cloud_profiling) && noexcept {
    return std::move(set_preprocessing_service_point_cloud_profiling(std::move(preprocessing_service_point_cloud_profiling)));
  }

 private:
  /// @see frame_timestamp()
  Timestamp frame_timestamp_{};
  /// @see frame_profiling()
  FrameProfiling frame_profiling_{};
  /// @see detection_service_profiling()
  ServiceProfiling detection_service_profiling_{};
  /// @see preprocessing_service_point_cloud_profiling()
  CowRepeated<BundledFrameProfilingSet_PreprocessingServicePointCloudProfilingMapEntry> preprocessing_service_point_cloud_profiling_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// / A profiling info sent to the notification service and forward to its
/// / subscribers.
///
/// Source: horus/pb/profiling.proto:120:1
class ProfilingInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProfilingInfo`.
  ProfilingInfo() noexcept = default;

  /// Move constructor.
  ProfilingInfo(ProfilingInfo&&) noexcept = default;
  /// Move assignment operator.
  ProfilingInfo& operator=(ProfilingInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProfilingInfo(const ProfilingInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProfilingInfo& operator=(const ProfilingInfo&) = delete;

  /// Default destructor.
  ~ProfilingInfo() noexcept final = default;

  /// Creates a `ProfilingInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProfilingInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.ProfilingInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.ProfilingInfo"; }

  /// The full name of the message: `horus.pb.ProfilingInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `general_profiling_set` (no 1).
  // -----

  /// / General profiling set of a service.
  ///
  /// Field no: 1.
  constexpr const ProfilingSet& general_profiling_set() const& noexcept HORUS_LIFETIME_BOUND {
    return general_profiling_set_;
  }

  /// If `general_profiling_set` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  ProfilingSet general_profiling_set() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(general_profiling_set_);
  }

  /// / General profiling set of a service.
  ///
  /// Field no: 1.
  ProfilingSet& mutable_general_profiling_set() & noexcept HORUS_LIFETIME_BOUND {
    clear_profiling_set();
    profiling_set_ = ProfilingSetOneof::kGeneralProfilingSet;
    set_fields_[0] = true;
    return general_profiling_set_;
  }

  /// Returns whether `general_profiling_set` (no 1) is set.
  constexpr bool has_general_profiling_set() const noexcept { return set_fields_[0]; }

  /// Clears `general_profiling_set` (no 1).
  void clear_general_profiling_set() & noexcept {
    profiling_set_ = {};
    set_fields_[0] = false;
    general_profiling_set_ = {};
  }

  /// Sets `general_profiling_set` (no 1) and returns `*this`.
  ProfilingInfo& set_general_profiling_set(ProfilingSet&& general_profiling_set) & noexcept {
    clear_profiling_set();
    profiling_set_ = ProfilingSetOneof::kGeneralProfilingSet;
    set_fields_[0] = true;
    general_profiling_set_ = std::move(general_profiling_set);
    return *this;
  }
  /// Sets `general_profiling_set` (no 1) and returns `*this`.
  ProfilingInfo&& set_general_profiling_set(ProfilingSet&& general_profiling_set) && noexcept {
    return std::move(set_general_profiling_set(std::move(general_profiling_set)));
  }

  // Field `bundled_frame_profiling_set` (no 2).
  // -----

  /// / Bundled frame profiling set (pipeline profiling sets of the detection
  /// / and preprocessing services).
  ///
  /// Field no: 2.
  constexpr const BundledFrameProfilingSet& bundled_frame_profiling_set() const& noexcept HORUS_LIFETIME_BOUND {
    return bundled_frame_profiling_set_;
  }

  /// If `bundled_frame_profiling_set` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  BundledFrameProfilingSet bundled_frame_profiling_set() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(bundled_frame_profiling_set_);
  }

  /// / Bundled frame profiling set (pipeline profiling sets of the detection
  /// / and preprocessing services).
  ///
  /// Field no: 2.
  BundledFrameProfilingSet& mutable_bundled_frame_profiling_set() & noexcept HORUS_LIFETIME_BOUND {
    clear_profiling_set();
    profiling_set_ = ProfilingSetOneof::kBundledFrameProfilingSet;
    set_fields_[1] = true;
    return bundled_frame_profiling_set_;
  }

  /// Returns whether `bundled_frame_profiling_set` (no 2) is set.
  constexpr bool has_bundled_frame_profiling_set() const noexcept { return set_fields_[1]; }

  /// Clears `bundled_frame_profiling_set` (no 2).
  void clear_bundled_frame_profiling_set() & noexcept {
    profiling_set_ = {};
    set_fields_[1] = false;
    bundled_frame_profiling_set_ = {};
  }

  /// Sets `bundled_frame_profiling_set` (no 2) and returns `*this`.
  ProfilingInfo& set_bundled_frame_profiling_set(BundledFrameProfilingSet&& bundled_frame_profiling_set) & noexcept {
    clear_profiling_set();
    profiling_set_ = ProfilingSetOneof::kBundledFrameProfilingSet;
    set_fields_[1] = true;
    bundled_frame_profiling_set_ = std::move(bundled_frame_profiling_set);
    return *this;
  }
  /// Sets `bundled_frame_profiling_set` (no 2) and returns `*this`.
  ProfilingInfo&& set_bundled_frame_profiling_set(BundledFrameProfilingSet&& bundled_frame_profiling_set) && noexcept {
    return std::move(set_bundled_frame_profiling_set(std::move(bundled_frame_profiling_set)));
  }

  // Oneof `profiling_set`.
  // -----

  /// Return value of `profiling_set_case()`.
  enum class ProfilingSetOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see general_profiling_set()
    kGeneralProfilingSet = 1,
    /// @see bundled_frame_profiling_set()
    kBundledFrameProfilingSet = 2,
  };

  /// Returns the current case set in `profiling_set`.
  constexpr ProfilingSetOneof profiling_set_case() const noexcept {
    return profiling_set_;
  }

  /// Clears the oneof value in `profiling_set`.
  void clear_profiling_set() noexcept {
    switch (profiling_set_) {
      case ProfilingSetOneof::kGeneralProfilingSet: {
        clear_general_profiling_set();
        break;
      }
      case ProfilingSetOneof::kBundledFrameProfilingSet: {
        clear_bundled_frame_profiling_set();
        break;
      }
      case ProfilingSetOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see general_profiling_set()
  ProfilingSet general_profiling_set_{};
  /// @see bundled_frame_profiling_set()
  BundledFrameProfilingSet bundled_frame_profiling_set_{};

  /// @see profiling_set_case()
  ProfilingSetOneof profiling_set_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// MARK: Enum traits

namespace horus {

template <>
class PbEnumTraits<horus::sdk::pb::ProfilingSet_ProfiledService> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.ProfilingSet.ProfiledService`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.ProfilingSet.ProfiledService"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::ProfilingSet_ProfiledService value) noexcept {
    switch (value) {
      case horus::sdk::pb::ProfilingSet_ProfiledService::kServiceUnspecified: {
        return "SERVICE_UNSPECIFIED";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledService::kPreprocessingService: {
        return "PREPROCESSING_SERVICE";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledService::kDetectionService: {
        return "DETECTION_SERVICE";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledService::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ProfilingSet_ProfiledService ValueOf(PbEnum value, horus::sdk::pb::ProfilingSet_ProfiledService default_value = horus::sdk::pb::ProfilingSet_ProfiledService::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::ProfilingSet_ProfiledService::kServiceUnspecified;
      }
      case 1: {
        return horus::sdk::pb::ProfilingSet_ProfiledService::kPreprocessingService;
      }
      case 2: {
        return horus::sdk::pb::ProfilingSet_ProfiledService::kDetectionService;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ProfilingSet_ProfiledService ValueOf(StringView name, horus::sdk::pb::ProfilingSet_ProfiledService default_value = horus::sdk::pb::ProfilingSet_ProfiledService::kUnknownWireValue) noexcept {
    if (name == "SERVICE_UNSPECIFIED") {
      return horus::sdk::pb::ProfilingSet_ProfiledService::kServiceUnspecified;
    }
    if (name == "PREPROCESSING_SERVICE") {
      return horus::sdk::pb::ProfilingSet_ProfiledService::kPreprocessingService;
    }
    if (name == "DETECTION_SERVICE") {
      return horus::sdk::pb::ProfilingSet_ProfiledService::kDetectionService;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::ProfilingSet_ProfiledService> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::ProfilingSet_ProfiledService value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::ProfilingSet_ProfiledService` from `reader`.
  static horus::sdk::pb::ProfilingSet_ProfiledService Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::ProfilingSet_ProfiledService>::ValueOf(reader.Reader().get_enum());
  }
};

template <>
class PbEnumTraits<horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.ProfilingSet.ProfiledDuration.PerformanceHint.ConfigParameterAction`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.ProfilingSet.ProfiledDuration.PerformanceHint.ConfigParameterAction"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction value) noexcept {
    switch (value) {
      case horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnspecified: {
        return "CONFIG_PARAMETER_ACTION_UNSPECIFIED";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kIncrease: {
        return "INCREASE";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kDecrease: {
        return "DECREASE";
      }
      case horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction ValueOf(PbEnum value, horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction default_value = horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kIncrease;
      }
      case 2: {
        return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kDecrease;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction ValueOf(StringView name, horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction default_value = horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnknownWireValue) noexcept {
    if (name == "CONFIG_PARAMETER_ACTION_UNSPECIFIED") {
      return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kUnspecified;
    }
    if (name == "INCREASE") {
      return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kIncrease;
    }
    if (name == "DECREASE") {
      return horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction::kDecrease;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction` from `reader`.
  static horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction>::ValueOf(reader.Reader().get_enum());
  }
};

}  // namespace horus

namespace horus {
namespace sdk {
namespace pb {

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, ProfilingSet_ProfiledService value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<ProfilingSet_ProfiledService>::NameOf(value));
}

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<ProfilingSet_ProfiledDuration_PerformanceHint_ConfigParameterAction>::NameOf(value));
}

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_PROFILING_PB_H_
