#ifndef HORUS_PB_TESTING_MESSAGES_PB_H_
#define HORUS_PB_TESTING_MESSAGES_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/testing/messages.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/cow_bytes.h"
#include "horus/pb/cow_repeated.h"
#include "horus/pb/cow_span.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/pb/types.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Enum declarations

/// Test enum.
///
/// Source: horus/pb/testing/messages.proto:6:1
enum class TestEnum : PbEnum {  // NOLINT(*-enum-size)
  /// Unspecified.
  kUnspecified = 0,
  /// Value `1`.
  kOne = 1,
  /// Value `2`.
  kTwo = 2,

  /// Unknown value read from the wire.
  kUnknownWireValue = 3,
};

// MARK: Message forward declarations

class TestMessage_SubMessage;
class TestMessage;

// MARK: Message declarations

/// No documentation.
///
/// Source: horus/pb/testing/messages.proto:17:3
class TestMessage_SubMessage final : public PbMessage {
 public:

  /// Constructs a default-initialized `TestMessage_SubMessage`.
  TestMessage_SubMessage() noexcept = default;

  /// Move constructor.
  TestMessage_SubMessage(TestMessage_SubMessage&&) noexcept = default;
  /// Move assignment operator.
  TestMessage_SubMessage& operator=(TestMessage_SubMessage&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit TestMessage_SubMessage(const TestMessage_SubMessage& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  TestMessage_SubMessage& operator=(const TestMessage_SubMessage&) = delete;

  /// Default destructor.
  ~TestMessage_SubMessage() noexcept final = default;

  /// Creates a `TestMessage_SubMessage` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit TestMessage_SubMessage(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.TestMessage.SubMessage`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.TestMessage.SubMessage"; }

  /// The full name of the message: `horus.pb.TestMessage.SubMessage`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `u32` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint32_t u32() const& noexcept HORUS_LIFETIME_BOUND {
    return u32_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_u32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return u32_;
  }

  /// Returns whether `u32` (no 1) is set.
  constexpr bool has_u32() const noexcept { return set_fields_[0]; }

  /// Clears `u32` (no 1).
  void clear_u32() & noexcept {
    set_fields_[0] = false;
    u32_ = {};
  }

  /// Sets `u32` (no 1) and returns `*this`.
  TestMessage_SubMessage& set_u32(std::uint32_t u32) & noexcept {
    set_fields_[0] = true;
    u32_ = u32;
    return *this;
  }
  /// Sets `u32` (no 1) and returns `*this`.
  TestMessage_SubMessage&& set_u32(std::uint32_t u32) && noexcept {
    return std::move(set_u32(u32));
  }

  // Field `i32` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::int32_t i32() const& noexcept HORUS_LIFETIME_BOUND {
    return i32_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::int32_t& mutable_i32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return i32_;
  }

  /// Returns whether `i32` (no 2) is set.
  constexpr bool has_i32() const noexcept { return set_fields_[1]; }

  /// Clears `i32` (no 2).
  void clear_i32() & noexcept {
    set_fields_[1] = false;
    i32_ = {};
  }

  /// Sets `i32` (no 2) and returns `*this`.
  TestMessage_SubMessage& set_i32(std::int32_t i32) & noexcept {
    set_fields_[1] = true;
    i32_ = i32;
    return *this;
  }
  /// Sets `i32` (no 2) and returns `*this`.
  TestMessage_SubMessage&& set_i32(std::int32_t i32) && noexcept {
    return std::move(set_i32(i32));
  }

  // Field `string` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& string() const& noexcept HORUS_LIFETIME_BOUND {
    return string_;
  }

  /// If `string` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes string() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(string_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_string() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return string_;
  }

  /// Returns whether `string` (no 3) is set.
  constexpr bool has_string() const noexcept { return set_fields_[2]; }

  /// Clears `string` (no 3).
  void clear_string() & noexcept {
    set_fields_[2] = false;
    string_ = {};
  }

  /// Sets `string` (no 3) and returns `*this`.
  TestMessage_SubMessage& set_string(CowBytes&& string) & noexcept {
    set_fields_[2] = true;
    string_ = std::move(string);
    return *this;
  }
  /// Sets `string` (no 3) and returns `*this`.
  TestMessage_SubMessage&& set_string(CowBytes&& string) && noexcept {
    return std::move(set_string(std::move(string)));
  }

 private:
  /// @see u32()
  std::uint32_t u32_{};
  /// @see i32()
  std::int32_t i32_{};
  /// @see string()
  CowBytes string_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Test message.
///
/// Source: horus/pb/testing/messages.proto:16:1
class TestMessage final : public PbMessage {
 public:
  /// @see TestMessage_SubMessage
  using SubMessage = TestMessage_SubMessage;

  /// Constructs a default-initialized `TestMessage`.
  TestMessage() noexcept = default;

  /// Move constructor.
  TestMessage(TestMessage&&) noexcept = default;
  /// Move assignment operator.
  TestMessage& operator=(TestMessage&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit TestMessage(const TestMessage& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  TestMessage& operator=(const TestMessage&) = delete;

  /// Default destructor.
  ~TestMessage() noexcept final = default;

  /// Creates a `TestMessage` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit TestMessage(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.TestMessage`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.TestMessage"; }

  /// The full name of the message: `horus.pb.TestMessage`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `float` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr float float_() const& noexcept HORUS_LIFETIME_BOUND {
    return floatf_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  float& mutable_float() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return floatf_;
  }

  /// Returns whether `float` (no 1) is set.
  constexpr bool has_float() const noexcept { return set_fields_[0]; }

  /// Clears `float` (no 1).
  void clear_float() & noexcept {
    set_fields_[0] = false;
    floatf_ = {};
  }

  /// Sets `float` (no 1) and returns `*this`.
  TestMessage& set_float(float float_) & noexcept {
    set_fields_[0] = true;
    floatf_ = float_;
    return *this;
  }
  /// Sets `float` (no 1) and returns `*this`.
  TestMessage&& set_float(float float_) && noexcept {
    return std::move(set_float(float_));
  }

  // Field `double` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr double double_() const& noexcept HORUS_LIFETIME_BOUND {
    return doublef_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  double& mutable_double() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return doublef_;
  }

  /// Returns whether `double` (no 2) is set.
  constexpr bool has_double() const noexcept { return set_fields_[1]; }

  /// Clears `double` (no 2).
  void clear_double() & noexcept {
    set_fields_[1] = false;
    doublef_ = {};
  }

  /// Sets `double` (no 2) and returns `*this`.
  TestMessage& set_double(double double_) & noexcept {
    set_fields_[1] = true;
    doublef_ = double_;
    return *this;
  }
  /// Sets `double` (no 2) and returns `*this`.
  TestMessage&& set_double(double double_) && noexcept {
    return std::move(set_double(double_));
  }

  // Field `i32` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr std::int32_t i32() const& noexcept HORUS_LIFETIME_BOUND {
    return i32_;
  }

  /// No documentation.
  ///
  /// Field no: 3.
  std::int32_t& mutable_i32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return i32_;
  }

  /// Returns whether `i32` (no 3) is set.
  constexpr bool has_i32() const noexcept { return set_fields_[2]; }

  /// Clears `i32` (no 3).
  void clear_i32() & noexcept {
    set_fields_[2] = false;
    i32_ = {};
  }

  /// Sets `i32` (no 3) and returns `*this`.
  TestMessage& set_i32(std::int32_t i32) & noexcept {
    set_fields_[2] = true;
    i32_ = i32;
    return *this;
  }
  /// Sets `i32` (no 3) and returns `*this`.
  TestMessage&& set_i32(std::int32_t i32) && noexcept {
    return std::move(set_i32(i32));
  }

  // Field `i64` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr std::int64_t i64() const& noexcept HORUS_LIFETIME_BOUND {
    return i64_;
  }

  /// No documentation.
  ///
  /// Field no: 4.
  std::int64_t& mutable_i64() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return i64_;
  }

  /// Returns whether `i64` (no 4) is set.
  constexpr bool has_i64() const noexcept { return set_fields_[3]; }

  /// Clears `i64` (no 4).
  void clear_i64() & noexcept {
    set_fields_[3] = false;
    i64_ = {};
  }

  /// Sets `i64` (no 4) and returns `*this`.
  TestMessage& set_i64(std::int64_t i64) & noexcept {
    set_fields_[3] = true;
    i64_ = i64;
    return *this;
  }
  /// Sets `i64` (no 4) and returns `*this`.
  TestMessage&& set_i64(std::int64_t i64) && noexcept {
    return std::move(set_i64(i64));
  }

  // Field `u32` (no 5).
  // -----

  /// No documentation.
  ///
  /// Field no: 5.
  constexpr std::uint32_t u32() const& noexcept HORUS_LIFETIME_BOUND {
    return u32_;
  }

  /// No documentation.
  ///
  /// Field no: 5.
  std::uint32_t& mutable_u32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[4] = true;
    return u32_;
  }

  /// Returns whether `u32` (no 5) is set.
  constexpr bool has_u32() const noexcept { return set_fields_[4]; }

  /// Clears `u32` (no 5).
  void clear_u32() & noexcept {
    set_fields_[4] = false;
    u32_ = {};
  }

  /// Sets `u32` (no 5) and returns `*this`.
  TestMessage& set_u32(std::uint32_t u32) & noexcept {
    set_fields_[4] = true;
    u32_ = u32;
    return *this;
  }
  /// Sets `u32` (no 5) and returns `*this`.
  TestMessage&& set_u32(std::uint32_t u32) && noexcept {
    return std::move(set_u32(u32));
  }

  // Field `u64` (no 6).
  // -----

  /// No documentation.
  ///
  /// Field no: 6.
  constexpr std::uint64_t u64() const& noexcept HORUS_LIFETIME_BOUND {
    return u64_;
  }

  /// No documentation.
  ///
  /// Field no: 6.
  std::uint64_t& mutable_u64() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[5] = true;
    return u64_;
  }

  /// Returns whether `u64` (no 6) is set.
  constexpr bool has_u64() const noexcept { return set_fields_[5]; }

  /// Clears `u64` (no 6).
  void clear_u64() & noexcept {
    set_fields_[5] = false;
    u64_ = {};
  }

  /// Sets `u64` (no 6) and returns `*this`.
  TestMessage& set_u64(std::uint64_t u64) & noexcept {
    set_fields_[5] = true;
    u64_ = u64;
    return *this;
  }
  /// Sets `u64` (no 6) and returns `*this`.
  TestMessage&& set_u64(std::uint64_t u64) && noexcept {
    return std::move(set_u64(u64));
  }

  // Field `bytes` (no 7).
  // -----

  /// No documentation.
  ///
  /// Field no: 7.
  constexpr const CowBytes& bytes() const& noexcept HORUS_LIFETIME_BOUND {
    return bytes_;
  }

  /// If `bytes` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 7.
  CowBytes bytes() && noexcept {
    if (!set_fields_[6]) {
      return {};
    }
    return std::move(bytes_);
  }

  /// No documentation.
  ///
  /// Field no: 7.
  CowBytes& mutable_bytes() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[6] = true;
    return bytes_;
  }

  /// Returns whether `bytes` (no 7) is set.
  constexpr bool has_bytes() const noexcept { return set_fields_[6]; }

  /// Clears `bytes` (no 7).
  void clear_bytes() & noexcept {
    set_fields_[6] = false;
    bytes_ = {};
  }

  /// Sets `bytes` (no 7) and returns `*this`.
  TestMessage& set_bytes(CowBytes&& bytes) & noexcept {
    set_fields_[6] = true;
    bytes_ = std::move(bytes);
    return *this;
  }
  /// Sets `bytes` (no 7) and returns `*this`.
  TestMessage&& set_bytes(CowBytes&& bytes) && noexcept {
    return std::move(set_bytes(std::move(bytes)));
  }

  // Field `string` (no 8).
  // -----

  /// No documentation.
  ///
  /// Field no: 8.
  constexpr const CowBytes& string() const& noexcept HORUS_LIFETIME_BOUND {
    return string_;
  }

  /// If `string` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 8.
  CowBytes string() && noexcept {
    if (!set_fields_[7]) {
      return {};
    }
    return std::move(string_);
  }

  /// No documentation.
  ///
  /// Field no: 8.
  CowBytes& mutable_string() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[7] = true;
    return string_;
  }

  /// Returns whether `string` (no 8) is set.
  constexpr bool has_string() const noexcept { return set_fields_[7]; }

  /// Clears `string` (no 8).
  void clear_string() & noexcept {
    set_fields_[7] = false;
    string_ = {};
  }

  /// Sets `string` (no 8) and returns `*this`.
  TestMessage& set_string(CowBytes&& string) & noexcept {
    set_fields_[7] = true;
    string_ = std::move(string);
    return *this;
  }
  /// Sets `string` (no 8) and returns `*this`.
  TestMessage&& set_string(CowBytes&& string) && noexcept {
    return std::move(set_string(std::move(string)));
  }

  // Field `submessage` (no 9).
  // -----

  /// No documentation.
  ///
  /// Field no: 9.
  constexpr const TestMessage_SubMessage& submessage() const& noexcept HORUS_LIFETIME_BOUND {
    return submessage_;
  }

  /// If `submessage` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 9.
  TestMessage_SubMessage submessage() && noexcept {
    if (!set_fields_[8]) {
      return {};
    }
    return std::move(submessage_);
  }

  /// No documentation.
  ///
  /// Field no: 9.
  TestMessage_SubMessage& mutable_submessage() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[8] = true;
    return submessage_;
  }

  /// Returns whether `submessage` (no 9) is set.
  constexpr bool has_submessage() const noexcept { return set_fields_[8]; }

  /// Clears `submessage` (no 9).
  void clear_submessage() & noexcept {
    set_fields_[8] = false;
    submessage_ = {};
  }

  /// Sets `submessage` (no 9) and returns `*this`.
  TestMessage& set_submessage(TestMessage_SubMessage&& submessage) & noexcept {
    set_fields_[8] = true;
    submessage_ = std::move(submessage);
    return *this;
  }
  /// Sets `submessage` (no 9) and returns `*this`.
  TestMessage&& set_submessage(TestMessage_SubMessage&& submessage) && noexcept {
    return std::move(set_submessage(std::move(submessage)));
  }

  // Field `bool` (no 10).
  // -----

  /// No documentation.
  ///
  /// Field no: 10.
  constexpr bool bool_() const& noexcept HORUS_LIFETIME_BOUND {
    return boolf_;
  }

  /// No documentation.
  ///
  /// Field no: 10.
  bool& mutable_bool() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[9] = true;
    return boolf_;
  }

  /// Returns whether `bool` (no 10) is set.
  constexpr bool has_bool() const noexcept { return set_fields_[9]; }

  /// Clears `bool` (no 10).
  void clear_bool() & noexcept {
    set_fields_[9] = false;
    boolf_ = {};
  }

  /// Sets `bool` (no 10) and returns `*this`.
  TestMessage& set_bool(bool bool_) & noexcept {
    set_fields_[9] = true;
    boolf_ = bool_;
    return *this;
  }
  /// Sets `bool` (no 10) and returns `*this`.
  TestMessage&& set_bool(bool bool_) && noexcept {
    return std::move(set_bool(bool_));
  }

  // Field `oneof_float` (no 11).
  // -----

  /// No documentation.
  ///
  /// Field no: 11.
  constexpr float oneof_float() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_float_;
  }

  /// No documentation.
  ///
  /// Field no: 11.
  float& mutable_oneof_float() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofFloat;
    set_fields_[10] = true;
    return oneof_float_;
  }

  /// Returns whether `oneof_float` (no 11) is set.
  constexpr bool has_oneof_float() const noexcept { return set_fields_[10]; }

  /// Clears `oneof_float` (no 11).
  void clear_oneof_float() & noexcept {
    test_oneof_ = {};
    set_fields_[10] = false;
    oneof_float_ = {};
  }

  /// Sets `oneof_float` (no 11) and returns `*this`.
  TestMessage& set_oneof_float(float oneof_float) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofFloat;
    set_fields_[10] = true;
    oneof_float_ = oneof_float;
    return *this;
  }
  /// Sets `oneof_float` (no 11) and returns `*this`.
  TestMessage&& set_oneof_float(float oneof_float) && noexcept {
    return std::move(set_oneof_float(oneof_float));
  }

  // Field `oneof_double` (no 12).
  // -----

  /// No documentation.
  ///
  /// Field no: 12.
  constexpr double oneof_double() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_double_;
  }

  /// No documentation.
  ///
  /// Field no: 12.
  double& mutable_oneof_double() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofDouble;
    set_fields_[11] = true;
    return oneof_double_;
  }

  /// Returns whether `oneof_double` (no 12) is set.
  constexpr bool has_oneof_double() const noexcept { return set_fields_[11]; }

  /// Clears `oneof_double` (no 12).
  void clear_oneof_double() & noexcept {
    test_oneof_ = {};
    set_fields_[11] = false;
    oneof_double_ = {};
  }

  /// Sets `oneof_double` (no 12) and returns `*this`.
  TestMessage& set_oneof_double(double oneof_double) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofDouble;
    set_fields_[11] = true;
    oneof_double_ = oneof_double;
    return *this;
  }
  /// Sets `oneof_double` (no 12) and returns `*this`.
  TestMessage&& set_oneof_double(double oneof_double) && noexcept {
    return std::move(set_oneof_double(oneof_double));
  }

  // Field `oneof_i32` (no 13).
  // -----

  /// No documentation.
  ///
  /// Field no: 13.
  constexpr std::int32_t oneof_i32() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_i32_;
  }

  /// No documentation.
  ///
  /// Field no: 13.
  std::int32_t& mutable_oneof_i32() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofI32;
    set_fields_[12] = true;
    return oneof_i32_;
  }

  /// Returns whether `oneof_i32` (no 13) is set.
  constexpr bool has_oneof_i32() const noexcept { return set_fields_[12]; }

  /// Clears `oneof_i32` (no 13).
  void clear_oneof_i32() & noexcept {
    test_oneof_ = {};
    set_fields_[12] = false;
    oneof_i32_ = {};
  }

  /// Sets `oneof_i32` (no 13) and returns `*this`.
  TestMessage& set_oneof_i32(std::int32_t oneof_i32) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofI32;
    set_fields_[12] = true;
    oneof_i32_ = oneof_i32;
    return *this;
  }
  /// Sets `oneof_i32` (no 13) and returns `*this`.
  TestMessage&& set_oneof_i32(std::int32_t oneof_i32) && noexcept {
    return std::move(set_oneof_i32(oneof_i32));
  }

  // Field `oneof_i64` (no 14).
  // -----

  /// No documentation.
  ///
  /// Field no: 14.
  constexpr std::int64_t oneof_i64() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_i64_;
  }

  /// No documentation.
  ///
  /// Field no: 14.
  std::int64_t& mutable_oneof_i64() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofI64;
    set_fields_[13] = true;
    return oneof_i64_;
  }

  /// Returns whether `oneof_i64` (no 14) is set.
  constexpr bool has_oneof_i64() const noexcept { return set_fields_[13]; }

  /// Clears `oneof_i64` (no 14).
  void clear_oneof_i64() & noexcept {
    test_oneof_ = {};
    set_fields_[13] = false;
    oneof_i64_ = {};
  }

  /// Sets `oneof_i64` (no 14) and returns `*this`.
  TestMessage& set_oneof_i64(std::int64_t oneof_i64) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofI64;
    set_fields_[13] = true;
    oneof_i64_ = oneof_i64;
    return *this;
  }
  /// Sets `oneof_i64` (no 14) and returns `*this`.
  TestMessage&& set_oneof_i64(std::int64_t oneof_i64) && noexcept {
    return std::move(set_oneof_i64(oneof_i64));
  }

  // Field `oneof_u32` (no 15).
  // -----

  /// No documentation.
  ///
  /// Field no: 15.
  constexpr std::uint32_t oneof_u32() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_u32_;
  }

  /// No documentation.
  ///
  /// Field no: 15.
  std::uint32_t& mutable_oneof_u32() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofU32;
    set_fields_[14] = true;
    return oneof_u32_;
  }

  /// Returns whether `oneof_u32` (no 15) is set.
  constexpr bool has_oneof_u32() const noexcept { return set_fields_[14]; }

  /// Clears `oneof_u32` (no 15).
  void clear_oneof_u32() & noexcept {
    test_oneof_ = {};
    set_fields_[14] = false;
    oneof_u32_ = {};
  }

  /// Sets `oneof_u32` (no 15) and returns `*this`.
  TestMessage& set_oneof_u32(std::uint32_t oneof_u32) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofU32;
    set_fields_[14] = true;
    oneof_u32_ = oneof_u32;
    return *this;
  }
  /// Sets `oneof_u32` (no 15) and returns `*this`.
  TestMessage&& set_oneof_u32(std::uint32_t oneof_u32) && noexcept {
    return std::move(set_oneof_u32(oneof_u32));
  }

  // Field `oneof_u64` (no 16).
  // -----

  /// No documentation.
  ///
  /// Field no: 16.
  constexpr std::uint64_t oneof_u64() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_u64_;
  }

  /// No documentation.
  ///
  /// Field no: 16.
  std::uint64_t& mutable_oneof_u64() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofU64;
    set_fields_[15] = true;
    return oneof_u64_;
  }

  /// Returns whether `oneof_u64` (no 16) is set.
  constexpr bool has_oneof_u64() const noexcept { return set_fields_[15]; }

  /// Clears `oneof_u64` (no 16).
  void clear_oneof_u64() & noexcept {
    test_oneof_ = {};
    set_fields_[15] = false;
    oneof_u64_ = {};
  }

  /// Sets `oneof_u64` (no 16) and returns `*this`.
  TestMessage& set_oneof_u64(std::uint64_t oneof_u64) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofU64;
    set_fields_[15] = true;
    oneof_u64_ = oneof_u64;
    return *this;
  }
  /// Sets `oneof_u64` (no 16) and returns `*this`.
  TestMessage&& set_oneof_u64(std::uint64_t oneof_u64) && noexcept {
    return std::move(set_oneof_u64(oneof_u64));
  }

  // Field `oneof_bytes` (no 17).
  // -----

  /// No documentation.
  ///
  /// Field no: 17.
  constexpr const CowBytes& oneof_bytes() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_bytes_;
  }

  /// If `oneof_bytes` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 17.
  CowBytes oneof_bytes() && noexcept {
    if (!set_fields_[16]) {
      return {};
    }
    return std::move(oneof_bytes_);
  }

  /// No documentation.
  ///
  /// Field no: 17.
  CowBytes& mutable_oneof_bytes() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofBytes;
    set_fields_[16] = true;
    return oneof_bytes_;
  }

  /// Returns whether `oneof_bytes` (no 17) is set.
  constexpr bool has_oneof_bytes() const noexcept { return set_fields_[16]; }

  /// Clears `oneof_bytes` (no 17).
  void clear_oneof_bytes() & noexcept {
    test_oneof_ = {};
    set_fields_[16] = false;
    oneof_bytes_ = {};
  }

  /// Sets `oneof_bytes` (no 17) and returns `*this`.
  TestMessage& set_oneof_bytes(CowBytes&& oneof_bytes) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofBytes;
    set_fields_[16] = true;
    oneof_bytes_ = std::move(oneof_bytes);
    return *this;
  }
  /// Sets `oneof_bytes` (no 17) and returns `*this`.
  TestMessage&& set_oneof_bytes(CowBytes&& oneof_bytes) && noexcept {
    return std::move(set_oneof_bytes(std::move(oneof_bytes)));
  }

  // Field `oneof_string` (no 18).
  // -----

  /// No documentation.
  ///
  /// Field no: 18.
  constexpr const CowBytes& oneof_string() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_string_;
  }

  /// If `oneof_string` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 18.
  CowBytes oneof_string() && noexcept {
    if (!set_fields_[17]) {
      return {};
    }
    return std::move(oneof_string_);
  }

  /// No documentation.
  ///
  /// Field no: 18.
  CowBytes& mutable_oneof_string() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofString;
    set_fields_[17] = true;
    return oneof_string_;
  }

  /// Returns whether `oneof_string` (no 18) is set.
  constexpr bool has_oneof_string() const noexcept { return set_fields_[17]; }

  /// Clears `oneof_string` (no 18).
  void clear_oneof_string() & noexcept {
    test_oneof_ = {};
    set_fields_[17] = false;
    oneof_string_ = {};
  }

  /// Sets `oneof_string` (no 18) and returns `*this`.
  TestMessage& set_oneof_string(CowBytes&& oneof_string) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofString;
    set_fields_[17] = true;
    oneof_string_ = std::move(oneof_string);
    return *this;
  }
  /// Sets `oneof_string` (no 18) and returns `*this`.
  TestMessage&& set_oneof_string(CowBytes&& oneof_string) && noexcept {
    return std::move(set_oneof_string(std::move(oneof_string)));
  }

  // Field `oneof_submessage` (no 19).
  // -----

  /// No documentation.
  ///
  /// Field no: 19.
  constexpr const TestMessage_SubMessage& oneof_submessage() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_submessage_;
  }

  /// If `oneof_submessage` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 19.
  TestMessage_SubMessage oneof_submessage() && noexcept {
    if (!set_fields_[18]) {
      return {};
    }
    return std::move(oneof_submessage_);
  }

  /// No documentation.
  ///
  /// Field no: 19.
  TestMessage_SubMessage& mutable_oneof_submessage() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofSubmessage;
    set_fields_[18] = true;
    return oneof_submessage_;
  }

  /// Returns whether `oneof_submessage` (no 19) is set.
  constexpr bool has_oneof_submessage() const noexcept { return set_fields_[18]; }

  /// Clears `oneof_submessage` (no 19).
  void clear_oneof_submessage() & noexcept {
    test_oneof_ = {};
    set_fields_[18] = false;
    oneof_submessage_ = {};
  }

  /// Sets `oneof_submessage` (no 19) and returns `*this`.
  TestMessage& set_oneof_submessage(TestMessage_SubMessage&& oneof_submessage) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofSubmessage;
    set_fields_[18] = true;
    oneof_submessage_ = std::move(oneof_submessage);
    return *this;
  }
  /// Sets `oneof_submessage` (no 19) and returns `*this`.
  TestMessage&& set_oneof_submessage(TestMessage_SubMessage&& oneof_submessage) && noexcept {
    return std::move(set_oneof_submessage(std::move(oneof_submessage)));
  }

  // Field `oneof_bool` (no 20).
  // -----

  /// No documentation.
  ///
  /// Field no: 20.
  constexpr bool oneof_bool() const& noexcept HORUS_LIFETIME_BOUND {
    return oneof_bool_;
  }

  /// No documentation.
  ///
  /// Field no: 20.
  bool& mutable_oneof_bool() & noexcept HORUS_LIFETIME_BOUND {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofBool;
    set_fields_[19] = true;
    return oneof_bool_;
  }

  /// Returns whether `oneof_bool` (no 20) is set.
  constexpr bool has_oneof_bool() const noexcept { return set_fields_[19]; }

  /// Clears `oneof_bool` (no 20).
  void clear_oneof_bool() & noexcept {
    test_oneof_ = {};
    set_fields_[19] = false;
    oneof_bool_ = {};
  }

  /// Sets `oneof_bool` (no 20) and returns `*this`.
  TestMessage& set_oneof_bool(bool oneof_bool) & noexcept {
    clear_test_oneof();
    test_oneof_ = TestOneofOneof::kOneofBool;
    set_fields_[19] = true;
    oneof_bool_ = oneof_bool;
    return *this;
  }
  /// Sets `oneof_bool` (no 20) and returns `*this`.
  TestMessage&& set_oneof_bool(bool oneof_bool) && noexcept {
    return std::move(set_oneof_bool(oneof_bool));
  }

  // Field `rep_float` (no 21).
  // -----

  /// No documentation.
  ///
  /// Field no: 21.
  constexpr const CowSpan<float>& rep_float() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_float_;
  }

  /// If `rep_float` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 21.
  CowSpan<float> rep_float() && noexcept {
    if (!set_fields_[20]) {
      return {};
    }
    return std::move(rep_float_);
  }

  /// No documentation.
  ///
  /// Field no: 21.
  CowSpan<float>& mutable_rep_float() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[20] = true;
    return rep_float_;
  }

  /// Returns whether `rep_float` (no 21) is set.
  constexpr bool has_rep_float() const noexcept { return set_fields_[20]; }

  /// Clears `rep_float` (no 21).
  void clear_rep_float() & noexcept {
    set_fields_[20] = false;
    rep_float_ = {};
  }

  /// Sets `rep_float` (no 21) and returns `*this`.
  TestMessage& set_rep_float(CowSpan<float>&& rep_float) & noexcept {
    set_fields_[20] = true;
    rep_float_ = std::move(rep_float);
    return *this;
  }
  /// Sets `rep_float` (no 21) and returns `*this`.
  TestMessage&& set_rep_float(CowSpan<float>&& rep_float) && noexcept {
    return std::move(set_rep_float(std::move(rep_float)));
  }

  // Field `rep_double` (no 22).
  // -----

  /// No documentation.
  ///
  /// Field no: 22.
  constexpr const CowSpan<double>& rep_double() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_double_;
  }

  /// If `rep_double` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 22.
  CowSpan<double> rep_double() && noexcept {
    if (!set_fields_[21]) {
      return {};
    }
    return std::move(rep_double_);
  }

  /// No documentation.
  ///
  /// Field no: 22.
  CowSpan<double>& mutable_rep_double() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[21] = true;
    return rep_double_;
  }

  /// Returns whether `rep_double` (no 22) is set.
  constexpr bool has_rep_double() const noexcept { return set_fields_[21]; }

  /// Clears `rep_double` (no 22).
  void clear_rep_double() & noexcept {
    set_fields_[21] = false;
    rep_double_ = {};
  }

  /// Sets `rep_double` (no 22) and returns `*this`.
  TestMessage& set_rep_double(CowSpan<double>&& rep_double) & noexcept {
    set_fields_[21] = true;
    rep_double_ = std::move(rep_double);
    return *this;
  }
  /// Sets `rep_double` (no 22) and returns `*this`.
  TestMessage&& set_rep_double(CowSpan<double>&& rep_double) && noexcept {
    return std::move(set_rep_double(std::move(rep_double)));
  }

  // Field `rep_i32` (no 23).
  // -----

  /// No documentation.
  ///
  /// Field no: 23.
  constexpr const CowRepeated<std::int32_t>& rep_i32() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_i32_;
  }

  /// If `rep_i32` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 23.
  CowRepeated<std::int32_t> rep_i32() && noexcept {
    if (!set_fields_[22]) {
      return {};
    }
    return std::move(rep_i32_);
  }

  /// No documentation.
  ///
  /// Field no: 23.
  CowRepeated<std::int32_t>& mutable_rep_i32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[22] = true;
    return rep_i32_;
  }

  /// Returns whether `rep_i32` (no 23) is set.
  constexpr bool has_rep_i32() const noexcept { return set_fields_[22]; }

  /// Clears `rep_i32` (no 23).
  void clear_rep_i32() & noexcept {
    set_fields_[22] = false;
    rep_i32_ = {};
  }

  /// Sets `rep_i32` (no 23) and returns `*this`.
  TestMessage& set_rep_i32(CowRepeated<std::int32_t>&& rep_i32) & noexcept {
    set_fields_[22] = true;
    rep_i32_ = std::move(rep_i32);
    return *this;
  }
  /// Sets `rep_i32` (no 23) and returns `*this`.
  TestMessage&& set_rep_i32(CowRepeated<std::int32_t>&& rep_i32) && noexcept {
    return std::move(set_rep_i32(std::move(rep_i32)));
  }

  // Field `rep_i64` (no 24).
  // -----

  /// No documentation.
  ///
  /// Field no: 24.
  constexpr const CowRepeated<std::int64_t>& rep_i64() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_i64_;
  }

  /// If `rep_i64` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 24.
  CowRepeated<std::int64_t> rep_i64() && noexcept {
    if (!set_fields_[23]) {
      return {};
    }
    return std::move(rep_i64_);
  }

  /// No documentation.
  ///
  /// Field no: 24.
  CowRepeated<std::int64_t>& mutable_rep_i64() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[23] = true;
    return rep_i64_;
  }

  /// Returns whether `rep_i64` (no 24) is set.
  constexpr bool has_rep_i64() const noexcept { return set_fields_[23]; }

  /// Clears `rep_i64` (no 24).
  void clear_rep_i64() & noexcept {
    set_fields_[23] = false;
    rep_i64_ = {};
  }

  /// Sets `rep_i64` (no 24) and returns `*this`.
  TestMessage& set_rep_i64(CowRepeated<std::int64_t>&& rep_i64) & noexcept {
    set_fields_[23] = true;
    rep_i64_ = std::move(rep_i64);
    return *this;
  }
  /// Sets `rep_i64` (no 24) and returns `*this`.
  TestMessage&& set_rep_i64(CowRepeated<std::int64_t>&& rep_i64) && noexcept {
    return std::move(set_rep_i64(std::move(rep_i64)));
  }

  // Field `rep_u32` (no 25).
  // -----

  /// No documentation.
  ///
  /// Field no: 25.
  constexpr const CowRepeated<std::uint32_t>& rep_u32() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_u32_;
  }

  /// If `rep_u32` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 25.
  CowRepeated<std::uint32_t> rep_u32() && noexcept {
    if (!set_fields_[24]) {
      return {};
    }
    return std::move(rep_u32_);
  }

  /// No documentation.
  ///
  /// Field no: 25.
  CowRepeated<std::uint32_t>& mutable_rep_u32() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[24] = true;
    return rep_u32_;
  }

  /// Returns whether `rep_u32` (no 25) is set.
  constexpr bool has_rep_u32() const noexcept { return set_fields_[24]; }

  /// Clears `rep_u32` (no 25).
  void clear_rep_u32() & noexcept {
    set_fields_[24] = false;
    rep_u32_ = {};
  }

  /// Sets `rep_u32` (no 25) and returns `*this`.
  TestMessage& set_rep_u32(CowRepeated<std::uint32_t>&& rep_u32) & noexcept {
    set_fields_[24] = true;
    rep_u32_ = std::move(rep_u32);
    return *this;
  }
  /// Sets `rep_u32` (no 25) and returns `*this`.
  TestMessage&& set_rep_u32(CowRepeated<std::uint32_t>&& rep_u32) && noexcept {
    return std::move(set_rep_u32(std::move(rep_u32)));
  }

  // Field `rep_u64` (no 26).
  // -----

  /// No documentation.
  ///
  /// Field no: 26.
  constexpr const CowRepeated<std::uint64_t>& rep_u64() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_u64_;
  }

  /// If `rep_u64` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 26.
  CowRepeated<std::uint64_t> rep_u64() && noexcept {
    if (!set_fields_[25]) {
      return {};
    }
    return std::move(rep_u64_);
  }

  /// No documentation.
  ///
  /// Field no: 26.
  CowRepeated<std::uint64_t>& mutable_rep_u64() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[25] = true;
    return rep_u64_;
  }

  /// Returns whether `rep_u64` (no 26) is set.
  constexpr bool has_rep_u64() const noexcept { return set_fields_[25]; }

  /// Clears `rep_u64` (no 26).
  void clear_rep_u64() & noexcept {
    set_fields_[25] = false;
    rep_u64_ = {};
  }

  /// Sets `rep_u64` (no 26) and returns `*this`.
  TestMessage& set_rep_u64(CowRepeated<std::uint64_t>&& rep_u64) & noexcept {
    set_fields_[25] = true;
    rep_u64_ = std::move(rep_u64);
    return *this;
  }
  /// Sets `rep_u64` (no 26) and returns `*this`.
  TestMessage&& set_rep_u64(CowRepeated<std::uint64_t>&& rep_u64) && noexcept {
    return std::move(set_rep_u64(std::move(rep_u64)));
  }

  // Field `rep_bytes` (no 27).
  // -----

  /// No documentation.
  ///
  /// Field no: 27.
  constexpr const CowRepeated<CowBytes>& rep_bytes() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_bytes_;
  }

  /// If `rep_bytes` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 27.
  CowRepeated<CowBytes> rep_bytes() && noexcept {
    if (!set_fields_[26]) {
      return {};
    }
    return std::move(rep_bytes_);
  }

  /// No documentation.
  ///
  /// Field no: 27.
  CowRepeated<CowBytes>& mutable_rep_bytes() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[26] = true;
    return rep_bytes_;
  }

  /// Returns whether `rep_bytes` (no 27) is set.
  constexpr bool has_rep_bytes() const noexcept { return set_fields_[26]; }

  /// Clears `rep_bytes` (no 27).
  void clear_rep_bytes() & noexcept {
    set_fields_[26] = false;
    rep_bytes_ = {};
  }

  /// Sets `rep_bytes` (no 27) and returns `*this`.
  TestMessage& set_rep_bytes(CowRepeated<CowBytes>&& rep_bytes) & noexcept {
    set_fields_[26] = true;
    rep_bytes_ = std::move(rep_bytes);
    return *this;
  }
  /// Sets `rep_bytes` (no 27) and returns `*this`.
  TestMessage&& set_rep_bytes(CowRepeated<CowBytes>&& rep_bytes) && noexcept {
    return std::move(set_rep_bytes(std::move(rep_bytes)));
  }

  // Field `rep_string` (no 28).
  // -----

  /// No documentation.
  ///
  /// Field no: 28.
  constexpr const CowRepeated<CowBytes>& rep_string() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_string_;
  }

  /// If `rep_string` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 28.
  CowRepeated<CowBytes> rep_string() && noexcept {
    if (!set_fields_[27]) {
      return {};
    }
    return std::move(rep_string_);
  }

  /// No documentation.
  ///
  /// Field no: 28.
  CowRepeated<CowBytes>& mutable_rep_string() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[27] = true;
    return rep_string_;
  }

  /// Returns whether `rep_string` (no 28) is set.
  constexpr bool has_rep_string() const noexcept { return set_fields_[27]; }

  /// Clears `rep_string` (no 28).
  void clear_rep_string() & noexcept {
    set_fields_[27] = false;
    rep_string_ = {};
  }

  /// Sets `rep_string` (no 28) and returns `*this`.
  TestMessage& set_rep_string(CowRepeated<CowBytes>&& rep_string) & noexcept {
    set_fields_[27] = true;
    rep_string_ = std::move(rep_string);
    return *this;
  }
  /// Sets `rep_string` (no 28) and returns `*this`.
  TestMessage&& set_rep_string(CowRepeated<CowBytes>&& rep_string) && noexcept {
    return std::move(set_rep_string(std::move(rep_string)));
  }

  // Field `rep_submessage` (no 29).
  // -----

  /// No documentation.
  ///
  /// Field no: 29.
  constexpr const CowRepeated<TestMessage_SubMessage>& rep_submessage() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_submessage_;
  }

  /// If `rep_submessage` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 29.
  CowRepeated<TestMessage_SubMessage> rep_submessage() && noexcept {
    if (!set_fields_[28]) {
      return {};
    }
    return std::move(rep_submessage_);
  }

  /// No documentation.
  ///
  /// Field no: 29.
  CowRepeated<TestMessage_SubMessage>& mutable_rep_submessage() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[28] = true;
    return rep_submessage_;
  }

  /// Returns whether `rep_submessage` (no 29) is set.
  constexpr bool has_rep_submessage() const noexcept { return set_fields_[28]; }

  /// Clears `rep_submessage` (no 29).
  void clear_rep_submessage() & noexcept {
    set_fields_[28] = false;
    rep_submessage_ = {};
  }

  /// Sets `rep_submessage` (no 29) and returns `*this`.
  TestMessage& set_rep_submessage(CowRepeated<TestMessage_SubMessage>&& rep_submessage) & noexcept {
    set_fields_[28] = true;
    rep_submessage_ = std::move(rep_submessage);
    return *this;
  }
  /// Sets `rep_submessage` (no 29) and returns `*this`.
  TestMessage&& set_rep_submessage(CowRepeated<TestMessage_SubMessage>&& rep_submessage) && noexcept {
    return std::move(set_rep_submessage(std::move(rep_submessage)));
  }

  // Field `rep_bool` (no 30).
  // -----

  /// No documentation.
  ///
  /// Field no: 30.
  constexpr const CowRepeated<bool>& rep_bool() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_bool_;
  }

  /// If `rep_bool` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 30.
  CowRepeated<bool> rep_bool() && noexcept {
    if (!set_fields_[29]) {
      return {};
    }
    return std::move(rep_bool_);
  }

  /// No documentation.
  ///
  /// Field no: 30.
  CowRepeated<bool>& mutable_rep_bool() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[29] = true;
    return rep_bool_;
  }

  /// Returns whether `rep_bool` (no 30) is set.
  constexpr bool has_rep_bool() const noexcept { return set_fields_[29]; }

  /// Clears `rep_bool` (no 30).
  void clear_rep_bool() & noexcept {
    set_fields_[29] = false;
    rep_bool_ = {};
  }

  /// Sets `rep_bool` (no 30) and returns `*this`.
  TestMessage& set_rep_bool(CowRepeated<bool>&& rep_bool) & noexcept {
    set_fields_[29] = true;
    rep_bool_ = std::move(rep_bool);
    return *this;
  }
  /// Sets `rep_bool` (no 30) and returns `*this`.
  TestMessage&& set_rep_bool(CowRepeated<bool>&& rep_bool) && noexcept {
    return std::move(set_rep_bool(std::move(rep_bool)));
  }

  // Field `rep_enum` (no 31).
  // -----

  /// No documentation.
  ///
  /// Field no: 31.
  constexpr const CowRepeated<TestEnum>& rep_enum() const& noexcept HORUS_LIFETIME_BOUND {
    return rep_enum_;
  }

  /// If `rep_enum` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 31.
  CowRepeated<TestEnum> rep_enum() && noexcept {
    if (!set_fields_[30]) {
      return {};
    }
    return std::move(rep_enum_);
  }

  /// No documentation.
  ///
  /// Field no: 31.
  CowRepeated<TestEnum>& mutable_rep_enum() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[30] = true;
    return rep_enum_;
  }

  /// Returns whether `rep_enum` (no 31) is set.
  constexpr bool has_rep_enum() const noexcept { return set_fields_[30]; }

  /// Clears `rep_enum` (no 31).
  void clear_rep_enum() & noexcept {
    set_fields_[30] = false;
    rep_enum_ = {};
  }

  /// Sets `rep_enum` (no 31) and returns `*this`.
  TestMessage& set_rep_enum(CowRepeated<TestEnum>&& rep_enum) & noexcept {
    set_fields_[30] = true;
    rep_enum_ = std::move(rep_enum);
    return *this;
  }
  /// Sets `rep_enum` (no 31) and returns `*this`.
  TestMessage&& set_rep_enum(CowRepeated<TestEnum>&& rep_enum) && noexcept {
    return std::move(set_rep_enum(std::move(rep_enum)));
  }

  // Oneof `test_oneof`.
  // -----

  /// Return value of `test_oneof_case()`.
  enum class TestOneofOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see oneof_float()
    kOneofFloat = 11,
    /// @see oneof_double()
    kOneofDouble = 12,
    /// @see oneof_i32()
    kOneofI32 = 13,
    /// @see oneof_i64()
    kOneofI64 = 14,
    /// @see oneof_u32()
    kOneofU32 = 15,
    /// @see oneof_u64()
    kOneofU64 = 16,
    /// @see oneof_bytes()
    kOneofBytes = 17,
    /// @see oneof_string()
    kOneofString = 18,
    /// @see oneof_submessage()
    kOneofSubmessage = 19,
    /// @see oneof_bool()
    kOneofBool = 20,
  };

  /// Returns the current case set in `test_oneof`.
  constexpr TestOneofOneof test_oneof_case() const noexcept {
    return test_oneof_;
  }

  /// Clears the oneof value in `test_oneof`.
  void clear_test_oneof() noexcept {
    switch (test_oneof_) {
      case TestOneofOneof::kOneofFloat: {
        clear_oneof_float();
        break;
      }
      case TestOneofOneof::kOneofDouble: {
        clear_oneof_double();
        break;
      }
      case TestOneofOneof::kOneofI32: {
        clear_oneof_i32();
        break;
      }
      case TestOneofOneof::kOneofI64: {
        clear_oneof_i64();
        break;
      }
      case TestOneofOneof::kOneofU32: {
        clear_oneof_u32();
        break;
      }
      case TestOneofOneof::kOneofU64: {
        clear_oneof_u64();
        break;
      }
      case TestOneofOneof::kOneofBytes: {
        clear_oneof_bytes();
        break;
      }
      case TestOneofOneof::kOneofString: {
        clear_oneof_string();
        break;
      }
      case TestOneofOneof::kOneofSubmessage: {
        clear_oneof_submessage();
        break;
      }
      case TestOneofOneof::kOneofBool: {
        clear_oneof_bool();
        break;
      }
      case TestOneofOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see float()
  float floatf_{};
  /// @see double()
  double doublef_{};
  /// @see i32()
  std::int32_t i32_{};
  /// @see i64()
  std::int64_t i64_{};
  /// @see u32()
  std::uint32_t u32_{};
  /// @see u64()
  std::uint64_t u64_{};
  /// @see bytes()
  CowBytes bytes_{};
  /// @see string()
  CowBytes string_{};
  /// @see submessage()
  TestMessage_SubMessage submessage_{};
  /// @see bool()
  bool boolf_{};
  /// @see oneof_float()
  float oneof_float_{};
  /// @see oneof_double()
  double oneof_double_{};
  /// @see oneof_i32()
  std::int32_t oneof_i32_{};
  /// @see oneof_i64()
  std::int64_t oneof_i64_{};
  /// @see oneof_u32()
  std::uint32_t oneof_u32_{};
  /// @see oneof_u64()
  std::uint64_t oneof_u64_{};
  /// @see oneof_bytes()
  CowBytes oneof_bytes_{};
  /// @see oneof_string()
  CowBytes oneof_string_{};
  /// @see oneof_submessage()
  TestMessage_SubMessage oneof_submessage_{};
  /// @see oneof_bool()
  bool oneof_bool_{};
  /// @see rep_float()
  CowSpan<float> rep_float_{};
  /// @see rep_double()
  CowSpan<double> rep_double_{};
  /// @see rep_i32()
  CowRepeated<std::int32_t> rep_i32_{};
  /// @see rep_i64()
  CowRepeated<std::int64_t> rep_i64_{};
  /// @see rep_u32()
  CowRepeated<std::uint32_t> rep_u32_{};
  /// @see rep_u64()
  CowRepeated<std::uint64_t> rep_u64_{};
  /// @see rep_bytes()
  CowRepeated<CowBytes> rep_bytes_{};
  /// @see rep_string()
  CowRepeated<CowBytes> rep_string_{};
  /// @see rep_submessage()
  CowRepeated<TestMessage_SubMessage> rep_submessage_{};
  /// @see rep_bool()
  CowRepeated<bool> rep_bool_{};
  /// @see rep_enum()
  CowRepeated<TestEnum> rep_enum_{};

  /// @see test_oneof_case()
  TestOneofOneof test_oneof_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<31> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// MARK: Enum traits

namespace horus {

template <>
class PbEnumTraits<horus::sdk::pb::TestEnum> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.TestEnum`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.TestEnum"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::TestEnum value) noexcept {
    switch (value) {
      case horus::sdk::pb::TestEnum::kUnspecified: {
        return "TEST_ENUM_UNSPECIFIED";
      }
      case horus::sdk::pb::TestEnum::kOne: {
        return "TEST_ENUM_ONE";
      }
      case horus::sdk::pb::TestEnum::kTwo: {
        return "TEST_ENUM_TWO";
      }
      case horus::sdk::pb::TestEnum::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::TestEnum ValueOf(PbEnum value, horus::sdk::pb::TestEnum default_value = horus::sdk::pb::TestEnum::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::TestEnum::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::TestEnum::kOne;
      }
      case 2: {
        return horus::sdk::pb::TestEnum::kTwo;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::TestEnum ValueOf(StringView name, horus::sdk::pb::TestEnum default_value = horus::sdk::pb::TestEnum::kUnknownWireValue) noexcept {
    if (name == "TEST_ENUM_UNSPECIFIED") {
      return horus::sdk::pb::TestEnum::kUnspecified;
    }
    if (name == "TEST_ENUM_ONE") {
      return horus::sdk::pb::TestEnum::kOne;
    }
    if (name == "TEST_ENUM_TWO") {
      return horus::sdk::pb::TestEnum::kTwo;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::TestEnum> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::TestEnum value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::TestEnum` from `reader`.
  static horus::sdk::pb::TestEnum Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::TestEnum>::ValueOf(reader.Reader().get_enum());
  }
};

}  // namespace horus

namespace horus {
namespace sdk {
namespace pb {

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, TestEnum value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<TestEnum>::NameOf(value));
}

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_TESTING_MESSAGES_PB_H_
