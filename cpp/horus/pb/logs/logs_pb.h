#ifndef HORUS_PB_LOGS_LOGS_PB_H_
#define HORUS_PB_LOGS_LOGS_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/logs/logs.proto`.
///
/// Generated by `/opt/actions-runner/_work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/pb/cow_bytes.h"
#include "horus/pb/cow_repeated.h"
#include "horus/pb/logs/common_pb.h"
#include "horus/pb/logs/metadata_pb.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/types/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {
namespace logs {

// MARK: Message forward declarations

class Generic;
class Oom;
class RpcConnectionError;
class InvalidProjectName;
class ProjectNotFound;
class ProjectAlreadyExists;
class InvalidConfiguration;
class EntityNotFound;
class ActiveProjectCannotBeDeleted;
class RpcDisconnectionError;
class DroppedLogs;
class OpenedProject;
class CreatedProject;
class ConfigUnavailable;
class InvalidRequest;
class SanityCheckError;
class BagFailedToOpen;
class BagFailedToClose;
class BagConversionFailed;
class BagFailedToWrite;
class CalibrationError;
class ProjectManagerFailedToStartRecording;
class ProjectManagerFailedToStopRecording;
class ServiceConnectionTimedOut;
class BagRecorderAlreadyRunning;
class LicenseServerConnectionError;
class LicenseError;
class LicenseNotFoundError;
class LicenseExpiredError;
class LicenseExceededError;
class LicenseHostMachineError;
class LicensePrivilegeError;
class LicenseActiveInfo;
class MultipleLicensesWarning;
class LicenseCurrentLicenseStatusInfo;
class BagRecordingStoppedInfo;
class BagRecordingFailedToStart;
class BagRecordingStartedInfo;
class ReplayRestartedInfo;
class InputSourceChangeRequestedInfo;
class InputSourceSwitchedInfo;
class RpcTimeoutWarning;
class CannotWriteLogFile;
class PointCloudParsingFailureWarning;
class LidarIsDead;
class LidarIsNotDeadAnymore;
class LidarIsObstructed;
class LidarIsNotObstructedAnymore;
class LidarIsTilted;
class LidarIsNotTiltedAnymore;
class LidarHasBeenAutomaticallyRecalibrated;
class ReceivedFirstDataForLidar;
class TerminationFailureError;
class FrameProcessingError;
class ThreadPoolUnavailableError;
class InvalidArgument;
class ComponentInitializationFailureFatal;
class UnhandledEnumCaseError;
class BagEmptyError;
class DiscardingDataError;
class DiscardingDataWarning;
class NothingToProcess;
class InvalidComponentConfiguration;
class ChannelReceiverNotFoundWarning;
class ModelLoadFailure;
class ModelExecutionFailureError;
class ServiceReadyInfo;
class ModelPreparingInfo;
class ModelInitializedInfo;
class ModelInitializationFailureWarning;
class RosSpinnerStoppedWarning;
class ActorSystemUnavailableError;
class ConfigNodeNotFoundError;
class BagTimestampOutOfOrderError;
class BagReplayUnexpectedTimestampError;
class WebsocketClosedInfo;
class WebsocketOpenedInfo;
class SubscriberDisconnectedInfo;
class ThreadPoolSlowingDownWarning;
class ThreadPoolNotRespondingWarning;
class ThreadPoolBrokenPromiseWarning;
class BoxFittingPointsBelowBaseWarning;
class FailedToRemoveStalePointsWarning;
class IrregularBroadcastingPeriodWarning;
class ClustererPointsOutOfRangeWarning;
class InternalError;
class InternalFatal;
class ServiceStartingInfo;
class ConfigNodeNotFoundFatal;
class ServiceSetupError;
class FilesystemError;
class InvalidPresetWarning;
class WebsocketFailedClearPendingError;
class WebsocketFailedToStopError;
class WebsocketFailedToCreateError;
class UnexpectedRpcError;
class LicensePollFailed;
class LicenseExpiredWarning;
class LicenseUsageExceededWarning;
class StaticThreadPoolSlowTaskWarning;
class RpcUnsupportedServiceWarning;
class WebsocketHandlerProblem;
class WebsocketDeserializeError;
class WebsocketExpiredRpcEndpointError;
class WebsocketQueueOverloadedWarning;
class RpcFailedToNotifyWarning;
class ConfigSubscriptionFailedWarning;
class ThreadPoolClampedWorkersWarning;
class StoppingHorusBagRecorderAlreadyStopped;
class RecorderConfigUpdateWhileRunning;
class ClampingDataWarning;
class LidarIncompatibleValues;
class CannotDetermineContainerIdError;
class StartedLidarDriver;
class CannotStartLidarDriver;
class StoppedLidarDriver;
class CannotStopLidarDriver;
class RestartedLidarDriver;
class CannotRestartLidarDriver;
class RemovedUnusedLidarDriver;
class CannotRemoveUnusedLidarDriver;
class LidarDriverGcFailure;
class IdSpaceExhausted;
class PreprocessingToPointAggregatorPointsSkipped;
class MinMsgIntervalLessThanThreshold;
class FailedToCleanupRosWarning;
class RpcDisconnectedWarning;
class RpcUnhandledError;
class TimeDiffOutOfRangeWarning;
class TensorrtLog;
class BuildingTensorrtEngineInfo;
class LoadingTensorrtEngineInfo;
class CalibrationMapNotFound;
class CalibrationMapNotValid;
class CalibrationMapPathAlreadyExists;
class FailedToSaveCalibrationMap;
class FailedToRemoveCalibrationMap;
class FailedToIterateInDirectory;
class MapBasedCalibrationWithoutMapLoading;
class MapBasedCalibrationAlreadyRunning;
class CancelMapBasedCalibrationNotRunning;
class BagStreamNotFound;
class EvaluationBagStartedInfo;
class EvaluationBagFinishedInfo;
class BagNotFound;
class BuildingPipelineInfo;
class BagIsNotEvaluation;
class HorusBagRunning;
class AutoGroundCalibrationWarning;
class AutoGroundCalibrationError;
class ObjectDetectorNotLoadedWarning;
class CalibrationIsRunningError;
class ModelInitInProgressInfo;
class RpcTimeoutWithResolutionWarning;
class CalibrationWasCancelledInfo;
class CalibrationMapRecordingFailedToStart;
class DetectionPipelineRequestedResetInfo;
class PreprocessingServicePipelineUnavailable;
class CircularRecordingDisabledWarning;
class SnapshotAlreadyRunningWarning;

// MARK: Message declarations

/// Log #1.
/// 
///  > $message
///
/// Source: horus/pb/logs/logs.proto:11:1
class Generic final : public PbMessage {
 public:

  /// Constructs a default-initialized `Generic`.
  Generic() noexcept = default;

  /// Move constructor.
  Generic(Generic&&) noexcept = default;
  /// Move assignment operator.
  Generic& operator=(Generic&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit Generic(const Generic& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  Generic& operator=(const Generic&) = delete;

  /// Default destructor.
  ~Generic() noexcept final = default;

  /// Creates a `Generic` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit Generic(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.Generic`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.Generic"; }

  /// The full name of the message: `horus.pb.logs.Generic`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `message` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& message() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return message_;
  }

  /// If `message` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes message() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(message_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_message() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return message_;
  }

  /// Returns whether `message` (no 1) is set.
  constexpr bool has_message() const noexcept { return set_fields_[0]; }

  /// Clears `message` (no 1).
  void clear_message() & noexcept {
    set_fields_[0] = false;
    message_ = {};
  }

  /// Sets `message` (no 1) and returns `*this`.
  Generic& set_message(CowBytes&& message) & noexcept {
    set_fields_[0] = true;
    message_ = std::move(message);
    return *this;
  }
  /// Sets `message` (no 1) and returns `*this`.
  Generic&& set_message(CowBytes&& message) && noexcept {
    return std::move(set_message(std::move(message)));
  }

  // Field `location` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_SourceLocation& location() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return location_;
  }

  /// If `location` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation location() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(location_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation& mutable_location() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return location_;
  }

  /// Returns whether `location` (no 2) is set.
  constexpr bool has_location() const noexcept { return set_fields_[1]; }

  /// Clears `location` (no 2).
  void clear_location() & noexcept {
    set_fields_[1] = false;
    location_ = {};
  }

  /// Sets `location` (no 2) and returns `*this`.
  Generic& set_location(horus::pb::LogMetadata_SourceLocation&& location) & noexcept {
    set_fields_[1] = true;
    location_ = std::move(location);
    return *this;
  }
  /// Sets `location` (no 2) and returns `*this`.
  Generic&& set_location(horus::pb::LogMetadata_SourceLocation&& location) && noexcept {
    return std::move(set_location(std::move(location)));
  }

 private:
  /// @see message()
  CowBytes message_{};
  /// @see location()
  horus::pb::LogMetadata_SourceLocation location_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #2.
/// 
///  > Out of memory
///
/// Source: horus/pb/logs/logs.proto:19:1
class Oom final : public PbMessage {
 public:

  /// Constructs a default-initialized `Oom`.
  Oom() noexcept = default;

  /// Move constructor.
  Oom(Oom&&) noexcept = default;
  /// Move assignment operator.
  Oom& operator=(Oom&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit Oom(const Oom&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  Oom& operator=(const Oom&) = delete;

  /// Default destructor.
  ~Oom() noexcept final = default;

  /// Creates a `Oom` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit Oom(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.Oom`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.Oom"; }

  /// The full name of the message: `horus.pb.logs.Oom`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #3.
/// 
///  > Cannot initiate connection to $target_service at $target_uri: $details
///
/// Source: horus/pb/logs/logs.proto:25:1
class RpcConnectionError final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcConnectionError`.
  RpcConnectionError() noexcept = default;

  /// Move constructor.
  RpcConnectionError(RpcConnectionError&&) noexcept = default;
  /// Move assignment operator.
  RpcConnectionError& operator=(RpcConnectionError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcConnectionError(const RpcConnectionError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcConnectionError& operator=(const RpcConnectionError&) = delete;

  /// Default destructor.
  ~RpcConnectionError() noexcept final = default;

  /// Creates a `RpcConnectionError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcConnectionError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcConnectionError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcConnectionError"; }

  /// The full name of the message: `horus.pb.logs.RpcConnectionError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `target_service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& target_service() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return target_service_;
  }

  /// If `target_service` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes target_service() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(target_service_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_target_service() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return target_service_;
  }

  /// Returns whether `target_service` (no 1) is set.
  constexpr bool has_target_service() const noexcept { return set_fields_[0]; }

  /// Clears `target_service` (no 1).
  void clear_target_service() & noexcept {
    set_fields_[0] = false;
    target_service_ = {};
  }

  /// Sets `target_service` (no 1) and returns `*this`.
  RpcConnectionError& set_target_service(CowBytes&& target_service) & noexcept {
    set_fields_[0] = true;
    target_service_ = std::move(target_service);
    return *this;
  }
  /// Sets `target_service` (no 1) and returns `*this`.
  RpcConnectionError&& set_target_service(CowBytes&& target_service) && noexcept {
    return std::move(set_target_service(std::move(target_service)));
  }

  // Field `target_uri` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& target_uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return target_uri_;
  }

  /// If `target_uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes target_uri() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(target_uri_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_target_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return target_uri_;
  }

  /// Returns whether `target_uri` (no 2) is set.
  constexpr bool has_target_uri() const noexcept { return set_fields_[1]; }

  /// Clears `target_uri` (no 2).
  void clear_target_uri() & noexcept {
    set_fields_[1] = false;
    target_uri_ = {};
  }

  /// Sets `target_uri` (no 2) and returns `*this`.
  RpcConnectionError& set_target_uri(CowBytes&& target_uri) & noexcept {
    set_fields_[1] = true;
    target_uri_ = std::move(target_uri);
    return *this;
  }
  /// Sets `target_uri` (no 2) and returns `*this`.
  RpcConnectionError&& set_target_uri(CowBytes&& target_uri) && noexcept {
    return std::move(set_target_uri(std::move(target_uri)));
  }

  // Field `details` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes details() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return details_;
  }

  /// Returns whether `details` (no 3) is set.
  constexpr bool has_details() const noexcept { return set_fields_[2]; }

  /// Clears `details` (no 3).
  void clear_details() & noexcept {
    set_fields_[2] = false;
    details_ = {};
  }

  /// Sets `details` (no 3) and returns `*this`.
  RpcConnectionError& set_details(CowBytes&& details) & noexcept {
    set_fields_[2] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 3) and returns `*this`.
  RpcConnectionError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see target_service()
  CowBytes target_service_{};
  /// @see target_uri()
  CowBytes target_uri_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #4.
/// 
///  > Project name `$name` is invalid: $details
///
/// Source: horus/pb/logs/logs.proto:34:1
class InvalidProjectName final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidProjectName`.
  InvalidProjectName() noexcept = default;

  /// Move constructor.
  InvalidProjectName(InvalidProjectName&&) noexcept = default;
  /// Move assignment operator.
  InvalidProjectName& operator=(InvalidProjectName&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidProjectName(const InvalidProjectName& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidProjectName& operator=(const InvalidProjectName&) = delete;

  /// Default destructor.
  ~InvalidProjectName() noexcept final = default;

  /// Creates a `InvalidProjectName` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidProjectName(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidProjectName`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidProjectName"; }

  /// The full name of the message: `horus.pb.logs.InvalidProjectName`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  InvalidProjectName& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  InvalidProjectName&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  InvalidProjectName& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  InvalidProjectName&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see name()
  CowBytes name_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #5.
/// 
///  > Project `$name` not found
///
/// Source: horus/pb/logs/logs.proto:42:1
class ProjectNotFound final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProjectNotFound`.
  ProjectNotFound() noexcept = default;

  /// Move constructor.
  ProjectNotFound(ProjectNotFound&&) noexcept = default;
  /// Move assignment operator.
  ProjectNotFound& operator=(ProjectNotFound&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProjectNotFound(const ProjectNotFound& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProjectNotFound& operator=(const ProjectNotFound&) = delete;

  /// Default destructor.
  ~ProjectNotFound() noexcept final = default;

  /// Creates a `ProjectNotFound` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProjectNotFound(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ProjectNotFound`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ProjectNotFound"; }

  /// The full name of the message: `horus.pb.logs.ProjectNotFound`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  ProjectNotFound& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  ProjectNotFound&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

 private:
  /// @see name()
  CowBytes name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #6.
/// 
///  > Project `$name` already exists
///
/// Source: horus/pb/logs/logs.proto:49:1
class ProjectAlreadyExists final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProjectAlreadyExists`.
  ProjectAlreadyExists() noexcept = default;

  /// Move constructor.
  ProjectAlreadyExists(ProjectAlreadyExists&&) noexcept = default;
  /// Move assignment operator.
  ProjectAlreadyExists& operator=(ProjectAlreadyExists&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProjectAlreadyExists(const ProjectAlreadyExists& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProjectAlreadyExists& operator=(const ProjectAlreadyExists&) = delete;

  /// Default destructor.
  ~ProjectAlreadyExists() noexcept final = default;

  /// Creates a `ProjectAlreadyExists` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProjectAlreadyExists(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ProjectAlreadyExists`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ProjectAlreadyExists"; }

  /// The full name of the message: `horus.pb.logs.ProjectAlreadyExists`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  ProjectAlreadyExists& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  ProjectAlreadyExists&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

 private:
  /// @see name()
  CowBytes name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #7.
/// 
///  > Configuration is invalid
///
/// Source: horus/pb/logs/logs.proto:56:1
class InvalidConfiguration final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidConfiguration`.
  InvalidConfiguration() noexcept = default;

  /// Move constructor.
  InvalidConfiguration(InvalidConfiguration&&) noexcept = default;
  /// Move assignment operator.
  InvalidConfiguration& operator=(InvalidConfiguration&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidConfiguration(const InvalidConfiguration& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidConfiguration& operator=(const InvalidConfiguration&) = delete;

  /// Default destructor.
  ~InvalidConfiguration() noexcept final = default;

  /// Creates a `InvalidConfiguration` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidConfiguration(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidConfiguration`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidConfiguration"; }

  /// The full name of the message: `horus.pb.logs.InvalidConfiguration`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `validation_errors` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowRepeated<ValidationError>& validation_errors() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return validation_errors_;
  }

  /// If `validation_errors` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowRepeated<ValidationError> validation_errors() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(validation_errors_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowRepeated<ValidationError>& mutable_validation_errors() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return validation_errors_;
  }

  /// Returns whether `validation_errors` (no 1) is set.
  constexpr bool has_validation_errors() const noexcept { return set_fields_[0]; }

  /// Clears `validation_errors` (no 1).
  void clear_validation_errors() & noexcept {
    set_fields_[0] = false;
    validation_errors_ = {};
  }

  /// Sets `validation_errors` (no 1) and returns `*this`.
  InvalidConfiguration& set_validation_errors(CowRepeated<ValidationError>&& validation_errors) & noexcept {
    set_fields_[0] = true;
    validation_errors_ = std::move(validation_errors);
    return *this;
  }
  /// Sets `validation_errors` (no 1) and returns `*this`.
  InvalidConfiguration&& set_validation_errors(CowRepeated<ValidationError>&& validation_errors) && noexcept {
    return std::move(set_validation_errors(std::move(validation_errors)));
  }

 private:
  /// @see validation_errors()
  CowRepeated<ValidationError> validation_errors_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #8.
/// 
///  > $entity_type `$id` not found
///
/// Source: horus/pb/logs/logs.proto:63:1
class EntityNotFound final : public PbMessage {
 public:

  /// Constructs a default-initialized `EntityNotFound`.
  EntityNotFound() noexcept = default;

  /// Move constructor.
  EntityNotFound(EntityNotFound&&) noexcept = default;
  /// Move assignment operator.
  EntityNotFound& operator=(EntityNotFound&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit EntityNotFound(const EntityNotFound& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  EntityNotFound& operator=(const EntityNotFound&) = delete;

  /// Default destructor.
  ~EntityNotFound() noexcept final = default;

  /// Creates a `EntityNotFound` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit EntityNotFound(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.EntityNotFound`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.EntityNotFound"; }

  /// The full name of the message: `horus.pb.logs.EntityNotFound`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return id_;
  }

  /// If `id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return id_;
  }

  /// Returns whether `id` (no 1) is set.
  constexpr bool has_id() const noexcept { return set_fields_[0]; }

  /// Clears `id` (no 1).
  void clear_id() & noexcept {
    set_fields_[0] = false;
    id_ = {};
  }

  /// Sets `id` (no 1) and returns `*this`.
  EntityNotFound& set_id(CowBytes&& id) & noexcept {
    set_fields_[0] = true;
    id_ = std::move(id);
    return *this;
  }
  /// Sets `id` (no 1) and returns `*this`.
  EntityNotFound&& set_id(CowBytes&& id) && noexcept {
    return std::move(set_id(std::move(id)));
  }

  // Field `entity_type` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& entity_type() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return entity_type_;
  }

  /// If `entity_type` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes entity_type() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(entity_type_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_entity_type() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return entity_type_;
  }

  /// Returns whether `entity_type` (no 2) is set.
  constexpr bool has_entity_type() const noexcept { return set_fields_[1]; }

  /// Clears `entity_type` (no 2).
  void clear_entity_type() & noexcept {
    set_fields_[1] = false;
    entity_type_ = {};
  }

  /// Sets `entity_type` (no 2) and returns `*this`.
  EntityNotFound& set_entity_type(CowBytes&& entity_type) & noexcept {
    set_fields_[1] = true;
    entity_type_ = std::move(entity_type);
    return *this;
  }
  /// Sets `entity_type` (no 2) and returns `*this`.
  EntityNotFound&& set_entity_type(CowBytes&& entity_type) && noexcept {
    return std::move(set_entity_type(std::move(entity_type)));
  }

 private:
  /// @see id()
  CowBytes id_{};
  /// @see entity_type()
  CowBytes entity_type_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #9.
/// 
///  > Active project cannot be deleted
///
/// Source: horus/pb/logs/logs.proto:71:1
class ActiveProjectCannotBeDeleted final : public PbMessage {
 public:

  /// Constructs a default-initialized `ActiveProjectCannotBeDeleted`.
  ActiveProjectCannotBeDeleted() noexcept = default;

  /// Move constructor.
  ActiveProjectCannotBeDeleted(ActiveProjectCannotBeDeleted&&) noexcept = default;
  /// Move assignment operator.
  ActiveProjectCannotBeDeleted& operator=(ActiveProjectCannotBeDeleted&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ActiveProjectCannotBeDeleted(const ActiveProjectCannotBeDeleted&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ActiveProjectCannotBeDeleted& operator=(const ActiveProjectCannotBeDeleted&) = delete;

  /// Default destructor.
  ~ActiveProjectCannotBeDeleted() noexcept final = default;

  /// Creates a `ActiveProjectCannotBeDeleted` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ActiveProjectCannotBeDeleted(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ActiveProjectCannotBeDeleted`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ActiveProjectCannotBeDeleted"; }

  /// The full name of the message: `horus.pb.logs.ActiveProjectCannotBeDeleted`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #10.
/// 
///  > Cannot terminate connection to $target_service at $target_uri: $details
///
/// Source: horus/pb/logs/logs.proto:77:1
class RpcDisconnectionError final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcDisconnectionError`.
  RpcDisconnectionError() noexcept = default;

  /// Move constructor.
  RpcDisconnectionError(RpcDisconnectionError&&) noexcept = default;
  /// Move assignment operator.
  RpcDisconnectionError& operator=(RpcDisconnectionError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcDisconnectionError(const RpcDisconnectionError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcDisconnectionError& operator=(const RpcDisconnectionError&) = delete;

  /// Default destructor.
  ~RpcDisconnectionError() noexcept final = default;

  /// Creates a `RpcDisconnectionError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcDisconnectionError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcDisconnectionError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcDisconnectionError"; }

  /// The full name of the message: `horus.pb.logs.RpcDisconnectionError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `target_service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& target_service() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return target_service_;
  }

  /// If `target_service` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes target_service() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(target_service_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_target_service() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return target_service_;
  }

  /// Returns whether `target_service` (no 1) is set.
  constexpr bool has_target_service() const noexcept { return set_fields_[0]; }

  /// Clears `target_service` (no 1).
  void clear_target_service() & noexcept {
    set_fields_[0] = false;
    target_service_ = {};
  }

  /// Sets `target_service` (no 1) and returns `*this`.
  RpcDisconnectionError& set_target_service(CowBytes&& target_service) & noexcept {
    set_fields_[0] = true;
    target_service_ = std::move(target_service);
    return *this;
  }
  /// Sets `target_service` (no 1) and returns `*this`.
  RpcDisconnectionError&& set_target_service(CowBytes&& target_service) && noexcept {
    return std::move(set_target_service(std::move(target_service)));
  }

  // Field `target_uri` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& target_uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return target_uri_;
  }

  /// If `target_uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes target_uri() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(target_uri_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_target_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return target_uri_;
  }

  /// Returns whether `target_uri` (no 2) is set.
  constexpr bool has_target_uri() const noexcept { return set_fields_[1]; }

  /// Clears `target_uri` (no 2).
  void clear_target_uri() & noexcept {
    set_fields_[1] = false;
    target_uri_ = {};
  }

  /// Sets `target_uri` (no 2) and returns `*this`.
  RpcDisconnectionError& set_target_uri(CowBytes&& target_uri) & noexcept {
    set_fields_[1] = true;
    target_uri_ = std::move(target_uri);
    return *this;
  }
  /// Sets `target_uri` (no 2) and returns `*this`.
  RpcDisconnectionError&& set_target_uri(CowBytes&& target_uri) && noexcept {
    return std::move(set_target_uri(std::move(target_uri)));
  }

  // Field `details` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes details() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return details_;
  }

  /// Returns whether `details` (no 3) is set.
  constexpr bool has_details() const noexcept { return set_fields_[2]; }

  /// Clears `details` (no 3).
  void clear_details() & noexcept {
    set_fields_[2] = false;
    details_ = {};
  }

  /// Sets `details` (no 3) and returns `*this`.
  RpcDisconnectionError& set_details(CowBytes&& details) & noexcept {
    set_fields_[2] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 3) and returns `*this`.
  RpcDisconnectionError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see target_service()
  CowBytes target_service_{};
  /// @see target_uri()
  CowBytes target_uri_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #11.
/// 
///  > Dropped $n log messages
///
/// Source: horus/pb/logs/logs.proto:86:1
class DroppedLogs final : public PbMessage {
 public:

  /// Constructs a default-initialized `DroppedLogs`.
  DroppedLogs() noexcept = default;

  /// Move constructor.
  DroppedLogs(DroppedLogs&&) noexcept = default;
  /// Move assignment operator.
  DroppedLogs& operator=(DroppedLogs&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DroppedLogs(const DroppedLogs& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DroppedLogs& operator=(const DroppedLogs&) = delete;

  /// Default destructor.
  ~DroppedLogs() noexcept final = default;

  /// Creates a `DroppedLogs` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DroppedLogs(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.DroppedLogs`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.DroppedLogs"; }

  /// The full name of the message: `horus.pb.logs.DroppedLogs`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `n` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t n() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return n_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_n() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return n_;
  }

  /// Returns whether `n` (no 1) is set.
  constexpr bool has_n() const noexcept { return set_fields_[0]; }

  /// Clears `n` (no 1).
  void clear_n() & noexcept {
    set_fields_[0] = false;
    n_ = {};
  }

  /// Sets `n` (no 1) and returns `*this`.
  DroppedLogs& set_n(std::uint64_t n) & noexcept {
    set_fields_[0] = true;
    n_ = n;
    return *this;
  }
  /// Sets `n` (no 1) and returns `*this`.
  DroppedLogs&& set_n(std::uint64_t n) && noexcept {
    return std::move(set_n(n));
  }

 private:
  /// @see n()
  std::uint64_t n_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #12.
/// 
///  > Opened project $project_name
///
/// Source: horus/pb/logs/logs.proto:93:1
class OpenedProject final : public PbMessage {
 public:

  /// Constructs a default-initialized `OpenedProject`.
  OpenedProject() noexcept = default;

  /// Move constructor.
  OpenedProject(OpenedProject&&) noexcept = default;
  /// Move assignment operator.
  OpenedProject& operator=(OpenedProject&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit OpenedProject(const OpenedProject& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  OpenedProject& operator=(const OpenedProject&) = delete;

  /// Default destructor.
  ~OpenedProject() noexcept final = default;

  /// Creates a `OpenedProject` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit OpenedProject(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.OpenedProject`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.OpenedProject"; }

  /// The full name of the message: `horus.pb.logs.OpenedProject`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `project_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& project_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return project_name_;
  }

  /// If `project_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes project_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(project_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_project_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return project_name_;
  }

  /// Returns whether `project_name` (no 1) is set.
  constexpr bool has_project_name() const noexcept { return set_fields_[0]; }

  /// Clears `project_name` (no 1).
  void clear_project_name() & noexcept {
    set_fields_[0] = false;
    project_name_ = {};
  }

  /// Sets `project_name` (no 1) and returns `*this`.
  OpenedProject& set_project_name(CowBytes&& project_name) & noexcept {
    set_fields_[0] = true;
    project_name_ = std::move(project_name);
    return *this;
  }
  /// Sets `project_name` (no 1) and returns `*this`.
  OpenedProject&& set_project_name(CowBytes&& project_name) && noexcept {
    return std::move(set_project_name(std::move(project_name)));
  }

 private:
  /// @see project_name()
  CowBytes project_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #13.
/// 
///  > Created project $project_name from $source_name
///
/// Source: horus/pb/logs/logs.proto:100:1
class CreatedProject final : public PbMessage {
 public:

  /// Constructs a default-initialized `CreatedProject`.
  CreatedProject() noexcept = default;

  /// Move constructor.
  CreatedProject(CreatedProject&&) noexcept = default;
  /// Move assignment operator.
  CreatedProject& operator=(CreatedProject&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CreatedProject(const CreatedProject& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CreatedProject& operator=(const CreatedProject&) = delete;

  /// Default destructor.
  ~CreatedProject() noexcept final = default;

  /// Creates a `CreatedProject` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CreatedProject(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CreatedProject`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CreatedProject"; }

  /// The full name of the message: `horus.pb.logs.CreatedProject`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `project_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& project_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return project_name_;
  }

  /// If `project_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes project_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(project_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_project_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return project_name_;
  }

  /// Returns whether `project_name` (no 1) is set.
  constexpr bool has_project_name() const noexcept { return set_fields_[0]; }

  /// Clears `project_name` (no 1).
  void clear_project_name() & noexcept {
    set_fields_[0] = false;
    project_name_ = {};
  }

  /// Sets `project_name` (no 1) and returns `*this`.
  CreatedProject& set_project_name(CowBytes&& project_name) & noexcept {
    set_fields_[0] = true;
    project_name_ = std::move(project_name);
    return *this;
  }
  /// Sets `project_name` (no 1) and returns `*this`.
  CreatedProject&& set_project_name(CowBytes&& project_name) && noexcept {
    return std::move(set_project_name(std::move(project_name)));
  }

  // Field `source_name` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& source_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return source_name_;
  }

  /// If `source_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes source_name() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(source_name_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_source_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return source_name_;
  }

  /// Returns whether `source_name` (no 2) is set.
  constexpr bool has_source_name() const noexcept { return set_fields_[1]; }

  /// Clears `source_name` (no 2).
  void clear_source_name() & noexcept {
    set_fields_[1] = false;
    source_name_ = {};
  }

  /// Sets `source_name` (no 2) and returns `*this`.
  CreatedProject& set_source_name(CowBytes&& source_name) & noexcept {
    set_fields_[1] = true;
    source_name_ = std::move(source_name);
    return *this;
  }
  /// Sets `source_name` (no 2) and returns `*this`.
  CreatedProject&& set_source_name(CowBytes&& source_name) && noexcept {
    return std::move(set_source_name(std::move(source_name)));
  }

 private:
  /// @see project_name()
  CowBytes project_name_{};
  /// @see source_name()
  CowBytes source_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #14.
/// 
///  > Configuration is unavailable; request cannot be processed.
///
/// Source: horus/pb/logs/logs.proto:108:1
class ConfigUnavailable final : public PbMessage {
 public:

  /// Constructs a default-initialized `ConfigUnavailable`.
  ConfigUnavailable() noexcept = default;

  /// Move constructor.
  ConfigUnavailable(ConfigUnavailable&&) noexcept = default;
  /// Move assignment operator.
  ConfigUnavailable& operator=(ConfigUnavailable&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ConfigUnavailable(const ConfigUnavailable&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ConfigUnavailable& operator=(const ConfigUnavailable&) = delete;

  /// Default destructor.
  ~ConfigUnavailable() noexcept final = default;

  /// Creates a `ConfigUnavailable` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ConfigUnavailable(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ConfigUnavailable`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ConfigUnavailable"; }

  /// The full name of the message: `horus.pb.logs.ConfigUnavailable`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #15.
/// 
///  > Invalid request received: $details
///
/// Source: horus/pb/logs/logs.proto:114:1
class InvalidRequest final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidRequest`.
  InvalidRequest() noexcept = default;

  /// Move constructor.
  InvalidRequest(InvalidRequest&&) noexcept = default;
  /// Move assignment operator.
  InvalidRequest& operator=(InvalidRequest&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidRequest(const InvalidRequest& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidRequest& operator=(const InvalidRequest&) = delete;

  /// Default destructor.
  ~InvalidRequest() noexcept final = default;

  /// Creates a `InvalidRequest` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidRequest(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidRequest`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidRequest"; }

  /// The full name of the message: `horus.pb.logs.InvalidRequest`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  InvalidRequest& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  InvalidRequest&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #16.
/// 
///  > $sanity_check_name failed: $details
///
/// Source: horus/pb/logs/logs.proto:121:1
class SanityCheckError final : public PbMessage {
 public:

  /// Constructs a default-initialized `SanityCheckError`.
  SanityCheckError() noexcept = default;

  /// Move constructor.
  SanityCheckError(SanityCheckError&&) noexcept = default;
  /// Move assignment operator.
  SanityCheckError& operator=(SanityCheckError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit SanityCheckError(const SanityCheckError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  SanityCheckError& operator=(const SanityCheckError&) = delete;

  /// Default destructor.
  ~SanityCheckError() noexcept final = default;

  /// Creates a `SanityCheckError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit SanityCheckError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.SanityCheckError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.SanityCheckError"; }

  /// The full name of the message: `horus.pb.logs.SanityCheckError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `sanity_check_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& sanity_check_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return sanity_check_name_;
  }

  /// If `sanity_check_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes sanity_check_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(sanity_check_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_sanity_check_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return sanity_check_name_;
  }

  /// Returns whether `sanity_check_name` (no 1) is set.
  constexpr bool has_sanity_check_name() const noexcept { return set_fields_[0]; }

  /// Clears `sanity_check_name` (no 1).
  void clear_sanity_check_name() & noexcept {
    set_fields_[0] = false;
    sanity_check_name_ = {};
  }

  /// Sets `sanity_check_name` (no 1) and returns `*this`.
  SanityCheckError& set_sanity_check_name(CowBytes&& sanity_check_name) & noexcept {
    set_fields_[0] = true;
    sanity_check_name_ = std::move(sanity_check_name);
    return *this;
  }
  /// Sets `sanity_check_name` (no 1) and returns `*this`.
  SanityCheckError&& set_sanity_check_name(CowBytes&& sanity_check_name) && noexcept {
    return std::move(set_sanity_check_name(std::move(sanity_check_name)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  SanityCheckError& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  SanityCheckError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see sanity_check_name()
  CowBytes sanity_check_name_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #17.
/// 
///  > The bag file ($horus_bag_path) could not be opened: $details
///
/// Source: horus/pb/logs/logs.proto:129:1
class BagFailedToOpen final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagFailedToOpen`.
  BagFailedToOpen() noexcept = default;

  /// Move constructor.
  BagFailedToOpen(BagFailedToOpen&&) noexcept = default;
  /// Move assignment operator.
  BagFailedToOpen& operator=(BagFailedToOpen&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagFailedToOpen(const BagFailedToOpen& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagFailedToOpen& operator=(const BagFailedToOpen&) = delete;

  /// Default destructor.
  ~BagFailedToOpen() noexcept final = default;

  /// Creates a `BagFailedToOpen` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagFailedToOpen(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagFailedToOpen`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagFailedToOpen"; }

  /// The full name of the message: `horus.pb.logs.BagFailedToOpen`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `horus_bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& horus_bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return horus_bag_path_;
  }

  /// If `horus_bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes horus_bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(horus_bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_horus_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return horus_bag_path_;
  }

  /// Returns whether `horus_bag_path` (no 1) is set.
  constexpr bool has_horus_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `horus_bag_path` (no 1).
  void clear_horus_bag_path() & noexcept {
    set_fields_[0] = false;
    horus_bag_path_ = {};
  }

  /// Sets `horus_bag_path` (no 1) and returns `*this`.
  BagFailedToOpen& set_horus_bag_path(CowBytes&& horus_bag_path) & noexcept {
    set_fields_[0] = true;
    horus_bag_path_ = std::move(horus_bag_path);
    return *this;
  }
  /// Sets `horus_bag_path` (no 1) and returns `*this`.
  BagFailedToOpen&& set_horus_bag_path(CowBytes&& horus_bag_path) && noexcept {
    return std::move(set_horus_bag_path(std::move(horus_bag_path)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  BagFailedToOpen& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  BagFailedToOpen&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see horus_bag_path()
  CowBytes horus_bag_path_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #18.
/// 
///  > Bag file could not be closed: $details
///
/// Source: horus/pb/logs/logs.proto:137:1
class BagFailedToClose final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagFailedToClose`.
  BagFailedToClose() noexcept = default;

  /// Move constructor.
  BagFailedToClose(BagFailedToClose&&) noexcept = default;
  /// Move assignment operator.
  BagFailedToClose& operator=(BagFailedToClose&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagFailedToClose(const BagFailedToClose& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagFailedToClose& operator=(const BagFailedToClose&) = delete;

  /// Default destructor.
  ~BagFailedToClose() noexcept final = default;

  /// Creates a `BagFailedToClose` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagFailedToClose(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagFailedToClose`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagFailedToClose"; }

  /// The full name of the message: `horus.pb.logs.BagFailedToClose`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  BagFailedToClose& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  BagFailedToClose&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #19.
/// 
///  > Bag file conversion failed: $details
///
/// Source: horus/pb/logs/logs.proto:144:1
class BagConversionFailed final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagConversionFailed`.
  BagConversionFailed() noexcept = default;

  /// Move constructor.
  BagConversionFailed(BagConversionFailed&&) noexcept = default;
  /// Move assignment operator.
  BagConversionFailed& operator=(BagConversionFailed&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagConversionFailed(const BagConversionFailed& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagConversionFailed& operator=(const BagConversionFailed&) = delete;

  /// Default destructor.
  ~BagConversionFailed() noexcept final = default;

  /// Creates a `BagConversionFailed` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagConversionFailed(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagConversionFailed`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagConversionFailed"; }

  /// The full name of the message: `horus.pb.logs.BagConversionFailed`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  BagConversionFailed& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  BagConversionFailed&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #20.
/// 
///  > Bag file writing failed $name: $details
///
/// Source: horus/pb/logs/logs.proto:151:1
class BagFailedToWrite final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagFailedToWrite`.
  BagFailedToWrite() noexcept = default;

  /// Move constructor.
  BagFailedToWrite(BagFailedToWrite&&) noexcept = default;
  /// Move assignment operator.
  BagFailedToWrite& operator=(BagFailedToWrite&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagFailedToWrite(const BagFailedToWrite& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagFailedToWrite& operator=(const BagFailedToWrite&) = delete;

  /// Default destructor.
  ~BagFailedToWrite() noexcept final = default;

  /// Creates a `BagFailedToWrite` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagFailedToWrite(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagFailedToWrite`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagFailedToWrite"; }

  /// The full name of the message: `horus.pb.logs.BagFailedToWrite`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  BagFailedToWrite& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  BagFailedToWrite&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  BagFailedToWrite& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  BagFailedToWrite&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see name()
  CowBytes name_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #21.
/// 
///  > Calibration failed: $details
///
/// Source: horus/pb/logs/logs.proto:159:1
class CalibrationError final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationError`.
  CalibrationError() noexcept = default;

  /// Move constructor.
  CalibrationError(CalibrationError&&) noexcept = default;
  /// Move assignment operator.
  CalibrationError& operator=(CalibrationError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationError(const CalibrationError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationError& operator=(const CalibrationError&) = delete;

  /// Default destructor.
  ~CalibrationError() noexcept final = default;

  /// Creates a `CalibrationError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationError"; }

  /// The full name of the message: `horus.pb.logs.CalibrationError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  CalibrationError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  CalibrationError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #22.
/// 
///  > Failed to start recording: $details
///
/// Source: horus/pb/logs/logs.proto:166:1
class ProjectManagerFailedToStartRecording final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProjectManagerFailedToStartRecording`.
  ProjectManagerFailedToStartRecording() noexcept = default;

  /// Move constructor.
  ProjectManagerFailedToStartRecording(ProjectManagerFailedToStartRecording&&) noexcept = default;
  /// Move assignment operator.
  ProjectManagerFailedToStartRecording& operator=(ProjectManagerFailedToStartRecording&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProjectManagerFailedToStartRecording(const ProjectManagerFailedToStartRecording& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProjectManagerFailedToStartRecording& operator=(const ProjectManagerFailedToStartRecording&) = delete;

  /// Default destructor.
  ~ProjectManagerFailedToStartRecording() noexcept final = default;

  /// Creates a `ProjectManagerFailedToStartRecording` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProjectManagerFailedToStartRecording(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ProjectManagerFailedToStartRecording`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ProjectManagerFailedToStartRecording"; }

  /// The full name of the message: `horus.pb.logs.ProjectManagerFailedToStartRecording`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  ProjectManagerFailedToStartRecording& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  ProjectManagerFailedToStartRecording&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #23.
/// 
///  > Failed to stop recording: $details
///
/// Source: horus/pb/logs/logs.proto:173:1
class ProjectManagerFailedToStopRecording final : public PbMessage {
 public:

  /// Constructs a default-initialized `ProjectManagerFailedToStopRecording`.
  ProjectManagerFailedToStopRecording() noexcept = default;

  /// Move constructor.
  ProjectManagerFailedToStopRecording(ProjectManagerFailedToStopRecording&&) noexcept = default;
  /// Move assignment operator.
  ProjectManagerFailedToStopRecording& operator=(ProjectManagerFailedToStopRecording&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ProjectManagerFailedToStopRecording(const ProjectManagerFailedToStopRecording& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ProjectManagerFailedToStopRecording& operator=(const ProjectManagerFailedToStopRecording&) = delete;

  /// Default destructor.
  ~ProjectManagerFailedToStopRecording() noexcept final = default;

  /// Creates a `ProjectManagerFailedToStopRecording` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ProjectManagerFailedToStopRecording(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ProjectManagerFailedToStopRecording`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ProjectManagerFailedToStopRecording"; }

  /// The full name of the message: `horus.pb.logs.ProjectManagerFailedToStopRecording`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  ProjectManagerFailedToStopRecording& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  ProjectManagerFailedToStopRecording&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #24.
/// 
///  > The connection with the requested $node_type node with ID $node_id timed out
///
/// Source: horus/pb/logs/logs.proto:180:1
class ServiceConnectionTimedOut final : public PbMessage {
 public:

  /// Constructs a default-initialized `ServiceConnectionTimedOut`.
  ServiceConnectionTimedOut() noexcept = default;

  /// Move constructor.
  ServiceConnectionTimedOut(ServiceConnectionTimedOut&&) noexcept = default;
  /// Move assignment operator.
  ServiceConnectionTimedOut& operator=(ServiceConnectionTimedOut&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ServiceConnectionTimedOut(const ServiceConnectionTimedOut& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ServiceConnectionTimedOut& operator=(const ServiceConnectionTimedOut&) = delete;

  /// Default destructor.
  ~ServiceConnectionTimedOut() noexcept final = default;

  /// Creates a `ServiceConnectionTimedOut` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ServiceConnectionTimedOut(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ServiceConnectionTimedOut`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ServiceConnectionTimedOut"; }

  /// The full name of the message: `horus.pb.logs.ServiceConnectionTimedOut`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `node_type` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& node_type() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return node_type_;
  }

  /// If `node_type` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes node_type() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(node_type_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_node_type() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return node_type_;
  }

  /// Returns whether `node_type` (no 1) is set.
  constexpr bool has_node_type() const noexcept { return set_fields_[0]; }

  /// Clears `node_type` (no 1).
  void clear_node_type() & noexcept {
    set_fields_[0] = false;
    node_type_ = {};
  }

  /// Sets `node_type` (no 1) and returns `*this`.
  ServiceConnectionTimedOut& set_node_type(CowBytes&& node_type) & noexcept {
    set_fields_[0] = true;
    node_type_ = std::move(node_type);
    return *this;
  }
  /// Sets `node_type` (no 1) and returns `*this`.
  ServiceConnectionTimedOut&& set_node_type(CowBytes&& node_type) && noexcept {
    return std::move(set_node_type(std::move(node_type)));
  }

  // Field `node_id` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& node_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return node_id_;
  }

  /// If `node_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes node_id() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(node_id_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_node_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return node_id_;
  }

  /// Returns whether `node_id` (no 2) is set.
  constexpr bool has_node_id() const noexcept { return set_fields_[1]; }

  /// Clears `node_id` (no 2).
  void clear_node_id() & noexcept {
    set_fields_[1] = false;
    node_id_ = {};
  }

  /// Sets `node_id` (no 2) and returns `*this`.
  ServiceConnectionTimedOut& set_node_id(CowBytes&& node_id) & noexcept {
    set_fields_[1] = true;
    node_id_ = std::move(node_id);
    return *this;
  }
  /// Sets `node_id` (no 2) and returns `*this`.
  ServiceConnectionTimedOut&& set_node_id(CowBytes&& node_id) && noexcept {
    return std::move(set_node_id(std::move(node_id)));
  }

 private:
  /// @see node_type()
  CowBytes node_type_{};
  /// @see node_id()
  CowBytes node_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #25.
/// 
///  > Bag recorder is already running for $path
///
/// Source: horus/pb/logs/logs.proto:188:1
class BagRecorderAlreadyRunning final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagRecorderAlreadyRunning`.
  BagRecorderAlreadyRunning() noexcept = default;

  /// Move constructor.
  BagRecorderAlreadyRunning(BagRecorderAlreadyRunning&&) noexcept = default;
  /// Move assignment operator.
  BagRecorderAlreadyRunning& operator=(BagRecorderAlreadyRunning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagRecorderAlreadyRunning(const BagRecorderAlreadyRunning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagRecorderAlreadyRunning& operator=(const BagRecorderAlreadyRunning&) = delete;

  /// Default destructor.
  ~BagRecorderAlreadyRunning() noexcept final = default;

  /// Creates a `BagRecorderAlreadyRunning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagRecorderAlreadyRunning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagRecorderAlreadyRunning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagRecorderAlreadyRunning"; }

  /// The full name of the message: `horus.pb.logs.BagRecorderAlreadyRunning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  BagRecorderAlreadyRunning& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  BagRecorderAlreadyRunning&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #26.
/// 
///  > Could not connect to license server: $details.
///
/// Source: horus/pb/logs/logs.proto:195:1
class LicenseServerConnectionError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseServerConnectionError`.
  LicenseServerConnectionError() noexcept = default;

  /// Move constructor.
  LicenseServerConnectionError(LicenseServerConnectionError&&) noexcept = default;
  /// Move assignment operator.
  LicenseServerConnectionError& operator=(LicenseServerConnectionError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseServerConnectionError(const LicenseServerConnectionError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseServerConnectionError& operator=(const LicenseServerConnectionError&) = delete;

  /// Default destructor.
  ~LicenseServerConnectionError() noexcept final = default;

  /// Creates a `LicenseServerConnectionError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseServerConnectionError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseServerConnectionError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseServerConnectionError"; }

  /// The full name of the message: `horus.pb.logs.LicenseServerConnectionError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  LicenseServerConnectionError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  LicenseServerConnectionError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #27.
/// 
///  > Could not read license: $details.
///
/// Source: horus/pb/logs/logs.proto:202:1
class LicenseError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseError`.
  LicenseError() noexcept = default;

  /// Move constructor.
  LicenseError(LicenseError&&) noexcept = default;
  /// Move assignment operator.
  LicenseError& operator=(LicenseError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseError(const LicenseError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseError& operator=(const LicenseError&) = delete;

  /// Default destructor.
  ~LicenseError() noexcept final = default;

  /// Creates a `LicenseError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseError"; }

  /// The full name of the message: `horus.pb.logs.LicenseError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  LicenseError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  LicenseError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #145.
/// 
///  > Found no valid license.
///
/// Source: horus/pb/logs/logs.proto:209:1
class LicenseNotFoundError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseNotFoundError`.
  LicenseNotFoundError() noexcept = default;

  /// Move constructor.
  LicenseNotFoundError(LicenseNotFoundError&&) noexcept = default;
  /// Move assignment operator.
  LicenseNotFoundError& operator=(LicenseNotFoundError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseNotFoundError(const LicenseNotFoundError&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseNotFoundError& operator=(const LicenseNotFoundError&) = delete;

  /// Default destructor.
  ~LicenseNotFoundError() noexcept final = default;

  /// Creates a `LicenseNotFoundError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseNotFoundError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseNotFoundError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseNotFoundError"; }

  /// The full name of the message: `horus.pb.logs.LicenseNotFoundError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #146.
/// 
///  > License expired on $expiration_time.
///
/// Source: horus/pb/logs/logs.proto:215:1
class LicenseExpiredError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseExpiredError`.
  LicenseExpiredError() noexcept = default;

  /// Move constructor.
  LicenseExpiredError(LicenseExpiredError&&) noexcept = default;
  /// Move assignment operator.
  LicenseExpiredError& operator=(LicenseExpiredError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseExpiredError(const LicenseExpiredError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseExpiredError& operator=(const LicenseExpiredError&) = delete;

  /// Default destructor.
  ~LicenseExpiredError() noexcept final = default;

  /// Creates a `LicenseExpiredError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseExpiredError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseExpiredError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseExpiredError"; }

  /// The full name of the message: `horus.pb.logs.LicenseExpiredError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `expiration_time` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& expiration_time() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return expiration_time_;
  }

  /// If `expiration_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp expiration_time() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(expiration_time_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_expiration_time() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return expiration_time_;
  }

  /// Returns whether `expiration_time` (no 1) is set.
  constexpr bool has_expiration_time() const noexcept { return set_fields_[0]; }

  /// Clears `expiration_time` (no 1).
  void clear_expiration_time() & noexcept {
    set_fields_[0] = false;
    expiration_time_ = {};
  }

  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseExpiredError& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) & noexcept {
    set_fields_[0] = true;
    expiration_time_ = std::move(expiration_time);
    return *this;
  }
  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseExpiredError&& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) && noexcept {
    return std::move(set_expiration_time(std::move(expiration_time)));
  }

 private:
  /// @see expiration_time()
  horus::pb::LogMetadata_Timestamp expiration_time_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #147.
/// 
///  > Project exceeds number of LiDARs allowed by license ($lidar_count > $max_lidar_count).
///
/// Source: horus/pb/logs/logs.proto:222:1
class LicenseExceededError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseExceededError`.
  LicenseExceededError() noexcept = default;

  /// Move constructor.
  LicenseExceededError(LicenseExceededError&&) noexcept = default;
  /// Move assignment operator.
  LicenseExceededError& operator=(LicenseExceededError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseExceededError(const LicenseExceededError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseExceededError& operator=(const LicenseExceededError&) = delete;

  /// Default destructor.
  ~LicenseExceededError() noexcept final = default;

  /// Creates a `LicenseExceededError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseExceededError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseExceededError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseExceededError"; }

  /// The full name of the message: `horus.pb.logs.LicenseExceededError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_count` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint32_t lidar_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_count_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_lidar_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_count_;
  }

  /// Returns whether `lidar_count` (no 1) is set.
  constexpr bool has_lidar_count() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_count` (no 1).
  void clear_lidar_count() & noexcept {
    set_fields_[0] = false;
    lidar_count_ = {};
  }

  /// Sets `lidar_count` (no 1) and returns `*this`.
  LicenseExceededError& set_lidar_count(std::uint32_t lidar_count) & noexcept {
    set_fields_[0] = true;
    lidar_count_ = lidar_count;
    return *this;
  }
  /// Sets `lidar_count` (no 1) and returns `*this`.
  LicenseExceededError&& set_lidar_count(std::uint32_t lidar_count) && noexcept {
    return std::move(set_lidar_count(lidar_count));
  }

  // Field `max_lidar_count` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint32_t max_lidar_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return max_lidar_count_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint32_t& mutable_max_lidar_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return max_lidar_count_;
  }

  /// Returns whether `max_lidar_count` (no 2) is set.
  constexpr bool has_max_lidar_count() const noexcept { return set_fields_[1]; }

  /// Clears `max_lidar_count` (no 2).
  void clear_max_lidar_count() & noexcept {
    set_fields_[1] = false;
    max_lidar_count_ = {};
  }

  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseExceededError& set_max_lidar_count(std::uint32_t max_lidar_count) & noexcept {
    set_fields_[1] = true;
    max_lidar_count_ = max_lidar_count;
    return *this;
  }
  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseExceededError&& set_max_lidar_count(std::uint32_t max_lidar_count) && noexcept {
    return std::move(set_max_lidar_count(max_lidar_count));
  }

 private:
  /// @see lidar_count()
  std::uint32_t lidar_count_{};
  /// @see max_lidar_count()
  std::uint32_t max_lidar_count_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #28.
/// 
///  > Could not validate license with current hardware - $details.
///
/// Source: horus/pb/logs/logs.proto:230:1
class LicenseHostMachineError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseHostMachineError`.
  LicenseHostMachineError() noexcept = default;

  /// Move constructor.
  LicenseHostMachineError(LicenseHostMachineError&&) noexcept = default;
  /// Move assignment operator.
  LicenseHostMachineError& operator=(LicenseHostMachineError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseHostMachineError(const LicenseHostMachineError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseHostMachineError& operator=(const LicenseHostMachineError&) = delete;

  /// Default destructor.
  ~LicenseHostMachineError() noexcept final = default;

  /// Creates a `LicenseHostMachineError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseHostMachineError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseHostMachineError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseHostMachineError"; }

  /// The full name of the message: `horus.pb.logs.LicenseHostMachineError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  LicenseHostMachineError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  LicenseHostMachineError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #148.
/// 
///  > Endpoint requires "$missing_privilege" privilege: $level_error.
///
/// Source: horus/pb/logs/logs.proto:237:1
class LicensePrivilegeError final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicensePrivilegeError`.
  LicensePrivilegeError() noexcept = default;

  /// Move constructor.
  LicensePrivilegeError(LicensePrivilegeError&&) noexcept = default;
  /// Move assignment operator.
  LicensePrivilegeError& operator=(LicensePrivilegeError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicensePrivilegeError(const LicensePrivilegeError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicensePrivilegeError& operator=(const LicensePrivilegeError&) = delete;

  /// Default destructor.
  ~LicensePrivilegeError() noexcept final = default;

  /// Creates a `LicensePrivilegeError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicensePrivilegeError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicensePrivilegeError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicensePrivilegeError"; }

  /// The full name of the message: `horus.pb.logs.LicensePrivilegeError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `missing_privilege` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& missing_privilege() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return missing_privilege_;
  }

  /// If `missing_privilege` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes missing_privilege() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(missing_privilege_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_missing_privilege() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return missing_privilege_;
  }

  /// Returns whether `missing_privilege` (no 1) is set.
  constexpr bool has_missing_privilege() const noexcept { return set_fields_[0]; }

  /// Clears `missing_privilege` (no 1).
  void clear_missing_privilege() & noexcept {
    set_fields_[0] = false;
    missing_privilege_ = {};
  }

  /// Sets `missing_privilege` (no 1) and returns `*this`.
  LicensePrivilegeError& set_missing_privilege(CowBytes&& missing_privilege) & noexcept {
    set_fields_[0] = true;
    missing_privilege_ = std::move(missing_privilege);
    return *this;
  }
  /// Sets `missing_privilege` (no 1) and returns `*this`.
  LicensePrivilegeError&& set_missing_privilege(CowBytes&& missing_privilege) && noexcept {
    return std::move(set_missing_privilege(std::move(missing_privilege)));
  }

  // Field `level_error` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& level_error() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return level_error_;
  }

  /// If `level_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes level_error() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(level_error_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_level_error() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return level_error_;
  }

  /// Returns whether `level_error` (no 2) is set.
  constexpr bool has_level_error() const noexcept { return set_fields_[1]; }

  /// Clears `level_error` (no 2).
  void clear_level_error() & noexcept {
    set_fields_[1] = false;
    level_error_ = {};
  }

  /// Sets `level_error` (no 2) and returns `*this`.
  LicensePrivilegeError& set_level_error(CowBytes&& level_error) & noexcept {
    set_fields_[1] = true;
    level_error_ = std::move(level_error);
    return *this;
  }
  /// Sets `level_error` (no 2) and returns `*this`.
  LicensePrivilegeError&& set_level_error(CowBytes&& level_error) && noexcept {
    return std::move(set_level_error(std::move(level_error)));
  }

 private:
  /// @see missing_privilege()
  CowBytes missing_privilege_{};
  /// @see level_error()
  CowBytes level_error_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #149.
/// 
///  > License is active.
///
/// Source: horus/pb/logs/logs.proto:245:1
class LicenseActiveInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseActiveInfo`.
  LicenseActiveInfo() noexcept = default;

  /// Move constructor.
  LicenseActiveInfo(LicenseActiveInfo&&) noexcept = default;
  /// Move assignment operator.
  LicenseActiveInfo& operator=(LicenseActiveInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseActiveInfo(const LicenseActiveInfo&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseActiveInfo& operator=(const LicenseActiveInfo&) = delete;

  /// Default destructor.
  ~LicenseActiveInfo() noexcept final = default;

  /// Creates a `LicenseActiveInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseActiveInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseActiveInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseActiveInfo"; }

  /// The full name of the message: `horus.pb.logs.LicenseActiveInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #150.
/// 
///  > Found $non_expired_licenses_count non-expired concurrent licenses. Only "$active_license_filename" is used.
///
/// Source: horus/pb/logs/logs.proto:251:1
class MultipleLicensesWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `MultipleLicensesWarning`.
  MultipleLicensesWarning() noexcept = default;

  /// Move constructor.
  MultipleLicensesWarning(MultipleLicensesWarning&&) noexcept = default;
  /// Move assignment operator.
  MultipleLicensesWarning& operator=(MultipleLicensesWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit MultipleLicensesWarning(const MultipleLicensesWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  MultipleLicensesWarning& operator=(const MultipleLicensesWarning&) = delete;

  /// Default destructor.
  ~MultipleLicensesWarning() noexcept final = default;

  /// Creates a `MultipleLicensesWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit MultipleLicensesWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.MultipleLicensesWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.MultipleLicensesWarning"; }

  /// The full name of the message: `horus.pb.logs.MultipleLicensesWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `non_expired_licenses_count` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint32_t non_expired_licenses_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return non_expired_licenses_count_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_non_expired_licenses_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return non_expired_licenses_count_;
  }

  /// Returns whether `non_expired_licenses_count` (no 1) is set.
  constexpr bool has_non_expired_licenses_count() const noexcept { return set_fields_[0]; }

  /// Clears `non_expired_licenses_count` (no 1).
  void clear_non_expired_licenses_count() & noexcept {
    set_fields_[0] = false;
    non_expired_licenses_count_ = {};
  }

  /// Sets `non_expired_licenses_count` (no 1) and returns `*this`.
  MultipleLicensesWarning& set_non_expired_licenses_count(std::uint32_t non_expired_licenses_count) & noexcept {
    set_fields_[0] = true;
    non_expired_licenses_count_ = non_expired_licenses_count;
    return *this;
  }
  /// Sets `non_expired_licenses_count` (no 1) and returns `*this`.
  MultipleLicensesWarning&& set_non_expired_licenses_count(std::uint32_t non_expired_licenses_count) && noexcept {
    return std::move(set_non_expired_licenses_count(non_expired_licenses_count));
  }

  // Field `active_license_filename` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& active_license_filename() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return active_license_filename_;
  }

  /// If `active_license_filename` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes active_license_filename() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(active_license_filename_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_active_license_filename() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return active_license_filename_;
  }

  /// Returns whether `active_license_filename` (no 2) is set.
  constexpr bool has_active_license_filename() const noexcept { return set_fields_[1]; }

  /// Clears `active_license_filename` (no 2).
  void clear_active_license_filename() & noexcept {
    set_fields_[1] = false;
    active_license_filename_ = {};
  }

  /// Sets `active_license_filename` (no 2) and returns `*this`.
  MultipleLicensesWarning& set_active_license_filename(CowBytes&& active_license_filename) & noexcept {
    set_fields_[1] = true;
    active_license_filename_ = std::move(active_license_filename);
    return *this;
  }
  /// Sets `active_license_filename` (no 2) and returns `*this`.
  MultipleLicensesWarning&& set_active_license_filename(CowBytes&& active_license_filename) && noexcept {
    return std::move(set_active_license_filename(std::move(active_license_filename)));
  }

 private:
  /// @see non_expired_licenses_count()
  std::uint32_t non_expired_licenses_count_{};
  /// @see active_license_filename()
  CowBytes active_license_filename_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #29.
/// 
///  > Current license accepts up to $max_lidar_count and expires on $expiration_time.
///
/// Source: horus/pb/logs/logs.proto:259:1
class LicenseCurrentLicenseStatusInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseCurrentLicenseStatusInfo`.
  LicenseCurrentLicenseStatusInfo() noexcept = default;

  /// Move constructor.
  LicenseCurrentLicenseStatusInfo(LicenseCurrentLicenseStatusInfo&&) noexcept = default;
  /// Move assignment operator.
  LicenseCurrentLicenseStatusInfo& operator=(LicenseCurrentLicenseStatusInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseCurrentLicenseStatusInfo(const LicenseCurrentLicenseStatusInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseCurrentLicenseStatusInfo& operator=(const LicenseCurrentLicenseStatusInfo&) = delete;

  /// Default destructor.
  ~LicenseCurrentLicenseStatusInfo() noexcept final = default;

  /// Creates a `LicenseCurrentLicenseStatusInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseCurrentLicenseStatusInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseCurrentLicenseStatusInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseCurrentLicenseStatusInfo"; }

  /// The full name of the message: `horus.pb.logs.LicenseCurrentLicenseStatusInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `expiration_time` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& expiration_time() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return expiration_time_;
  }

  /// If `expiration_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp expiration_time() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(expiration_time_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_expiration_time() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return expiration_time_;
  }

  /// Returns whether `expiration_time` (no 1) is set.
  constexpr bool has_expiration_time() const noexcept { return set_fields_[0]; }

  /// Clears `expiration_time` (no 1).
  void clear_expiration_time() & noexcept {
    set_fields_[0] = false;
    expiration_time_ = {};
  }

  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseCurrentLicenseStatusInfo& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) & noexcept {
    set_fields_[0] = true;
    expiration_time_ = std::move(expiration_time);
    return *this;
  }
  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseCurrentLicenseStatusInfo&& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) && noexcept {
    return std::move(set_expiration_time(std::move(expiration_time)));
  }

  // Field `max_lidar_count` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint32_t max_lidar_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return max_lidar_count_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint32_t& mutable_max_lidar_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return max_lidar_count_;
  }

  /// Returns whether `max_lidar_count` (no 2) is set.
  constexpr bool has_max_lidar_count() const noexcept { return set_fields_[1]; }

  /// Clears `max_lidar_count` (no 2).
  void clear_max_lidar_count() & noexcept {
    set_fields_[1] = false;
    max_lidar_count_ = {};
  }

  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseCurrentLicenseStatusInfo& set_max_lidar_count(std::uint32_t max_lidar_count) & noexcept {
    set_fields_[1] = true;
    max_lidar_count_ = max_lidar_count;
    return *this;
  }
  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseCurrentLicenseStatusInfo&& set_max_lidar_count(std::uint32_t max_lidar_count) && noexcept {
    return std::move(set_max_lidar_count(max_lidar_count));
  }

 private:
  /// @see expiration_time()
  horus::pb::LogMetadata_Timestamp expiration_time_{};
  /// @see max_lidar_count()
  std::uint32_t max_lidar_count_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #30.
/// 
///  > Bag recording stopped for $path: $details
///
/// Source: horus/pb/logs/logs.proto:267:1
class BagRecordingStoppedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagRecordingStoppedInfo`.
  BagRecordingStoppedInfo() noexcept = default;

  /// Move constructor.
  BagRecordingStoppedInfo(BagRecordingStoppedInfo&&) noexcept = default;
  /// Move assignment operator.
  BagRecordingStoppedInfo& operator=(BagRecordingStoppedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagRecordingStoppedInfo(const BagRecordingStoppedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagRecordingStoppedInfo& operator=(const BagRecordingStoppedInfo&) = delete;

  /// Default destructor.
  ~BagRecordingStoppedInfo() noexcept final = default;

  /// Creates a `BagRecordingStoppedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagRecordingStoppedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagRecordingStoppedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagRecordingStoppedInfo"; }

  /// The full name of the message: `horus.pb.logs.BagRecordingStoppedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  BagRecordingStoppedInfo& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  BagRecordingStoppedInfo&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  BagRecordingStoppedInfo& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  BagRecordingStoppedInfo&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see path()
  CowBytes path_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #31.
/// 
///  > Bag recording failed to start: $details
///
/// Source: horus/pb/logs/logs.proto:275:1
class BagRecordingFailedToStart final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagRecordingFailedToStart`.
  BagRecordingFailedToStart() noexcept = default;

  /// Move constructor.
  BagRecordingFailedToStart(BagRecordingFailedToStart&&) noexcept = default;
  /// Move assignment operator.
  BagRecordingFailedToStart& operator=(BagRecordingFailedToStart&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagRecordingFailedToStart(const BagRecordingFailedToStart& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagRecordingFailedToStart& operator=(const BagRecordingFailedToStart&) = delete;

  /// Default destructor.
  ~BagRecordingFailedToStart() noexcept final = default;

  /// Creates a `BagRecordingFailedToStart` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagRecordingFailedToStart(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagRecordingFailedToStart`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagRecordingFailedToStart"; }

  /// The full name of the message: `horus.pb.logs.BagRecordingFailedToStart`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  BagRecordingFailedToStart& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  BagRecordingFailedToStart&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #32.
/// 
///  > Bag recording started for $path
///
/// Source: horus/pb/logs/logs.proto:282:1
class BagRecordingStartedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagRecordingStartedInfo`.
  BagRecordingStartedInfo() noexcept = default;

  /// Move constructor.
  BagRecordingStartedInfo(BagRecordingStartedInfo&&) noexcept = default;
  /// Move assignment operator.
  BagRecordingStartedInfo& operator=(BagRecordingStartedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagRecordingStartedInfo(const BagRecordingStartedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagRecordingStartedInfo& operator=(const BagRecordingStartedInfo&) = delete;

  /// Default destructor.
  ~BagRecordingStartedInfo() noexcept final = default;

  /// Creates a `BagRecordingStartedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagRecordingStartedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagRecordingStartedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagRecordingStartedInfo"; }

  /// The full name of the message: `horus.pb.logs.BagRecordingStartedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  BagRecordingStartedInfo& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  BagRecordingStartedInfo&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #33.
/// 
///  > Replay Restarted
///
/// Source: horus/pb/logs/logs.proto:289:1
class ReplayRestartedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ReplayRestartedInfo`.
  ReplayRestartedInfo() noexcept = default;

  /// Move constructor.
  ReplayRestartedInfo(ReplayRestartedInfo&&) noexcept = default;
  /// Move assignment operator.
  ReplayRestartedInfo& operator=(ReplayRestartedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ReplayRestartedInfo(const ReplayRestartedInfo&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ReplayRestartedInfo& operator=(const ReplayRestartedInfo&) = delete;

  /// Default destructor.
  ~ReplayRestartedInfo() noexcept final = default;

  /// Creates a `ReplayRestartedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ReplayRestartedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ReplayRestartedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ReplayRestartedInfo"; }

  /// The full name of the message: `horus.pb.logs.ReplayRestartedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #34.
/// 
///  > Input source $source requested
///
/// Source: horus/pb/logs/logs.proto:295:1
class InputSourceChangeRequestedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `InputSourceChangeRequestedInfo`.
  InputSourceChangeRequestedInfo() noexcept = default;

  /// Move constructor.
  InputSourceChangeRequestedInfo(InputSourceChangeRequestedInfo&&) noexcept = default;
  /// Move assignment operator.
  InputSourceChangeRequestedInfo& operator=(InputSourceChangeRequestedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InputSourceChangeRequestedInfo(const InputSourceChangeRequestedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InputSourceChangeRequestedInfo& operator=(const InputSourceChangeRequestedInfo&) = delete;

  /// Default destructor.
  ~InputSourceChangeRequestedInfo() noexcept final = default;

  /// Creates a `InputSourceChangeRequestedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InputSourceChangeRequestedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InputSourceChangeRequestedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InputSourceChangeRequestedInfo"; }

  /// The full name of the message: `horus.pb.logs.InputSourceChangeRequestedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `source` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& source() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return source_;
  }

  /// If `source` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes source() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(source_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_source() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return source_;
  }

  /// Returns whether `source` (no 1) is set.
  constexpr bool has_source() const noexcept { return set_fields_[0]; }

  /// Clears `source` (no 1).
  void clear_source() & noexcept {
    set_fields_[0] = false;
    source_ = {};
  }

  /// Sets `source` (no 1) and returns `*this`.
  InputSourceChangeRequestedInfo& set_source(CowBytes&& source) & noexcept {
    set_fields_[0] = true;
    source_ = std::move(source);
    return *this;
  }
  /// Sets `source` (no 1) and returns `*this`.
  InputSourceChangeRequestedInfo&& set_source(CowBytes&& source) && noexcept {
    return std::move(set_source(std::move(source)));
  }

 private:
  /// @see source()
  CowBytes source_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #35.
/// 
///  > Input source changed to $source
///
/// Source: horus/pb/logs/logs.proto:302:1
class InputSourceSwitchedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `InputSourceSwitchedInfo`.
  InputSourceSwitchedInfo() noexcept = default;

  /// Move constructor.
  InputSourceSwitchedInfo(InputSourceSwitchedInfo&&) noexcept = default;
  /// Move assignment operator.
  InputSourceSwitchedInfo& operator=(InputSourceSwitchedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InputSourceSwitchedInfo(const InputSourceSwitchedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InputSourceSwitchedInfo& operator=(const InputSourceSwitchedInfo&) = delete;

  /// Default destructor.
  ~InputSourceSwitchedInfo() noexcept final = default;

  /// Creates a `InputSourceSwitchedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InputSourceSwitchedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InputSourceSwitchedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InputSourceSwitchedInfo"; }

  /// The full name of the message: `horus.pb.logs.InputSourceSwitchedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `source` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& source() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return source_;
  }

  /// If `source` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes source() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(source_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_source() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return source_;
  }

  /// Returns whether `source` (no 1) is set.
  constexpr bool has_source() const noexcept { return set_fields_[0]; }

  /// Clears `source` (no 1).
  void clear_source() & noexcept {
    set_fields_[0] = false;
    source_ = {};
  }

  /// Sets `source` (no 1) and returns `*this`.
  InputSourceSwitchedInfo& set_source(CowBytes&& source) & noexcept {
    set_fields_[0] = true;
    source_ = std::move(source);
    return *this;
  }
  /// Sets `source` (no 1) and returns `*this`.
  InputSourceSwitchedInfo&& set_source(CowBytes&& source) && noexcept {
    return std::move(set_source(std::move(source)));
  }

 private:
  /// @see source()
  CowBytes source_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #36.
/// 
///  > RPC request $request_name to $endpoint timed out after $elapsed.
///
/// Source: horus/pb/logs/logs.proto:309:1
class RpcTimeoutWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcTimeoutWarning`.
  RpcTimeoutWarning() noexcept = default;

  /// Move constructor.
  RpcTimeoutWarning(RpcTimeoutWarning&&) noexcept = default;
  /// Move assignment operator.
  RpcTimeoutWarning& operator=(RpcTimeoutWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcTimeoutWarning(const RpcTimeoutWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcTimeoutWarning& operator=(const RpcTimeoutWarning&) = delete;

  /// Default destructor.
  ~RpcTimeoutWarning() noexcept final = default;

  /// Creates a `RpcTimeoutWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcTimeoutWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcTimeoutWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcTimeoutWarning"; }

  /// The full name of the message: `horus.pb.logs.RpcTimeoutWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `request_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& request_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return request_name_;
  }

  /// If `request_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes request_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(request_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_request_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return request_name_;
  }

  /// Returns whether `request_name` (no 1) is set.
  constexpr bool has_request_name() const noexcept { return set_fields_[0]; }

  /// Clears `request_name` (no 1).
  void clear_request_name() & noexcept {
    set_fields_[0] = false;
    request_name_ = {};
  }

  /// Sets `request_name` (no 1) and returns `*this`.
  RpcTimeoutWarning& set_request_name(CowBytes&& request_name) & noexcept {
    set_fields_[0] = true;
    request_name_ = std::move(request_name);
    return *this;
  }
  /// Sets `request_name` (no 1) and returns `*this`.
  RpcTimeoutWarning&& set_request_name(CowBytes&& request_name) && noexcept {
    return std::move(set_request_name(std::move(request_name)));
  }

  // Field `endpoint` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& endpoint() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return endpoint_;
  }

  /// If `endpoint` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes endpoint() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(endpoint_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_endpoint() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return endpoint_;
  }

  /// Returns whether `endpoint` (no 2) is set.
  constexpr bool has_endpoint() const noexcept { return set_fields_[1]; }

  /// Clears `endpoint` (no 2).
  void clear_endpoint() & noexcept {
    set_fields_[1] = false;
    endpoint_ = {};
  }

  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcTimeoutWarning& set_endpoint(CowBytes&& endpoint) & noexcept {
    set_fields_[1] = true;
    endpoint_ = std::move(endpoint);
    return *this;
  }
  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcTimeoutWarning&& set_endpoint(CowBytes&& endpoint) && noexcept {
    return std::move(set_endpoint(std::move(endpoint)));
  }

  // Field `elapsed` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const horus::pb::LogMetadata_Duration& elapsed() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return elapsed_;
  }

  /// If `elapsed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration elapsed() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(elapsed_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration& mutable_elapsed() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return elapsed_;
  }

  /// Returns whether `elapsed` (no 3) is set.
  constexpr bool has_elapsed() const noexcept { return set_fields_[2]; }

  /// Clears `elapsed` (no 3).
  void clear_elapsed() & noexcept {
    set_fields_[2] = false;
    elapsed_ = {};
  }

  /// Sets `elapsed` (no 3) and returns `*this`.
  RpcTimeoutWarning& set_elapsed(horus::pb::LogMetadata_Duration&& elapsed) & noexcept {
    set_fields_[2] = true;
    elapsed_ = std::move(elapsed);
    return *this;
  }
  /// Sets `elapsed` (no 3) and returns `*this`.
  RpcTimeoutWarning&& set_elapsed(horus::pb::LogMetadata_Duration&& elapsed) && noexcept {
    return std::move(set_elapsed(std::move(elapsed)));
  }

 private:
  /// @see request_name()
  CowBytes request_name_{};
  /// @see endpoint()
  CowBytes endpoint_{};
  /// @see elapsed()
  horus::pb::LogMetadata_Duration elapsed_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #37.
/// 
///  > Notification service cannot write log in $path: $details
///
/// Source: horus/pb/logs/logs.proto:318:1
class CannotWriteLogFile final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotWriteLogFile`.
  CannotWriteLogFile() noexcept = default;

  /// Move constructor.
  CannotWriteLogFile(CannotWriteLogFile&&) noexcept = default;
  /// Move assignment operator.
  CannotWriteLogFile& operator=(CannotWriteLogFile&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotWriteLogFile(const CannotWriteLogFile& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotWriteLogFile& operator=(const CannotWriteLogFile&) = delete;

  /// Default destructor.
  ~CannotWriteLogFile() noexcept final = default;

  /// Creates a `CannotWriteLogFile` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotWriteLogFile(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotWriteLogFile`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotWriteLogFile"; }

  /// The full name of the message: `horus.pb.logs.CannotWriteLogFile`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  CannotWriteLogFile& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  CannotWriteLogFile&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  CannotWriteLogFile& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  CannotWriteLogFile&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see path()
  CowBytes path_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #38.
/// 
///  > Point cloud parsing failed: $details
///
/// Source: horus/pb/logs/logs.proto:326:1
class PointCloudParsingFailureWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `PointCloudParsingFailureWarning`.
  PointCloudParsingFailureWarning() noexcept = default;

  /// Move constructor.
  PointCloudParsingFailureWarning(PointCloudParsingFailureWarning&&) noexcept = default;
  /// Move assignment operator.
  PointCloudParsingFailureWarning& operator=(PointCloudParsingFailureWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit PointCloudParsingFailureWarning(const PointCloudParsingFailureWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  PointCloudParsingFailureWarning& operator=(const PointCloudParsingFailureWarning&) = delete;

  /// Default destructor.
  ~PointCloudParsingFailureWarning() noexcept final = default;

  /// Creates a `PointCloudParsingFailureWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit PointCloudParsingFailureWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.PointCloudParsingFailureWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.PointCloudParsingFailureWarning"; }

  /// The full name of the message: `horus.pb.logs.PointCloudParsingFailureWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  PointCloudParsingFailureWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  PointCloudParsingFailureWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #39.
/// 
///  > The lidar $lidar_id is considered dead. No data has been received for a while.
///
/// Source: horus/pb/logs/logs.proto:333:1
class LidarIsDead final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsDead`.
  LidarIsDead() noexcept = default;

  /// Move constructor.
  LidarIsDead(LidarIsDead&&) noexcept = default;
  /// Move assignment operator.
  LidarIsDead& operator=(LidarIsDead&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsDead(const LidarIsDead& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsDead& operator=(const LidarIsDead&) = delete;

  /// Default destructor.
  ~LidarIsDead() noexcept final = default;

  /// Creates a `LidarIsDead` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsDead(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsDead`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsDead"; }

  /// The full name of the message: `horus.pb.logs.LidarIsDead`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsDead& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsDead&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #40.
/// 
///  > The lidar $lidar_id is not considered dead anymore. A point cloud has been received again after some time.
///
/// Source: horus/pb/logs/logs.proto:340:1
class LidarIsNotDeadAnymore final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsNotDeadAnymore`.
  LidarIsNotDeadAnymore() noexcept = default;

  /// Move constructor.
  LidarIsNotDeadAnymore(LidarIsNotDeadAnymore&&) noexcept = default;
  /// Move assignment operator.
  LidarIsNotDeadAnymore& operator=(LidarIsNotDeadAnymore&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsNotDeadAnymore(const LidarIsNotDeadAnymore& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsNotDeadAnymore& operator=(const LidarIsNotDeadAnymore&) = delete;

  /// Default destructor.
  ~LidarIsNotDeadAnymore() noexcept final = default;

  /// Creates a `LidarIsNotDeadAnymore` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsNotDeadAnymore(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsNotDeadAnymore`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsNotDeadAnymore"; }

  /// The full name of the message: `horus.pb.logs.LidarIsNotDeadAnymore`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotDeadAnymore& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotDeadAnymore&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #41.
/// 
///  > The lidar $lidar_id is obstructed.
///
/// Source: horus/pb/logs/logs.proto:347:1
class LidarIsObstructed final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsObstructed`.
  LidarIsObstructed() noexcept = default;

  /// Move constructor.
  LidarIsObstructed(LidarIsObstructed&&) noexcept = default;
  /// Move assignment operator.
  LidarIsObstructed& operator=(LidarIsObstructed&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsObstructed(const LidarIsObstructed& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsObstructed& operator=(const LidarIsObstructed&) = delete;

  /// Default destructor.
  ~LidarIsObstructed() noexcept final = default;

  /// Creates a `LidarIsObstructed` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsObstructed(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsObstructed`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsObstructed"; }

  /// The full name of the message: `horus.pb.logs.LidarIsObstructed`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsObstructed& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsObstructed&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #42.
/// 
///  > The lidar $lidar_id is not obstructed anymore.
///
/// Source: horus/pb/logs/logs.proto:354:1
class LidarIsNotObstructedAnymore final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsNotObstructedAnymore`.
  LidarIsNotObstructedAnymore() noexcept = default;

  /// Move constructor.
  LidarIsNotObstructedAnymore(LidarIsNotObstructedAnymore&&) noexcept = default;
  /// Move assignment operator.
  LidarIsNotObstructedAnymore& operator=(LidarIsNotObstructedAnymore&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsNotObstructedAnymore(const LidarIsNotObstructedAnymore& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsNotObstructedAnymore& operator=(const LidarIsNotObstructedAnymore&) = delete;

  /// Default destructor.
  ~LidarIsNotObstructedAnymore() noexcept final = default;

  /// Creates a `LidarIsNotObstructedAnymore` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsNotObstructedAnymore(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsNotObstructedAnymore`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsNotObstructedAnymore"; }

  /// The full name of the message: `horus.pb.logs.LidarIsNotObstructedAnymore`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotObstructedAnymore& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotObstructedAnymore&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #43.
/// 
///  > The lidar $lidar_id is tilted.
///
/// Source: horus/pb/logs/logs.proto:361:1
class LidarIsTilted final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsTilted`.
  LidarIsTilted() noexcept = default;

  /// Move constructor.
  LidarIsTilted(LidarIsTilted&&) noexcept = default;
  /// Move assignment operator.
  LidarIsTilted& operator=(LidarIsTilted&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsTilted(const LidarIsTilted& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsTilted& operator=(const LidarIsTilted&) = delete;

  /// Default destructor.
  ~LidarIsTilted() noexcept final = default;

  /// Creates a `LidarIsTilted` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsTilted(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsTilted`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsTilted"; }

  /// The full name of the message: `horus.pb.logs.LidarIsTilted`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsTilted& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsTilted&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #44.
/// 
///  > The lidar $lidar_id is not tilted anymore.
///
/// Source: horus/pb/logs/logs.proto:368:1
class LidarIsNotTiltedAnymore final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIsNotTiltedAnymore`.
  LidarIsNotTiltedAnymore() noexcept = default;

  /// Move constructor.
  LidarIsNotTiltedAnymore(LidarIsNotTiltedAnymore&&) noexcept = default;
  /// Move assignment operator.
  LidarIsNotTiltedAnymore& operator=(LidarIsNotTiltedAnymore&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIsNotTiltedAnymore(const LidarIsNotTiltedAnymore& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIsNotTiltedAnymore& operator=(const LidarIsNotTiltedAnymore&) = delete;

  /// Default destructor.
  ~LidarIsNotTiltedAnymore() noexcept final = default;

  /// Creates a `LidarIsNotTiltedAnymore` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIsNotTiltedAnymore(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIsNotTiltedAnymore`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIsNotTiltedAnymore"; }

  /// The full name of the message: `horus.pb.logs.LidarIsNotTiltedAnymore`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotTiltedAnymore& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarIsNotTiltedAnymore&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #45.
/// 
///  > The lidar $lidar_id has been automatically re-calibrated.
///
/// Source: horus/pb/logs/logs.proto:375:1
class LidarHasBeenAutomaticallyRecalibrated final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarHasBeenAutomaticallyRecalibrated`.
  LidarHasBeenAutomaticallyRecalibrated() noexcept = default;

  /// Move constructor.
  LidarHasBeenAutomaticallyRecalibrated(LidarHasBeenAutomaticallyRecalibrated&&) noexcept = default;
  /// Move assignment operator.
  LidarHasBeenAutomaticallyRecalibrated& operator=(LidarHasBeenAutomaticallyRecalibrated&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarHasBeenAutomaticallyRecalibrated(const LidarHasBeenAutomaticallyRecalibrated& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarHasBeenAutomaticallyRecalibrated& operator=(const LidarHasBeenAutomaticallyRecalibrated&) = delete;

  /// Default destructor.
  ~LidarHasBeenAutomaticallyRecalibrated() noexcept final = default;

  /// Creates a `LidarHasBeenAutomaticallyRecalibrated` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarHasBeenAutomaticallyRecalibrated(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarHasBeenAutomaticallyRecalibrated`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarHasBeenAutomaticallyRecalibrated"; }

  /// The full name of the message: `horus.pb.logs.LidarHasBeenAutomaticallyRecalibrated`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarHasBeenAutomaticallyRecalibrated& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  LidarHasBeenAutomaticallyRecalibrated&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #46.
/// 
///  > Data has been received for the first time for the lidar $lidar_id.
///
/// Source: horus/pb/logs/logs.proto:382:1
class ReceivedFirstDataForLidar final : public PbMessage {
 public:

  /// Constructs a default-initialized `ReceivedFirstDataForLidar`.
  ReceivedFirstDataForLidar() noexcept = default;

  /// Move constructor.
  ReceivedFirstDataForLidar(ReceivedFirstDataForLidar&&) noexcept = default;
  /// Move assignment operator.
  ReceivedFirstDataForLidar& operator=(ReceivedFirstDataForLidar&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ReceivedFirstDataForLidar(const ReceivedFirstDataForLidar& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ReceivedFirstDataForLidar& operator=(const ReceivedFirstDataForLidar&) = delete;

  /// Default destructor.
  ~ReceivedFirstDataForLidar() noexcept final = default;

  /// Creates a `ReceivedFirstDataForLidar` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ReceivedFirstDataForLidar(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ReceivedFirstDataForLidar`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ReceivedFirstDataForLidar"; }

  /// The full name of the message: `horus.pb.logs.ReceivedFirstDataForLidar`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  ReceivedFirstDataForLidar& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  ReceivedFirstDataForLidar&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #47.
/// 
///  > Failed to destruct $component: $details
///
/// Source: horus/pb/logs/logs.proto:389:1
class TerminationFailureError final : public PbMessage {
 public:

  /// Constructs a default-initialized `TerminationFailureError`.
  TerminationFailureError() noexcept = default;

  /// Move constructor.
  TerminationFailureError(TerminationFailureError&&) noexcept = default;
  /// Move assignment operator.
  TerminationFailureError& operator=(TerminationFailureError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit TerminationFailureError(const TerminationFailureError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  TerminationFailureError& operator=(const TerminationFailureError&) = delete;

  /// Default destructor.
  ~TerminationFailureError() noexcept final = default;

  /// Creates a `TerminationFailureError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit TerminationFailureError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.TerminationFailureError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.TerminationFailureError"; }

  /// The full name of the message: `horus.pb.logs.TerminationFailureError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  TerminationFailureError& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  TerminationFailureError&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  TerminationFailureError& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  TerminationFailureError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see component()
  CowBytes component_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #48.
/// 
///  > The Frame Task Scheduler failed to process frame task: $details
///
/// Source: horus/pb/logs/logs.proto:397:1
class FrameProcessingError final : public PbMessage {
 public:

  /// Constructs a default-initialized `FrameProcessingError`.
  FrameProcessingError() noexcept = default;

  /// Move constructor.
  FrameProcessingError(FrameProcessingError&&) noexcept = default;
  /// Move assignment operator.
  FrameProcessingError& operator=(FrameProcessingError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FrameProcessingError(const FrameProcessingError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FrameProcessingError& operator=(const FrameProcessingError&) = delete;

  /// Default destructor.
  ~FrameProcessingError() noexcept final = default;

  /// Creates a `FrameProcessingError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FrameProcessingError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FrameProcessingError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FrameProcessingError"; }

  /// The full name of the message: `horus.pb.logs.FrameProcessingError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  FrameProcessingError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  FrameProcessingError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #49.
/// 
///  > Thread pool is not available: $consequence
///
/// Source: horus/pb/logs/logs.proto:404:1
class ThreadPoolUnavailableError final : public PbMessage {
 public:

  /// Constructs a default-initialized `ThreadPoolUnavailableError`.
  ThreadPoolUnavailableError() noexcept = default;

  /// Move constructor.
  ThreadPoolUnavailableError(ThreadPoolUnavailableError&&) noexcept = default;
  /// Move assignment operator.
  ThreadPoolUnavailableError& operator=(ThreadPoolUnavailableError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ThreadPoolUnavailableError(const ThreadPoolUnavailableError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ThreadPoolUnavailableError& operator=(const ThreadPoolUnavailableError&) = delete;

  /// Default destructor.
  ~ThreadPoolUnavailableError() noexcept final = default;

  /// Creates a `ThreadPoolUnavailableError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ThreadPoolUnavailableError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ThreadPoolUnavailableError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ThreadPoolUnavailableError"; }

  /// The full name of the message: `horus.pb.logs.ThreadPoolUnavailableError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `consequence` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& consequence() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return consequence_;
  }

  /// If `consequence` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes consequence() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(consequence_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_consequence() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return consequence_;
  }

  /// Returns whether `consequence` (no 1) is set.
  constexpr bool has_consequence() const noexcept { return set_fields_[0]; }

  /// Clears `consequence` (no 1).
  void clear_consequence() & noexcept {
    set_fields_[0] = false;
    consequence_ = {};
  }

  /// Sets `consequence` (no 1) and returns `*this`.
  ThreadPoolUnavailableError& set_consequence(CowBytes&& consequence) & noexcept {
    set_fields_[0] = true;
    consequence_ = std::move(consequence);
    return *this;
  }
  /// Sets `consequence` (no 1) and returns `*this`.
  ThreadPoolUnavailableError&& set_consequence(CowBytes&& consequence) && noexcept {
    return std::move(set_consequence(std::move(consequence)));
  }

 private:
  /// @see consequence()
  CowBytes consequence_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #50.
/// 
///  > Invalid argument: $details
///
/// Source: horus/pb/logs/logs.proto:411:1
class InvalidArgument final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidArgument`.
  InvalidArgument() noexcept = default;

  /// Move constructor.
  InvalidArgument(InvalidArgument&&) noexcept = default;
  /// Move assignment operator.
  InvalidArgument& operator=(InvalidArgument&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidArgument(const InvalidArgument& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidArgument& operator=(const InvalidArgument&) = delete;

  /// Default destructor.
  ~InvalidArgument() noexcept final = default;

  /// Creates a `InvalidArgument` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidArgument(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidArgument`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidArgument"; }

  /// The full name of the message: `horus.pb.logs.InvalidArgument`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  InvalidArgument& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  InvalidArgument&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #51.
/// 
///  > Failed to initialize $component: $details
///
/// Source: horus/pb/logs/logs.proto:418:1
class ComponentInitializationFailureFatal final : public PbMessage {
 public:

  /// Constructs a default-initialized `ComponentInitializationFailureFatal`.
  ComponentInitializationFailureFatal() noexcept = default;

  /// Move constructor.
  ComponentInitializationFailureFatal(ComponentInitializationFailureFatal&&) noexcept = default;
  /// Move assignment operator.
  ComponentInitializationFailureFatal& operator=(ComponentInitializationFailureFatal&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ComponentInitializationFailureFatal(const ComponentInitializationFailureFatal& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ComponentInitializationFailureFatal& operator=(const ComponentInitializationFailureFatal&) = delete;

  /// Default destructor.
  ~ComponentInitializationFailureFatal() noexcept final = default;

  /// Creates a `ComponentInitializationFailureFatal` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ComponentInitializationFailureFatal(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ComponentInitializationFailureFatal`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ComponentInitializationFailureFatal"; }

  /// The full name of the message: `horus.pb.logs.ComponentInitializationFailureFatal`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  ComponentInitializationFailureFatal& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  ComponentInitializationFailureFatal&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  ComponentInitializationFailureFatal& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  ComponentInitializationFailureFatal&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see component()
  CowBytes component_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #52.
/// 
///  > Unhandled enum case $case_name at $location
///
/// Source: horus/pb/logs/logs.proto:426:1
class UnhandledEnumCaseError final : public PbMessage {
 public:

  /// Constructs a default-initialized `UnhandledEnumCaseError`.
  UnhandledEnumCaseError() noexcept = default;

  /// Move constructor.
  UnhandledEnumCaseError(UnhandledEnumCaseError&&) noexcept = default;
  /// Move assignment operator.
  UnhandledEnumCaseError& operator=(UnhandledEnumCaseError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit UnhandledEnumCaseError(const UnhandledEnumCaseError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  UnhandledEnumCaseError& operator=(const UnhandledEnumCaseError&) = delete;

  /// Default destructor.
  ~UnhandledEnumCaseError() noexcept final = default;

  /// Creates a `UnhandledEnumCaseError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit UnhandledEnumCaseError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.UnhandledEnumCaseError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.UnhandledEnumCaseError"; }

  /// The full name of the message: `horus.pb.logs.UnhandledEnumCaseError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `case_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& case_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return case_name_;
  }

  /// If `case_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes case_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(case_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_case_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return case_name_;
  }

  /// Returns whether `case_name` (no 1) is set.
  constexpr bool has_case_name() const noexcept { return set_fields_[0]; }

  /// Clears `case_name` (no 1).
  void clear_case_name() & noexcept {
    set_fields_[0] = false;
    case_name_ = {};
  }

  /// Sets `case_name` (no 1) and returns `*this`.
  UnhandledEnumCaseError& set_case_name(CowBytes&& case_name) & noexcept {
    set_fields_[0] = true;
    case_name_ = std::move(case_name);
    return *this;
  }
  /// Sets `case_name` (no 1) and returns `*this`.
  UnhandledEnumCaseError&& set_case_name(CowBytes&& case_name) && noexcept {
    return std::move(set_case_name(std::move(case_name)));
  }

  // Field `location` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_SourceLocation& location() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return location_;
  }

  /// If `location` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation location() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(location_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation& mutable_location() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return location_;
  }

  /// Returns whether `location` (no 2) is set.
  constexpr bool has_location() const noexcept { return set_fields_[1]; }

  /// Clears `location` (no 2).
  void clear_location() & noexcept {
    set_fields_[1] = false;
    location_ = {};
  }

  /// Sets `location` (no 2) and returns `*this`.
  UnhandledEnumCaseError& set_location(horus::pb::LogMetadata_SourceLocation&& location) & noexcept {
    set_fields_[1] = true;
    location_ = std::move(location);
    return *this;
  }
  /// Sets `location` (no 2) and returns `*this`.
  UnhandledEnumCaseError&& set_location(horus::pb::LogMetadata_SourceLocation&& location) && noexcept {
    return std::move(set_location(std::move(location)));
  }

 private:
  /// @see case_name()
  CowBytes case_name_{};
  /// @see location()
  horus::pb::LogMetadata_SourceLocation location_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #53.
/// 
///  > The replay bag file is empty.
///
/// Source: horus/pb/logs/logs.proto:434:1
class BagEmptyError final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagEmptyError`.
  BagEmptyError() noexcept = default;

  /// Move constructor.
  BagEmptyError(BagEmptyError&&) noexcept = default;
  /// Move assignment operator.
  BagEmptyError& operator=(BagEmptyError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagEmptyError(const BagEmptyError&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagEmptyError& operator=(const BagEmptyError&) = delete;

  /// Default destructor.
  ~BagEmptyError() noexcept final = default;

  /// Creates a `BagEmptyError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagEmptyError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagEmptyError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagEmptyError"; }

  /// The full name of the message: `horus.pb.logs.BagEmptyError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #54.
/// 
///  > Discarding data in $component: $details
///
/// Source: horus/pb/logs/logs.proto:440:1
class DiscardingDataError final : public PbMessage {
 public:

  /// Constructs a default-initialized `DiscardingDataError`.
  DiscardingDataError() noexcept = default;

  /// Move constructor.
  DiscardingDataError(DiscardingDataError&&) noexcept = default;
  /// Move assignment operator.
  DiscardingDataError& operator=(DiscardingDataError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DiscardingDataError(const DiscardingDataError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DiscardingDataError& operator=(const DiscardingDataError&) = delete;

  /// Default destructor.
  ~DiscardingDataError() noexcept final = default;

  /// Creates a `DiscardingDataError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DiscardingDataError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.DiscardingDataError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.DiscardingDataError"; }

  /// The full name of the message: `horus.pb.logs.DiscardingDataError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  DiscardingDataError& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  DiscardingDataError&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  DiscardingDataError& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  DiscardingDataError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see component()
  CowBytes component_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #55.
/// 
///  > Discarding data in $component: $details.
///
/// Source: horus/pb/logs/logs.proto:448:1
class DiscardingDataWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `DiscardingDataWarning`.
  DiscardingDataWarning() noexcept = default;

  /// Move constructor.
  DiscardingDataWarning(DiscardingDataWarning&&) noexcept = default;
  /// Move assignment operator.
  DiscardingDataWarning& operator=(DiscardingDataWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DiscardingDataWarning(const DiscardingDataWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DiscardingDataWarning& operator=(const DiscardingDataWarning&) = delete;

  /// Default destructor.
  ~DiscardingDataWarning() noexcept final = default;

  /// Creates a `DiscardingDataWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DiscardingDataWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.DiscardingDataWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.DiscardingDataWarning"; }

  /// The full name of the message: `horus.pb.logs.DiscardingDataWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  DiscardingDataWarning& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  DiscardingDataWarning&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  DiscardingDataWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  DiscardingDataWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see component()
  CowBytes component_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #56.
/// 
///  > Nothing to process: $details
///
/// Source: horus/pb/logs/logs.proto:456:1
class NothingToProcess final : public PbMessage {
 public:

  /// Constructs a default-initialized `NothingToProcess`.
  NothingToProcess() noexcept = default;

  /// Move constructor.
  NothingToProcess(NothingToProcess&&) noexcept = default;
  /// Move assignment operator.
  NothingToProcess& operator=(NothingToProcess&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit NothingToProcess(const NothingToProcess& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  NothingToProcess& operator=(const NothingToProcess&) = delete;

  /// Default destructor.
  ~NothingToProcess() noexcept final = default;

  /// Creates a `NothingToProcess` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit NothingToProcess(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.NothingToProcess`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.NothingToProcess"; }

  /// The full name of the message: `horus.pb.logs.NothingToProcess`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  NothingToProcess& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  NothingToProcess&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #57.
/// 
///  > Invalid configuration for $component: $details
///
/// Source: horus/pb/logs/logs.proto:463:1
class InvalidComponentConfiguration final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidComponentConfiguration`.
  InvalidComponentConfiguration() noexcept = default;

  /// Move constructor.
  InvalidComponentConfiguration(InvalidComponentConfiguration&&) noexcept = default;
  /// Move assignment operator.
  InvalidComponentConfiguration& operator=(InvalidComponentConfiguration&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidComponentConfiguration(const InvalidComponentConfiguration& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidComponentConfiguration& operator=(const InvalidComponentConfiguration&) = delete;

  /// Default destructor.
  ~InvalidComponentConfiguration() noexcept final = default;

  /// Creates a `InvalidComponentConfiguration` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidComponentConfiguration(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidComponentConfiguration`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidComponentConfiguration"; }

  /// The full name of the message: `horus.pb.logs.InvalidComponentConfiguration`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  InvalidComponentConfiguration& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  InvalidComponentConfiguration&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  InvalidComponentConfiguration& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  InvalidComponentConfiguration&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see component()
  CowBytes component_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #58.
/// 
///  > Channel receiver $key not found
///
/// Source: horus/pb/logs/logs.proto:471:1
class ChannelReceiverNotFoundWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ChannelReceiverNotFoundWarning`.
  ChannelReceiverNotFoundWarning() noexcept = default;

  /// Move constructor.
  ChannelReceiverNotFoundWarning(ChannelReceiverNotFoundWarning&&) noexcept = default;
  /// Move assignment operator.
  ChannelReceiverNotFoundWarning& operator=(ChannelReceiverNotFoundWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ChannelReceiverNotFoundWarning(const ChannelReceiverNotFoundWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ChannelReceiverNotFoundWarning& operator=(const ChannelReceiverNotFoundWarning&) = delete;

  /// Default destructor.
  ~ChannelReceiverNotFoundWarning() noexcept final = default;

  /// Creates a `ChannelReceiverNotFoundWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ChannelReceiverNotFoundWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ChannelReceiverNotFoundWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ChannelReceiverNotFoundWarning"; }

  /// The full name of the message: `horus.pb.logs.ChannelReceiverNotFoundWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `key` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& key() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return key_;
  }

  /// If `key` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes key() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(key_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_key() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return key_;
  }

  /// Returns whether `key` (no 1) is set.
  constexpr bool has_key() const noexcept { return set_fields_[0]; }

  /// Clears `key` (no 1).
  void clear_key() & noexcept {
    set_fields_[0] = false;
    key_ = {};
  }

  /// Sets `key` (no 1) and returns `*this`.
  ChannelReceiverNotFoundWarning& set_key(CowBytes&& key) & noexcept {
    set_fields_[0] = true;
    key_ = std::move(key);
    return *this;
  }
  /// Sets `key` (no 1) and returns `*this`.
  ChannelReceiverNotFoundWarning&& set_key(CowBytes&& key) && noexcept {
    return std::move(set_key(std::move(key)));
  }

 private:
  /// @see key()
  CowBytes key_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #59.
/// 
///  > Model $model failed to load: $details
///
/// Source: horus/pb/logs/logs.proto:478:1
class ModelLoadFailure final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelLoadFailure`.
  ModelLoadFailure() noexcept = default;

  /// Move constructor.
  ModelLoadFailure(ModelLoadFailure&&) noexcept = default;
  /// Move assignment operator.
  ModelLoadFailure& operator=(ModelLoadFailure&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelLoadFailure(const ModelLoadFailure& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelLoadFailure& operator=(const ModelLoadFailure&) = delete;

  /// Default destructor.
  ~ModelLoadFailure() noexcept final = default;

  /// Creates a `ModelLoadFailure` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelLoadFailure(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelLoadFailure`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelLoadFailure"; }

  /// The full name of the message: `horus.pb.logs.ModelLoadFailure`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `model` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& model() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return model_;
  }

  /// If `model` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes model() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(model_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_model() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return model_;
  }

  /// Returns whether `model` (no 1) is set.
  constexpr bool has_model() const noexcept { return set_fields_[0]; }

  /// Clears `model` (no 1).
  void clear_model() & noexcept {
    set_fields_[0] = false;
    model_ = {};
  }

  /// Sets `model` (no 1) and returns `*this`.
  ModelLoadFailure& set_model(CowBytes&& model) & noexcept {
    set_fields_[0] = true;
    model_ = std::move(model);
    return *this;
  }
  /// Sets `model` (no 1) and returns `*this`.
  ModelLoadFailure&& set_model(CowBytes&& model) && noexcept {
    return std::move(set_model(std::move(model)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  ModelLoadFailure& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  ModelLoadFailure&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see model()
  CowBytes model_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #60.
/// 
///  > Model $model failed to execute: $details
///
/// Source: horus/pb/logs/logs.proto:486:1
class ModelExecutionFailureError final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelExecutionFailureError`.
  ModelExecutionFailureError() noexcept = default;

  /// Move constructor.
  ModelExecutionFailureError(ModelExecutionFailureError&&) noexcept = default;
  /// Move assignment operator.
  ModelExecutionFailureError& operator=(ModelExecutionFailureError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelExecutionFailureError(const ModelExecutionFailureError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelExecutionFailureError& operator=(const ModelExecutionFailureError&) = delete;

  /// Default destructor.
  ~ModelExecutionFailureError() noexcept final = default;

  /// Creates a `ModelExecutionFailureError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelExecutionFailureError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelExecutionFailureError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelExecutionFailureError"; }

  /// The full name of the message: `horus.pb.logs.ModelExecutionFailureError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `model` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& model() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return model_;
  }

  /// If `model` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes model() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(model_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_model() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return model_;
  }

  /// Returns whether `model` (no 1) is set.
  constexpr bool has_model() const noexcept { return set_fields_[0]; }

  /// Clears `model` (no 1).
  void clear_model() & noexcept {
    set_fields_[0] = false;
    model_ = {};
  }

  /// Sets `model` (no 1) and returns `*this`.
  ModelExecutionFailureError& set_model(CowBytes&& model) & noexcept {
    set_fields_[0] = true;
    model_ = std::move(model);
    return *this;
  }
  /// Sets `model` (no 1) and returns `*this`.
  ModelExecutionFailureError&& set_model(CowBytes&& model) && noexcept {
    return std::move(set_model(std::move(model)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  ModelExecutionFailureError& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  ModelExecutionFailureError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see model()
  CowBytes model_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #61.
/// 
///  > $service service is ready
///
/// Source: horus/pb/logs/logs.proto:494:1
class ServiceReadyInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ServiceReadyInfo`.
  ServiceReadyInfo() noexcept = default;

  /// Move constructor.
  ServiceReadyInfo(ServiceReadyInfo&&) noexcept = default;
  /// Move assignment operator.
  ServiceReadyInfo& operator=(ServiceReadyInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ServiceReadyInfo(const ServiceReadyInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ServiceReadyInfo& operator=(const ServiceReadyInfo&) = delete;

  /// Default destructor.
  ~ServiceReadyInfo() noexcept final = default;

  /// Creates a `ServiceReadyInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ServiceReadyInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ServiceReadyInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ServiceReadyInfo"; }

  /// The full name of the message: `horus.pb.logs.ServiceReadyInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& service() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return service_;
  }

  /// If `service` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes service() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(service_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_service() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_;
  }

  /// Returns whether `service` (no 1) is set.
  constexpr bool has_service() const noexcept { return set_fields_[0]; }

  /// Clears `service` (no 1).
  void clear_service() & noexcept {
    set_fields_[0] = false;
    service_ = {};
  }

  /// Sets `service` (no 1) and returns `*this`.
  ServiceReadyInfo& set_service(CowBytes&& service) & noexcept {
    set_fields_[0] = true;
    service_ = std::move(service);
    return *this;
  }
  /// Sets `service` (no 1) and returns `*this`.
  ServiceReadyInfo&& set_service(CowBytes&& service) && noexcept {
    return std::move(set_service(std::move(service)));
  }

 private:
  /// @see service()
  CowBytes service_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #62.
/// 
///  > Preparing model $model, it may take several seconds to stabilize.
///
/// Source: horus/pb/logs/logs.proto:501:1
class ModelPreparingInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelPreparingInfo`.
  ModelPreparingInfo() noexcept = default;

  /// Move constructor.
  ModelPreparingInfo(ModelPreparingInfo&&) noexcept = default;
  /// Move assignment operator.
  ModelPreparingInfo& operator=(ModelPreparingInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelPreparingInfo(const ModelPreparingInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelPreparingInfo& operator=(const ModelPreparingInfo&) = delete;

  /// Default destructor.
  ~ModelPreparingInfo() noexcept final = default;

  /// Creates a `ModelPreparingInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelPreparingInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelPreparingInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelPreparingInfo"; }

  /// The full name of the message: `horus.pb.logs.ModelPreparingInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `model` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& model() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return model_;
  }

  /// If `model` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes model() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(model_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_model() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return model_;
  }

  /// Returns whether `model` (no 1) is set.
  constexpr bool has_model() const noexcept { return set_fields_[0]; }

  /// Clears `model` (no 1).
  void clear_model() & noexcept {
    set_fields_[0] = false;
    model_ = {};
  }

  /// Sets `model` (no 1) and returns `*this`.
  ModelPreparingInfo& set_model(CowBytes&& model) & noexcept {
    set_fields_[0] = true;
    model_ = std::move(model);
    return *this;
  }
  /// Sets `model` (no 1) and returns `*this`.
  ModelPreparingInfo&& set_model(CowBytes&& model) && noexcept {
    return std::move(set_model(std::move(model)));
  }

 private:
  /// @see model()
  CowBytes model_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #63.
/// 
///  > $name model has been initialized and is ready for use.
///
/// Source: horus/pb/logs/logs.proto:508:1
class ModelInitializedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelInitializedInfo`.
  ModelInitializedInfo() noexcept = default;

  /// Move constructor.
  ModelInitializedInfo(ModelInitializedInfo&&) noexcept = default;
  /// Move assignment operator.
  ModelInitializedInfo& operator=(ModelInitializedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelInitializedInfo(const ModelInitializedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelInitializedInfo& operator=(const ModelInitializedInfo&) = delete;

  /// Default destructor.
  ~ModelInitializedInfo() noexcept final = default;

  /// Creates a `ModelInitializedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelInitializedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelInitializedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelInitializedInfo"; }

  /// The full name of the message: `horus.pb.logs.ModelInitializedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  ModelInitializedInfo& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  ModelInitializedInfo&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

 private:
  /// @see name()
  CowBytes name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #64.
/// 
///  > Failed to initialize model $model: $details
///
/// Source: horus/pb/logs/logs.proto:515:1
class ModelInitializationFailureWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelInitializationFailureWarning`.
  ModelInitializationFailureWarning() noexcept = default;

  /// Move constructor.
  ModelInitializationFailureWarning(ModelInitializationFailureWarning&&) noexcept = default;
  /// Move assignment operator.
  ModelInitializationFailureWarning& operator=(ModelInitializationFailureWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelInitializationFailureWarning(const ModelInitializationFailureWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelInitializationFailureWarning& operator=(const ModelInitializationFailureWarning&) = delete;

  /// Default destructor.
  ~ModelInitializationFailureWarning() noexcept final = default;

  /// Creates a `ModelInitializationFailureWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelInitializationFailureWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelInitializationFailureWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelInitializationFailureWarning"; }

  /// The full name of the message: `horus.pb.logs.ModelInitializationFailureWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `model` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& model() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return model_;
  }

  /// If `model` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes model() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(model_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_model() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return model_;
  }

  /// Returns whether `model` (no 1) is set.
  constexpr bool has_model() const noexcept { return set_fields_[0]; }

  /// Clears `model` (no 1).
  void clear_model() & noexcept {
    set_fields_[0] = false;
    model_ = {};
  }

  /// Sets `model` (no 1) and returns `*this`.
  ModelInitializationFailureWarning& set_model(CowBytes&& model) & noexcept {
    set_fields_[0] = true;
    model_ = std::move(model);
    return *this;
  }
  /// Sets `model` (no 1) and returns `*this`.
  ModelInitializationFailureWarning&& set_model(CowBytes&& model) && noexcept {
    return std::move(set_model(std::move(model)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  ModelInitializationFailureWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  ModelInitializationFailureWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see model()
  CowBytes model_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #65.
/// 
///  > ROS spinner stopped: $details
///
/// Source: horus/pb/logs/logs.proto:523:1
class RosSpinnerStoppedWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RosSpinnerStoppedWarning`.
  RosSpinnerStoppedWarning() noexcept = default;

  /// Move constructor.
  RosSpinnerStoppedWarning(RosSpinnerStoppedWarning&&) noexcept = default;
  /// Move assignment operator.
  RosSpinnerStoppedWarning& operator=(RosSpinnerStoppedWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RosSpinnerStoppedWarning(const RosSpinnerStoppedWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RosSpinnerStoppedWarning& operator=(const RosSpinnerStoppedWarning&) = delete;

  /// Default destructor.
  ~RosSpinnerStoppedWarning() noexcept final = default;

  /// Creates a `RosSpinnerStoppedWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RosSpinnerStoppedWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RosSpinnerStoppedWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RosSpinnerStoppedWarning"; }

  /// The full name of the message: `horus.pb.logs.RosSpinnerStoppedWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  RosSpinnerStoppedWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  RosSpinnerStoppedWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #66.
/// 
///  > Actor system is not available. Please reinstantiate the pipeline.
///
/// Source: horus/pb/logs/logs.proto:530:1
class ActorSystemUnavailableError final : public PbMessage {
 public:

  /// Constructs a default-initialized `ActorSystemUnavailableError`.
  ActorSystemUnavailableError() noexcept = default;

  /// Move constructor.
  ActorSystemUnavailableError(ActorSystemUnavailableError&&) noexcept = default;
  /// Move assignment operator.
  ActorSystemUnavailableError& operator=(ActorSystemUnavailableError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ActorSystemUnavailableError(const ActorSystemUnavailableError&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ActorSystemUnavailableError& operator=(const ActorSystemUnavailableError&) = delete;

  /// Default destructor.
  ~ActorSystemUnavailableError() noexcept final = default;

  /// Creates a `ActorSystemUnavailableError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ActorSystemUnavailableError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ActorSystemUnavailableError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ActorSystemUnavailableError"; }

  /// The full name of the message: `horus.pb.logs.ActorSystemUnavailableError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #67.
/// 
///  > Configuration for node $node is unavailable
///
/// Source: horus/pb/logs/logs.proto:536:1
class ConfigNodeNotFoundError final : public PbMessage {
 public:

  /// Constructs a default-initialized `ConfigNodeNotFoundError`.
  ConfigNodeNotFoundError() noexcept = default;

  /// Move constructor.
  ConfigNodeNotFoundError(ConfigNodeNotFoundError&&) noexcept = default;
  /// Move assignment operator.
  ConfigNodeNotFoundError& operator=(ConfigNodeNotFoundError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ConfigNodeNotFoundError(const ConfigNodeNotFoundError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ConfigNodeNotFoundError& operator=(const ConfigNodeNotFoundError&) = delete;

  /// Default destructor.
  ~ConfigNodeNotFoundError() noexcept final = default;

  /// Creates a `ConfigNodeNotFoundError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ConfigNodeNotFoundError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ConfigNodeNotFoundError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ConfigNodeNotFoundError"; }

  /// The full name of the message: `horus.pb.logs.ConfigNodeNotFoundError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `node` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& node() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return node_;
  }

  /// If `node` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes node() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(node_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_node() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return node_;
  }

  /// Returns whether `node` (no 1) is set.
  constexpr bool has_node() const noexcept { return set_fields_[0]; }

  /// Clears `node` (no 1).
  void clear_node() & noexcept {
    set_fields_[0] = false;
    node_ = {};
  }

  /// Sets `node` (no 1) and returns `*this`.
  ConfigNodeNotFoundError& set_node(CowBytes&& node) & noexcept {
    set_fields_[0] = true;
    node_ = std::move(node);
    return *this;
  }
  /// Sets `node` (no 1) and returns `*this`.
  ConfigNodeNotFoundError&& set_node(CowBytes&& node) && noexcept {
    return std::move(set_node(std::move(node)));
  }

 private:
  /// @see node()
  CowBytes node_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #68.
/// 
///  > Timestamps are out of order: $prior_timestamp > $current_timestamp
///
/// Source: horus/pb/logs/logs.proto:543:1
class BagTimestampOutOfOrderError final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagTimestampOutOfOrderError`.
  BagTimestampOutOfOrderError() noexcept = default;

  /// Move constructor.
  BagTimestampOutOfOrderError(BagTimestampOutOfOrderError&&) noexcept = default;
  /// Move assignment operator.
  BagTimestampOutOfOrderError& operator=(BagTimestampOutOfOrderError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagTimestampOutOfOrderError(const BagTimestampOutOfOrderError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagTimestampOutOfOrderError& operator=(const BagTimestampOutOfOrderError&) = delete;

  /// Default destructor.
  ~BagTimestampOutOfOrderError() noexcept final = default;

  /// Creates a `BagTimestampOutOfOrderError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagTimestampOutOfOrderError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagTimestampOutOfOrderError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagTimestampOutOfOrderError"; }

  /// The full name of the message: `horus.pb.logs.BagTimestampOutOfOrderError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `prior_timestamp` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& prior_timestamp() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return prior_timestamp_;
  }

  /// If `prior_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp prior_timestamp() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(prior_timestamp_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_prior_timestamp() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return prior_timestamp_;
  }

  /// Returns whether `prior_timestamp` (no 1) is set.
  constexpr bool has_prior_timestamp() const noexcept { return set_fields_[0]; }

  /// Clears `prior_timestamp` (no 1).
  void clear_prior_timestamp() & noexcept {
    set_fields_[0] = false;
    prior_timestamp_ = {};
  }

  /// Sets `prior_timestamp` (no 1) and returns `*this`.
  BagTimestampOutOfOrderError& set_prior_timestamp(horus::pb::LogMetadata_Timestamp&& prior_timestamp) & noexcept {
    set_fields_[0] = true;
    prior_timestamp_ = std::move(prior_timestamp);
    return *this;
  }
  /// Sets `prior_timestamp` (no 1) and returns `*this`.
  BagTimestampOutOfOrderError&& set_prior_timestamp(horus::pb::LogMetadata_Timestamp&& prior_timestamp) && noexcept {
    return std::move(set_prior_timestamp(std::move(prior_timestamp)));
  }

  // Field `current_timestamp` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Timestamp& current_timestamp() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return current_timestamp_;
  }

  /// If `current_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp current_timestamp() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(current_timestamp_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp& mutable_current_timestamp() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return current_timestamp_;
  }

  /// Returns whether `current_timestamp` (no 2) is set.
  constexpr bool has_current_timestamp() const noexcept { return set_fields_[1]; }

  /// Clears `current_timestamp` (no 2).
  void clear_current_timestamp() & noexcept {
    set_fields_[1] = false;
    current_timestamp_ = {};
  }

  /// Sets `current_timestamp` (no 2) and returns `*this`.
  BagTimestampOutOfOrderError& set_current_timestamp(horus::pb::LogMetadata_Timestamp&& current_timestamp) & noexcept {
    set_fields_[1] = true;
    current_timestamp_ = std::move(current_timestamp);
    return *this;
  }
  /// Sets `current_timestamp` (no 2) and returns `*this`.
  BagTimestampOutOfOrderError&& set_current_timestamp(horus::pb::LogMetadata_Timestamp&& current_timestamp) && noexcept {
    return std::move(set_current_timestamp(std::move(current_timestamp)));
  }

 private:
  /// @see prior_timestamp()
  horus::pb::LogMetadata_Timestamp prior_timestamp_{};
  /// @see current_timestamp()
  horus::pb::LogMetadata_Timestamp current_timestamp_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #69.
/// 
///  > Unexpected timestamp: expected $expected_timestamp but received $received_timestamp
///
/// Source: horus/pb/logs/logs.proto:551:1
class BagReplayUnexpectedTimestampError final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagReplayUnexpectedTimestampError`.
  BagReplayUnexpectedTimestampError() noexcept = default;

  /// Move constructor.
  BagReplayUnexpectedTimestampError(BagReplayUnexpectedTimestampError&&) noexcept = default;
  /// Move assignment operator.
  BagReplayUnexpectedTimestampError& operator=(BagReplayUnexpectedTimestampError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagReplayUnexpectedTimestampError(const BagReplayUnexpectedTimestampError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagReplayUnexpectedTimestampError& operator=(const BagReplayUnexpectedTimestampError&) = delete;

  /// Default destructor.
  ~BagReplayUnexpectedTimestampError() noexcept final = default;

  /// Creates a `BagReplayUnexpectedTimestampError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagReplayUnexpectedTimestampError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagReplayUnexpectedTimestampError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagReplayUnexpectedTimestampError"; }

  /// The full name of the message: `horus.pb.logs.BagReplayUnexpectedTimestampError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `expected_timestamp` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& expected_timestamp() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return expected_timestamp_;
  }

  /// If `expected_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp expected_timestamp() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(expected_timestamp_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_expected_timestamp() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return expected_timestamp_;
  }

  /// Returns whether `expected_timestamp` (no 1) is set.
  constexpr bool has_expected_timestamp() const noexcept { return set_fields_[0]; }

  /// Clears `expected_timestamp` (no 1).
  void clear_expected_timestamp() & noexcept {
    set_fields_[0] = false;
    expected_timestamp_ = {};
  }

  /// Sets `expected_timestamp` (no 1) and returns `*this`.
  BagReplayUnexpectedTimestampError& set_expected_timestamp(horus::pb::LogMetadata_Timestamp&& expected_timestamp) & noexcept {
    set_fields_[0] = true;
    expected_timestamp_ = std::move(expected_timestamp);
    return *this;
  }
  /// Sets `expected_timestamp` (no 1) and returns `*this`.
  BagReplayUnexpectedTimestampError&& set_expected_timestamp(horus::pb::LogMetadata_Timestamp&& expected_timestamp) && noexcept {
    return std::move(set_expected_timestamp(std::move(expected_timestamp)));
  }

  // Field `received_timestamp` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Timestamp& received_timestamp() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return received_timestamp_;
  }

  /// If `received_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp received_timestamp() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(received_timestamp_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp& mutable_received_timestamp() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return received_timestamp_;
  }

  /// Returns whether `received_timestamp` (no 2) is set.
  constexpr bool has_received_timestamp() const noexcept { return set_fields_[1]; }

  /// Clears `received_timestamp` (no 2).
  void clear_received_timestamp() & noexcept {
    set_fields_[1] = false;
    received_timestamp_ = {};
  }

  /// Sets `received_timestamp` (no 2) and returns `*this`.
  BagReplayUnexpectedTimestampError& set_received_timestamp(horus::pb::LogMetadata_Timestamp&& received_timestamp) & noexcept {
    set_fields_[1] = true;
    received_timestamp_ = std::move(received_timestamp);
    return *this;
  }
  /// Sets `received_timestamp` (no 2) and returns `*this`.
  BagReplayUnexpectedTimestampError&& set_received_timestamp(horus::pb::LogMetadata_Timestamp&& received_timestamp) && noexcept {
    return std::move(set_received_timestamp(std::move(received_timestamp)));
  }

 private:
  /// @see expected_timestamp()
  horus::pb::LogMetadata_Timestamp expected_timestamp_{};
  /// @see received_timestamp()
  horus::pb::LogMetadata_Timestamp received_timestamp_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #70.
/// 
///  > WebSocket RPC connection to $uri closed
///
/// Source: horus/pb/logs/logs.proto:559:1
class WebsocketClosedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketClosedInfo`.
  WebsocketClosedInfo() noexcept = default;

  /// Move constructor.
  WebsocketClosedInfo(WebsocketClosedInfo&&) noexcept = default;
  /// Move assignment operator.
  WebsocketClosedInfo& operator=(WebsocketClosedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketClosedInfo(const WebsocketClosedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketClosedInfo& operator=(const WebsocketClosedInfo&) = delete;

  /// Default destructor.
  ~WebsocketClosedInfo() noexcept final = default;

  /// Creates a `WebsocketClosedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketClosedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketClosedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketClosedInfo"; }

  /// The full name of the message: `horus.pb.logs.WebsocketClosedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `uri` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return uri_;
  }

  /// If `uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes uri() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(uri_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return uri_;
  }

  /// Returns whether `uri` (no 1) is set.
  constexpr bool has_uri() const noexcept { return set_fields_[0]; }

  /// Clears `uri` (no 1).
  void clear_uri() & noexcept {
    set_fields_[0] = false;
    uri_ = {};
  }

  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketClosedInfo& set_uri(CowBytes&& uri) & noexcept {
    set_fields_[0] = true;
    uri_ = std::move(uri);
    return *this;
  }
  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketClosedInfo&& set_uri(CowBytes&& uri) && noexcept {
    return std::move(set_uri(std::move(uri)));
  }

 private:
  /// @see uri()
  CowBytes uri_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #71.
/// 
///  > WebSocket RPC connection to $uri opened (as $endpoint_is_server_client)
///
/// Source: horus/pb/logs/logs.proto:566:1
class WebsocketOpenedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketOpenedInfo`.
  WebsocketOpenedInfo() noexcept = default;

  /// Move constructor.
  WebsocketOpenedInfo(WebsocketOpenedInfo&&) noexcept = default;
  /// Move assignment operator.
  WebsocketOpenedInfo& operator=(WebsocketOpenedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketOpenedInfo(const WebsocketOpenedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketOpenedInfo& operator=(const WebsocketOpenedInfo&) = delete;

  /// Default destructor.
  ~WebsocketOpenedInfo() noexcept final = default;

  /// Creates a `WebsocketOpenedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketOpenedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketOpenedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketOpenedInfo"; }

  /// The full name of the message: `horus.pb.logs.WebsocketOpenedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `uri` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return uri_;
  }

  /// If `uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes uri() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(uri_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return uri_;
  }

  /// Returns whether `uri` (no 1) is set.
  constexpr bool has_uri() const noexcept { return set_fields_[0]; }

  /// Clears `uri` (no 1).
  void clear_uri() & noexcept {
    set_fields_[0] = false;
    uri_ = {};
  }

  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketOpenedInfo& set_uri(CowBytes&& uri) & noexcept {
    set_fields_[0] = true;
    uri_ = std::move(uri);
    return *this;
  }
  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketOpenedInfo&& set_uri(CowBytes&& uri) && noexcept {
    return std::move(set_uri(std::move(uri)));
  }

  // Field `endpoint_is_server_client` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& endpoint_is_server_client() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return endpoint_is_server_client_;
  }

  /// If `endpoint_is_server_client` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes endpoint_is_server_client() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(endpoint_is_server_client_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_endpoint_is_server_client() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return endpoint_is_server_client_;
  }

  /// Returns whether `endpoint_is_server_client` (no 2) is set.
  constexpr bool has_endpoint_is_server_client() const noexcept { return set_fields_[1]; }

  /// Clears `endpoint_is_server_client` (no 2).
  void clear_endpoint_is_server_client() & noexcept {
    set_fields_[1] = false;
    endpoint_is_server_client_ = {};
  }

  /// Sets `endpoint_is_server_client` (no 2) and returns `*this`.
  WebsocketOpenedInfo& set_endpoint_is_server_client(CowBytes&& endpoint_is_server_client) & noexcept {
    set_fields_[1] = true;
    endpoint_is_server_client_ = std::move(endpoint_is_server_client);
    return *this;
  }
  /// Sets `endpoint_is_server_client` (no 2) and returns `*this`.
  WebsocketOpenedInfo&& set_endpoint_is_server_client(CowBytes&& endpoint_is_server_client) && noexcept {
    return std::move(set_endpoint_is_server_client(std::move(endpoint_is_server_client)));
  }

 private:
  /// @see uri()
  CowBytes uri_{};
  /// @see endpoint_is_server_client()
  CowBytes endpoint_is_server_client_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #72.
/// 
///  > Subscriber $name disconnected ($uri)
///
/// Source: horus/pb/logs/logs.proto:574:1
class SubscriberDisconnectedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `SubscriberDisconnectedInfo`.
  SubscriberDisconnectedInfo() noexcept = default;

  /// Move constructor.
  SubscriberDisconnectedInfo(SubscriberDisconnectedInfo&&) noexcept = default;
  /// Move assignment operator.
  SubscriberDisconnectedInfo& operator=(SubscriberDisconnectedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit SubscriberDisconnectedInfo(const SubscriberDisconnectedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  SubscriberDisconnectedInfo& operator=(const SubscriberDisconnectedInfo&) = delete;

  /// Default destructor.
  ~SubscriberDisconnectedInfo() noexcept final = default;

  /// Creates a `SubscriberDisconnectedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit SubscriberDisconnectedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.SubscriberDisconnectedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.SubscriberDisconnectedInfo"; }

  /// The full name of the message: `horus.pb.logs.SubscriberDisconnectedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return name_;
  }

  /// If `name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return name_;
  }

  /// Returns whether `name` (no 1) is set.
  constexpr bool has_name() const noexcept { return set_fields_[0]; }

  /// Clears `name` (no 1).
  void clear_name() & noexcept {
    set_fields_[0] = false;
    name_ = {};
  }

  /// Sets `name` (no 1) and returns `*this`.
  SubscriberDisconnectedInfo& set_name(CowBytes&& name) & noexcept {
    set_fields_[0] = true;
    name_ = std::move(name);
    return *this;
  }
  /// Sets `name` (no 1) and returns `*this`.
  SubscriberDisconnectedInfo&& set_name(CowBytes&& name) && noexcept {
    return std::move(set_name(std::move(name)));
  }

  // Field `uri` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return uri_;
  }

  /// If `uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes uri() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(uri_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return uri_;
  }

  /// Returns whether `uri` (no 2) is set.
  constexpr bool has_uri() const noexcept { return set_fields_[1]; }

  /// Clears `uri` (no 2).
  void clear_uri() & noexcept {
    set_fields_[1] = false;
    uri_ = {};
  }

  /// Sets `uri` (no 2) and returns `*this`.
  SubscriberDisconnectedInfo& set_uri(CowBytes&& uri) & noexcept {
    set_fields_[1] = true;
    uri_ = std::move(uri);
    return *this;
  }
  /// Sets `uri` (no 2) and returns `*this`.
  SubscriberDisconnectedInfo&& set_uri(CowBytes&& uri) && noexcept {
    return std::move(set_uri(std::move(uri)));
  }

 private:
  /// @see name()
  CowBytes name_{};
  /// @see uri()
  CowBytes uri_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #73.
/// 
///  > Thread pool is slowing down for $number times!
///
/// Source: horus/pb/logs/logs.proto:582:1
class ThreadPoolSlowingDownWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ThreadPoolSlowingDownWarning`.
  ThreadPoolSlowingDownWarning() noexcept = default;

  /// Move constructor.
  ThreadPoolSlowingDownWarning(ThreadPoolSlowingDownWarning&&) noexcept = default;
  /// Move assignment operator.
  ThreadPoolSlowingDownWarning& operator=(ThreadPoolSlowingDownWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ThreadPoolSlowingDownWarning(const ThreadPoolSlowingDownWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ThreadPoolSlowingDownWarning& operator=(const ThreadPoolSlowingDownWarning&) = delete;

  /// Default destructor.
  ~ThreadPoolSlowingDownWarning() noexcept final = default;

  /// Creates a `ThreadPoolSlowingDownWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ThreadPoolSlowingDownWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ThreadPoolSlowingDownWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ThreadPoolSlowingDownWarning"; }

  /// The full name of the message: `horus.pb.logs.ThreadPoolSlowingDownWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `number` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t number() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return number_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_number() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return number_;
  }

  /// Returns whether `number` (no 1) is set.
  constexpr bool has_number() const noexcept { return set_fields_[0]; }

  /// Clears `number` (no 1).
  void clear_number() & noexcept {
    set_fields_[0] = false;
    number_ = {};
  }

  /// Sets `number` (no 1) and returns `*this`.
  ThreadPoolSlowingDownWarning& set_number(std::uint64_t number) & noexcept {
    set_fields_[0] = true;
    number_ = number;
    return *this;
  }
  /// Sets `number` (no 1) and returns `*this`.
  ThreadPoolSlowingDownWarning&& set_number(std::uint64_t number) && noexcept {
    return std::move(set_number(number));
  }

 private:
  /// @see number()
  std::uint64_t number_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #74.
/// 
///  > Thread pool is not responding for $not_responding_for.
///
/// Source: horus/pb/logs/logs.proto:589:1
class ThreadPoolNotRespondingWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ThreadPoolNotRespondingWarning`.
  ThreadPoolNotRespondingWarning() noexcept = default;

  /// Move constructor.
  ThreadPoolNotRespondingWarning(ThreadPoolNotRespondingWarning&&) noexcept = default;
  /// Move assignment operator.
  ThreadPoolNotRespondingWarning& operator=(ThreadPoolNotRespondingWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ThreadPoolNotRespondingWarning(const ThreadPoolNotRespondingWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ThreadPoolNotRespondingWarning& operator=(const ThreadPoolNotRespondingWarning&) = delete;

  /// Default destructor.
  ~ThreadPoolNotRespondingWarning() noexcept final = default;

  /// Creates a `ThreadPoolNotRespondingWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ThreadPoolNotRespondingWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ThreadPoolNotRespondingWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ThreadPoolNotRespondingWarning"; }

  /// The full name of the message: `horus.pb.logs.ThreadPoolNotRespondingWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `not_responding_for` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Duration& not_responding_for() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return not_responding_for_;
  }

  /// If `not_responding_for` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Duration not_responding_for() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(not_responding_for_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Duration& mutable_not_responding_for() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return not_responding_for_;
  }

  /// Returns whether `not_responding_for` (no 1) is set.
  constexpr bool has_not_responding_for() const noexcept { return set_fields_[0]; }

  /// Clears `not_responding_for` (no 1).
  void clear_not_responding_for() & noexcept {
    set_fields_[0] = false;
    not_responding_for_ = {};
  }

  /// Sets `not_responding_for` (no 1) and returns `*this`.
  ThreadPoolNotRespondingWarning& set_not_responding_for(horus::pb::LogMetadata_Duration&& not_responding_for) & noexcept {
    set_fields_[0] = true;
    not_responding_for_ = std::move(not_responding_for);
    return *this;
  }
  /// Sets `not_responding_for` (no 1) and returns `*this`.
  ThreadPoolNotRespondingWarning&& set_not_responding_for(horus::pb::LogMetadata_Duration&& not_responding_for) && noexcept {
    return std::move(set_not_responding_for(std::move(not_responding_for)));
  }

 private:
  /// @see not_responding_for()
  horus::pb::LogMetadata_Duration not_responding_for_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #75.
/// 
///  > Thread pool task future is no longer available. The thread pool might have been restarted during events such as input source change.
///
/// Source: horus/pb/logs/logs.proto:596:1
class ThreadPoolBrokenPromiseWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ThreadPoolBrokenPromiseWarning`.
  ThreadPoolBrokenPromiseWarning() noexcept = default;

  /// Move constructor.
  ThreadPoolBrokenPromiseWarning(ThreadPoolBrokenPromiseWarning&&) noexcept = default;
  /// Move assignment operator.
  ThreadPoolBrokenPromiseWarning& operator=(ThreadPoolBrokenPromiseWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ThreadPoolBrokenPromiseWarning(const ThreadPoolBrokenPromiseWarning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ThreadPoolBrokenPromiseWarning& operator=(const ThreadPoolBrokenPromiseWarning&) = delete;

  /// Default destructor.
  ~ThreadPoolBrokenPromiseWarning() noexcept final = default;

  /// Creates a `ThreadPoolBrokenPromiseWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ThreadPoolBrokenPromiseWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ThreadPoolBrokenPromiseWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ThreadPoolBrokenPromiseWarning"; }

  /// The full name of the message: `horus.pb.logs.ThreadPoolBrokenPromiseWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #76.
/// 
///  > Some points are below the base Z-coordinate when fitting the box. This might affect the detection results.
///
/// Source: horus/pb/logs/logs.proto:602:1
class BoxFittingPointsBelowBaseWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `BoxFittingPointsBelowBaseWarning`.
  BoxFittingPointsBelowBaseWarning() noexcept = default;

  /// Move constructor.
  BoxFittingPointsBelowBaseWarning(BoxFittingPointsBelowBaseWarning&&) noexcept = default;
  /// Move assignment operator.
  BoxFittingPointsBelowBaseWarning& operator=(BoxFittingPointsBelowBaseWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BoxFittingPointsBelowBaseWarning(const BoxFittingPointsBelowBaseWarning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BoxFittingPointsBelowBaseWarning& operator=(const BoxFittingPointsBelowBaseWarning&) = delete;

  /// Default destructor.
  ~BoxFittingPointsBelowBaseWarning() noexcept final = default;

  /// Creates a `BoxFittingPointsBelowBaseWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BoxFittingPointsBelowBaseWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BoxFittingPointsBelowBaseWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BoxFittingPointsBelowBaseWarning"; }

  /// The full name of the message: `horus.pb.logs.BoxFittingPointsBelowBaseWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #77.
/// 
///  > Failed to remove stale points: $details
///
/// Source: horus/pb/logs/logs.proto:608:1
class FailedToRemoveStalePointsWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `FailedToRemoveStalePointsWarning`.
  FailedToRemoveStalePointsWarning() noexcept = default;

  /// Move constructor.
  FailedToRemoveStalePointsWarning(FailedToRemoveStalePointsWarning&&) noexcept = default;
  /// Move assignment operator.
  FailedToRemoveStalePointsWarning& operator=(FailedToRemoveStalePointsWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FailedToRemoveStalePointsWarning(const FailedToRemoveStalePointsWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FailedToRemoveStalePointsWarning& operator=(const FailedToRemoveStalePointsWarning&) = delete;

  /// Default destructor.
  ~FailedToRemoveStalePointsWarning() noexcept final = default;

  /// Creates a `FailedToRemoveStalePointsWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FailedToRemoveStalePointsWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FailedToRemoveStalePointsWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FailedToRemoveStalePointsWarning"; }

  /// The full name of the message: `horus.pb.logs.FailedToRemoveStalePointsWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  FailedToRemoveStalePointsWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  FailedToRemoveStalePointsWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #78.
/// 
///  > $num_irregular irregular broadcast(s) detected in the last $duration (mean deviation: $mean_deviation).
///
/// Source: horus/pb/logs/logs.proto:615:1
class IrregularBroadcastingPeriodWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `IrregularBroadcastingPeriodWarning`.
  IrregularBroadcastingPeriodWarning() noexcept = default;

  /// Move constructor.
  IrregularBroadcastingPeriodWarning(IrregularBroadcastingPeriodWarning&&) noexcept = default;
  /// Move assignment operator.
  IrregularBroadcastingPeriodWarning& operator=(IrregularBroadcastingPeriodWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit IrregularBroadcastingPeriodWarning(const IrregularBroadcastingPeriodWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  IrregularBroadcastingPeriodWarning& operator=(const IrregularBroadcastingPeriodWarning&) = delete;

  /// Default destructor.
  ~IrregularBroadcastingPeriodWarning() noexcept final = default;

  /// Creates a `IrregularBroadcastingPeriodWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit IrregularBroadcastingPeriodWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.IrregularBroadcastingPeriodWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.IrregularBroadcastingPeriodWarning"; }

  /// The full name of the message: `horus.pb.logs.IrregularBroadcastingPeriodWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `num_irregular` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t num_irregular() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return num_irregular_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_num_irregular() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return num_irregular_;
  }

  /// Returns whether `num_irregular` (no 1) is set.
  constexpr bool has_num_irregular() const noexcept { return set_fields_[0]; }

  /// Clears `num_irregular` (no 1).
  void clear_num_irregular() & noexcept {
    set_fields_[0] = false;
    num_irregular_ = {};
  }

  /// Sets `num_irregular` (no 1) and returns `*this`.
  IrregularBroadcastingPeriodWarning& set_num_irregular(std::uint64_t num_irregular) & noexcept {
    set_fields_[0] = true;
    num_irregular_ = num_irregular;
    return *this;
  }
  /// Sets `num_irregular` (no 1) and returns `*this`.
  IrregularBroadcastingPeriodWarning&& set_num_irregular(std::uint64_t num_irregular) && noexcept {
    return std::move(set_num_irregular(num_irregular));
  }

  // Field `duration` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Duration& duration() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return duration_;
  }

  /// If `duration` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration duration() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(duration_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration& mutable_duration() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return duration_;
  }

  /// Returns whether `duration` (no 2) is set.
  constexpr bool has_duration() const noexcept { return set_fields_[1]; }

  /// Clears `duration` (no 2).
  void clear_duration() & noexcept {
    set_fields_[1] = false;
    duration_ = {};
  }

  /// Sets `duration` (no 2) and returns `*this`.
  IrregularBroadcastingPeriodWarning& set_duration(horus::pb::LogMetadata_Duration&& duration) & noexcept {
    set_fields_[1] = true;
    duration_ = std::move(duration);
    return *this;
  }
  /// Sets `duration` (no 2) and returns `*this`.
  IrregularBroadcastingPeriodWarning&& set_duration(horus::pb::LogMetadata_Duration&& duration) && noexcept {
    return std::move(set_duration(std::move(duration)));
  }

  // Field `mean_deviation` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const horus::pb::LogMetadata_Duration& mean_deviation() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return mean_deviation_;
  }

  /// If `mean_deviation` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration mean_deviation() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(mean_deviation_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration& mutable_mean_deviation() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return mean_deviation_;
  }

  /// Returns whether `mean_deviation` (no 3) is set.
  constexpr bool has_mean_deviation() const noexcept { return set_fields_[2]; }

  /// Clears `mean_deviation` (no 3).
  void clear_mean_deviation() & noexcept {
    set_fields_[2] = false;
    mean_deviation_ = {};
  }

  /// Sets `mean_deviation` (no 3) and returns `*this`.
  IrregularBroadcastingPeriodWarning& set_mean_deviation(horus::pb::LogMetadata_Duration&& mean_deviation) & noexcept {
    set_fields_[2] = true;
    mean_deviation_ = std::move(mean_deviation);
    return *this;
  }
  /// Sets `mean_deviation` (no 3) and returns `*this`.
  IrregularBroadcastingPeriodWarning&& set_mean_deviation(horus::pb::LogMetadata_Duration&& mean_deviation) && noexcept {
    return std::move(set_mean_deviation(std::move(mean_deviation)));
  }

 private:
  /// @see num_irregular()
  std::uint64_t num_irregular_{};
  /// @see duration()
  horus::pb::LogMetadata_Duration duration_{};
  /// @see mean_deviation()
  horus::pb::LogMetadata_Duration mean_deviation_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #79.
/// 
///  > There are $num_points points out of range in the clusterer. Some points: $sample_points.
///
/// Source: horus/pb/logs/logs.proto:624:1
class ClustererPointsOutOfRangeWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ClustererPointsOutOfRangeWarning`.
  ClustererPointsOutOfRangeWarning() noexcept = default;

  /// Move constructor.
  ClustererPointsOutOfRangeWarning(ClustererPointsOutOfRangeWarning&&) noexcept = default;
  /// Move assignment operator.
  ClustererPointsOutOfRangeWarning& operator=(ClustererPointsOutOfRangeWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ClustererPointsOutOfRangeWarning(const ClustererPointsOutOfRangeWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ClustererPointsOutOfRangeWarning& operator=(const ClustererPointsOutOfRangeWarning&) = delete;

  /// Default destructor.
  ~ClustererPointsOutOfRangeWarning() noexcept final = default;

  /// Creates a `ClustererPointsOutOfRangeWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ClustererPointsOutOfRangeWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ClustererPointsOutOfRangeWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ClustererPointsOutOfRangeWarning"; }

  /// The full name of the message: `horus.pb.logs.ClustererPointsOutOfRangeWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `num_points` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t num_points() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return num_points_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_num_points() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return num_points_;
  }

  /// Returns whether `num_points` (no 1) is set.
  constexpr bool has_num_points() const noexcept { return set_fields_[0]; }

  /// Clears `num_points` (no 1).
  void clear_num_points() & noexcept {
    set_fields_[0] = false;
    num_points_ = {};
  }

  /// Sets `num_points` (no 1) and returns `*this`.
  ClustererPointsOutOfRangeWarning& set_num_points(std::uint64_t num_points) & noexcept {
    set_fields_[0] = true;
    num_points_ = num_points;
    return *this;
  }
  /// Sets `num_points` (no 1) and returns `*this`.
  ClustererPointsOutOfRangeWarning&& set_num_points(std::uint64_t num_points) && noexcept {
    return std::move(set_num_points(num_points));
  }

  // Field `sample_points` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& sample_points() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return sample_points_;
  }

  /// If `sample_points` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes sample_points() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(sample_points_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_sample_points() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return sample_points_;
  }

  /// Returns whether `sample_points` (no 2) is set.
  constexpr bool has_sample_points() const noexcept { return set_fields_[1]; }

  /// Clears `sample_points` (no 2).
  void clear_sample_points() & noexcept {
    set_fields_[1] = false;
    sample_points_ = {};
  }

  /// Sets `sample_points` (no 2) and returns `*this`.
  ClustererPointsOutOfRangeWarning& set_sample_points(CowBytes&& sample_points) & noexcept {
    set_fields_[1] = true;
    sample_points_ = std::move(sample_points);
    return *this;
  }
  /// Sets `sample_points` (no 2) and returns `*this`.
  ClustererPointsOutOfRangeWarning&& set_sample_points(CowBytes&& sample_points) && noexcept {
    return std::move(set_sample_points(std::move(sample_points)));
  }

 private:
  /// @see num_points()
  std::uint64_t num_points_{};
  /// @see sample_points()
  CowBytes sample_points_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #80.
/// 
///  > An internal error occurred: $details
///
/// Source: horus/pb/logs/logs.proto:632:1
class InternalError final : public PbMessage {
 public:

  /// Constructs a default-initialized `InternalError`.
  InternalError() noexcept = default;

  /// Move constructor.
  InternalError(InternalError&&) noexcept = default;
  /// Move assignment operator.
  InternalError& operator=(InternalError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InternalError(const InternalError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InternalError& operator=(const InternalError&) = delete;

  /// Default destructor.
  ~InternalError() noexcept final = default;

  /// Creates a `InternalError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InternalError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InternalError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InternalError"; }

  /// The full name of the message: `horus.pb.logs.InternalError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  InternalError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  InternalError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #81.
/// 
///  > An internal fatal error occurred: $details
///
/// Source: horus/pb/logs/logs.proto:639:1
class InternalFatal final : public PbMessage {
 public:

  /// Constructs a default-initialized `InternalFatal`.
  InternalFatal() noexcept = default;

  /// Move constructor.
  InternalFatal(InternalFatal&&) noexcept = default;
  /// Move assignment operator.
  InternalFatal& operator=(InternalFatal&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InternalFatal(const InternalFatal& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InternalFatal& operator=(const InternalFatal&) = delete;

  /// Default destructor.
  ~InternalFatal() noexcept final = default;

  /// Creates a `InternalFatal` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InternalFatal(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InternalFatal`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InternalFatal"; }

  /// The full name of the message: `horus.pb.logs.InternalFatal`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  InternalFatal& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  InternalFatal&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #82.
/// 
///  > $service is starting
///
/// Source: horus/pb/logs/logs.proto:646:1
class ServiceStartingInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ServiceStartingInfo`.
  ServiceStartingInfo() noexcept = default;

  /// Move constructor.
  ServiceStartingInfo(ServiceStartingInfo&&) noexcept = default;
  /// Move assignment operator.
  ServiceStartingInfo& operator=(ServiceStartingInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ServiceStartingInfo(const ServiceStartingInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ServiceStartingInfo& operator=(const ServiceStartingInfo&) = delete;

  /// Default destructor.
  ~ServiceStartingInfo() noexcept final = default;

  /// Creates a `ServiceStartingInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ServiceStartingInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ServiceStartingInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ServiceStartingInfo"; }

  /// The full name of the message: `horus.pb.logs.ServiceStartingInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& service() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return service_;
  }

  /// If `service` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes service() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(service_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_service() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_;
  }

  /// Returns whether `service` (no 1) is set.
  constexpr bool has_service() const noexcept { return set_fields_[0]; }

  /// Clears `service` (no 1).
  void clear_service() & noexcept {
    set_fields_[0] = false;
    service_ = {};
  }

  /// Sets `service` (no 1) and returns `*this`.
  ServiceStartingInfo& set_service(CowBytes&& service) & noexcept {
    set_fields_[0] = true;
    service_ = std::move(service);
    return *this;
  }
  /// Sets `service` (no 1) and returns `*this`.
  ServiceStartingInfo&& set_service(CowBytes&& service) && noexcept {
    return std::move(set_service(std::move(service)));
  }

 private:
  /// @see service()
  CowBytes service_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #83.
/// 
///  > Configuration for node $node is unavailable
///
/// Source: horus/pb/logs/logs.proto:653:1
class ConfigNodeNotFoundFatal final : public PbMessage {
 public:

  /// Constructs a default-initialized `ConfigNodeNotFoundFatal`.
  ConfigNodeNotFoundFatal() noexcept = default;

  /// Move constructor.
  ConfigNodeNotFoundFatal(ConfigNodeNotFoundFatal&&) noexcept = default;
  /// Move assignment operator.
  ConfigNodeNotFoundFatal& operator=(ConfigNodeNotFoundFatal&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ConfigNodeNotFoundFatal(const ConfigNodeNotFoundFatal& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ConfigNodeNotFoundFatal& operator=(const ConfigNodeNotFoundFatal&) = delete;

  /// Default destructor.
  ~ConfigNodeNotFoundFatal() noexcept final = default;

  /// Creates a `ConfigNodeNotFoundFatal` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ConfigNodeNotFoundFatal(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ConfigNodeNotFoundFatal`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ConfigNodeNotFoundFatal"; }

  /// The full name of the message: `horus.pb.logs.ConfigNodeNotFoundFatal`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `node` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& node() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return node_;
  }

  /// If `node` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes node() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(node_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_node() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return node_;
  }

  /// Returns whether `node` (no 1) is set.
  constexpr bool has_node() const noexcept { return set_fields_[0]; }

  /// Clears `node` (no 1).
  void clear_node() & noexcept {
    set_fields_[0] = false;
    node_ = {};
  }

  /// Sets `node` (no 1) and returns `*this`.
  ConfigNodeNotFoundFatal& set_node(CowBytes&& node) & noexcept {
    set_fields_[0] = true;
    node_ = std::move(node);
    return *this;
  }
  /// Sets `node` (no 1) and returns `*this`.
  ConfigNodeNotFoundFatal&& set_node(CowBytes&& node) && noexcept {
    return std::move(set_node(std::move(node)));
  }

 private:
  /// @see node()
  CowBytes node_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #84.
/// 
///  > Failed to setup: $details
///
/// Source: horus/pb/logs/logs.proto:660:1
class ServiceSetupError final : public PbMessage {
 public:

  /// Constructs a default-initialized `ServiceSetupError`.
  ServiceSetupError() noexcept = default;

  /// Move constructor.
  ServiceSetupError(ServiceSetupError&&) noexcept = default;
  /// Move assignment operator.
  ServiceSetupError& operator=(ServiceSetupError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ServiceSetupError(const ServiceSetupError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ServiceSetupError& operator=(const ServiceSetupError&) = delete;

  /// Default destructor.
  ~ServiceSetupError() noexcept final = default;

  /// Creates a `ServiceSetupError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ServiceSetupError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ServiceSetupError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ServiceSetupError"; }

  /// The full name of the message: `horus.pb.logs.ServiceSetupError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  ServiceSetupError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  ServiceSetupError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #85.
/// 
///  > Filesystem error: $details
///
/// Source: horus/pb/logs/logs.proto:667:1
class FilesystemError final : public PbMessage {
 public:

  /// Constructs a default-initialized `FilesystemError`.
  FilesystemError() noexcept = default;

  /// Move constructor.
  FilesystemError(FilesystemError&&) noexcept = default;
  /// Move assignment operator.
  FilesystemError& operator=(FilesystemError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FilesystemError(const FilesystemError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FilesystemError& operator=(const FilesystemError&) = delete;

  /// Default destructor.
  ~FilesystemError() noexcept final = default;

  /// Creates a `FilesystemError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FilesystemError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FilesystemError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FilesystemError"; }

  /// The full name of the message: `horus.pb.logs.FilesystemError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  FilesystemError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  FilesystemError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #86.
/// 
///  > Tried to apply invalid preset $preset due to $reason, falling back to $fallback_name.
///
/// Source: horus/pb/logs/logs.proto:674:1
class InvalidPresetWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `InvalidPresetWarning`.
  InvalidPresetWarning() noexcept = default;

  /// Move constructor.
  InvalidPresetWarning(InvalidPresetWarning&&) noexcept = default;
  /// Move assignment operator.
  InvalidPresetWarning& operator=(InvalidPresetWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit InvalidPresetWarning(const InvalidPresetWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  InvalidPresetWarning& operator=(const InvalidPresetWarning&) = delete;

  /// Default destructor.
  ~InvalidPresetWarning() noexcept final = default;

  /// Creates a `InvalidPresetWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit InvalidPresetWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.InvalidPresetWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.InvalidPresetWarning"; }

  /// The full name of the message: `horus.pb.logs.InvalidPresetWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `preset` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& preset() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return preset_;
  }

  /// If `preset` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes preset() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(preset_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_preset() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return preset_;
  }

  /// Returns whether `preset` (no 1) is set.
  constexpr bool has_preset() const noexcept { return set_fields_[0]; }

  /// Clears `preset` (no 1).
  void clear_preset() & noexcept {
    set_fields_[0] = false;
    preset_ = {};
  }

  /// Sets `preset` (no 1) and returns `*this`.
  InvalidPresetWarning& set_preset(CowBytes&& preset) & noexcept {
    set_fields_[0] = true;
    preset_ = std::move(preset);
    return *this;
  }
  /// Sets `preset` (no 1) and returns `*this`.
  InvalidPresetWarning&& set_preset(CowBytes&& preset) && noexcept {
    return std::move(set_preset(std::move(preset)));
  }

  // Field `fallback_name` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& fallback_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return fallback_name_;
  }

  /// If `fallback_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes fallback_name() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(fallback_name_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_fallback_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return fallback_name_;
  }

  /// Returns whether `fallback_name` (no 2) is set.
  constexpr bool has_fallback_name() const noexcept { return set_fields_[1]; }

  /// Clears `fallback_name` (no 2).
  void clear_fallback_name() & noexcept {
    set_fields_[1] = false;
    fallback_name_ = {};
  }

  /// Sets `fallback_name` (no 2) and returns `*this`.
  InvalidPresetWarning& set_fallback_name(CowBytes&& fallback_name) & noexcept {
    set_fields_[1] = true;
    fallback_name_ = std::move(fallback_name);
    return *this;
  }
  /// Sets `fallback_name` (no 2) and returns `*this`.
  InvalidPresetWarning&& set_fallback_name(CowBytes&& fallback_name) && noexcept {
    return std::move(set_fallback_name(std::move(fallback_name)));
  }

  // Field `reason` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& reason() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return reason_;
  }

  /// If `reason` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes reason() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(reason_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_reason() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return reason_;
  }

  /// Returns whether `reason` (no 3) is set.
  constexpr bool has_reason() const noexcept { return set_fields_[2]; }

  /// Clears `reason` (no 3).
  void clear_reason() & noexcept {
    set_fields_[2] = false;
    reason_ = {};
  }

  /// Sets `reason` (no 3) and returns `*this`.
  InvalidPresetWarning& set_reason(CowBytes&& reason) & noexcept {
    set_fields_[2] = true;
    reason_ = std::move(reason);
    return *this;
  }
  /// Sets `reason` (no 3) and returns `*this`.
  InvalidPresetWarning&& set_reason(CowBytes&& reason) && noexcept {
    return std::move(set_reason(std::move(reason)));
  }

 private:
  /// @see preset()
  CowBytes preset_{};
  /// @see fallback_name()
  CowBytes fallback_name_{};
  /// @see reason()
  CowBytes reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #87.
/// 
///  > WebSocket failed to clear pending queues: $exception
///
/// Source: horus/pb/logs/logs.proto:683:1
class WebsocketFailedClearPendingError final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketFailedClearPendingError`.
  WebsocketFailedClearPendingError() noexcept = default;

  /// Move constructor.
  WebsocketFailedClearPendingError(WebsocketFailedClearPendingError&&) noexcept = default;
  /// Move assignment operator.
  WebsocketFailedClearPendingError& operator=(WebsocketFailedClearPendingError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketFailedClearPendingError(const WebsocketFailedClearPendingError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketFailedClearPendingError& operator=(const WebsocketFailedClearPendingError&) = delete;

  /// Default destructor.
  ~WebsocketFailedClearPendingError() noexcept final = default;

  /// Creates a `WebsocketFailedClearPendingError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketFailedClearPendingError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedClearPendingError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketFailedClearPendingError"; }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedClearPendingError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `exception` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& exception() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return exception_;
  }

  /// If `exception` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes exception() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(exception_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_exception() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return exception_;
  }

  /// Returns whether `exception` (no 1) is set.
  constexpr bool has_exception() const noexcept { return set_fields_[0]; }

  /// Clears `exception` (no 1).
  void clear_exception() & noexcept {
    set_fields_[0] = false;
    exception_ = {};
  }

  /// Sets `exception` (no 1) and returns `*this`.
  WebsocketFailedClearPendingError& set_exception(CowBytes&& exception) & noexcept {
    set_fields_[0] = true;
    exception_ = std::move(exception);
    return *this;
  }
  /// Sets `exception` (no 1) and returns `*this`.
  WebsocketFailedClearPendingError&& set_exception(CowBytes&& exception) && noexcept {
    return std::move(set_exception(std::move(exception)));
  }

 private:
  /// @see exception()
  CowBytes exception_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #88.
/// 
///  > WebSocket failed to stop: $exception
///
/// Source: horus/pb/logs/logs.proto:690:1
class WebsocketFailedToStopError final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketFailedToStopError`.
  WebsocketFailedToStopError() noexcept = default;

  /// Move constructor.
  WebsocketFailedToStopError(WebsocketFailedToStopError&&) noexcept = default;
  /// Move assignment operator.
  WebsocketFailedToStopError& operator=(WebsocketFailedToStopError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketFailedToStopError(const WebsocketFailedToStopError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketFailedToStopError& operator=(const WebsocketFailedToStopError&) = delete;

  /// Default destructor.
  ~WebsocketFailedToStopError() noexcept final = default;

  /// Creates a `WebsocketFailedToStopError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketFailedToStopError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedToStopError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketFailedToStopError"; }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedToStopError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `exception` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& exception() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return exception_;
  }

  /// If `exception` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes exception() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(exception_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_exception() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return exception_;
  }

  /// Returns whether `exception` (no 1) is set.
  constexpr bool has_exception() const noexcept { return set_fields_[0]; }

  /// Clears `exception` (no 1).
  void clear_exception() & noexcept {
    set_fields_[0] = false;
    exception_ = {};
  }

  /// Sets `exception` (no 1) and returns `*this`.
  WebsocketFailedToStopError& set_exception(CowBytes&& exception) & noexcept {
    set_fields_[0] = true;
    exception_ = std::move(exception);
    return *this;
  }
  /// Sets `exception` (no 1) and returns `*this`.
  WebsocketFailedToStopError&& set_exception(CowBytes&& exception) && noexcept {
    return std::move(set_exception(std::move(exception)));
  }

 private:
  /// @see exception()
  CowBytes exception_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #89.
/// 
///  > Failed to create RPC server ws://$host:$port/: $exception
///
/// Source: horus/pb/logs/logs.proto:697:1
class WebsocketFailedToCreateError final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketFailedToCreateError`.
  WebsocketFailedToCreateError() noexcept = default;

  /// Move constructor.
  WebsocketFailedToCreateError(WebsocketFailedToCreateError&&) noexcept = default;
  /// Move assignment operator.
  WebsocketFailedToCreateError& operator=(WebsocketFailedToCreateError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketFailedToCreateError(const WebsocketFailedToCreateError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketFailedToCreateError& operator=(const WebsocketFailedToCreateError&) = delete;

  /// Default destructor.
  ~WebsocketFailedToCreateError() noexcept final = default;

  /// Creates a `WebsocketFailedToCreateError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketFailedToCreateError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedToCreateError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketFailedToCreateError"; }

  /// The full name of the message: `horus.pb.logs.WebsocketFailedToCreateError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `host` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& host() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return host_;
  }

  /// If `host` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes host() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(host_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_host() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return host_;
  }

  /// Returns whether `host` (no 1) is set.
  constexpr bool has_host() const noexcept { return set_fields_[0]; }

  /// Clears `host` (no 1).
  void clear_host() & noexcept {
    set_fields_[0] = false;
    host_ = {};
  }

  /// Sets `host` (no 1) and returns `*this`.
  WebsocketFailedToCreateError& set_host(CowBytes&& host) & noexcept {
    set_fields_[0] = true;
    host_ = std::move(host);
    return *this;
  }
  /// Sets `host` (no 1) and returns `*this`.
  WebsocketFailedToCreateError&& set_host(CowBytes&& host) && noexcept {
    return std::move(set_host(std::move(host)));
  }

  // Field `port` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint32_t port() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return port_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint32_t& mutable_port() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return port_;
  }

  /// Returns whether `port` (no 2) is set.
  constexpr bool has_port() const noexcept { return set_fields_[1]; }

  /// Clears `port` (no 2).
  void clear_port() & noexcept {
    set_fields_[1] = false;
    port_ = {};
  }

  /// Sets `port` (no 2) and returns `*this`.
  WebsocketFailedToCreateError& set_port(std::uint32_t port) & noexcept {
    set_fields_[1] = true;
    port_ = port;
    return *this;
  }
  /// Sets `port` (no 2) and returns `*this`.
  WebsocketFailedToCreateError&& set_port(std::uint32_t port) && noexcept {
    return std::move(set_port(port));
  }

  // Field `exception` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& exception() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return exception_;
  }

  /// If `exception` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes exception() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(exception_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_exception() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return exception_;
  }

  /// Returns whether `exception` (no 3) is set.
  constexpr bool has_exception() const noexcept { return set_fields_[2]; }

  /// Clears `exception` (no 3).
  void clear_exception() & noexcept {
    set_fields_[2] = false;
    exception_ = {};
  }

  /// Sets `exception` (no 3) and returns `*this`.
  WebsocketFailedToCreateError& set_exception(CowBytes&& exception) & noexcept {
    set_fields_[2] = true;
    exception_ = std::move(exception);
    return *this;
  }
  /// Sets `exception` (no 3) and returns `*this`.
  WebsocketFailedToCreateError&& set_exception(CowBytes&& exception) && noexcept {
    return std::move(set_exception(std::move(exception)));
  }

 private:
  /// @see host()
  CowBytes host_{};
  /// @see port()
  std::uint32_t port_{};
  /// @see exception()
  CowBytes exception_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #90.
/// 
///  > Unexpected RPC error: $details
///
/// Source: horus/pb/logs/logs.proto:706:1
class UnexpectedRpcError final : public PbMessage {
 public:

  /// Constructs a default-initialized `UnexpectedRpcError`.
  UnexpectedRpcError() noexcept = default;

  /// Move constructor.
  UnexpectedRpcError(UnexpectedRpcError&&) noexcept = default;
  /// Move assignment operator.
  UnexpectedRpcError& operator=(UnexpectedRpcError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit UnexpectedRpcError(const UnexpectedRpcError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  UnexpectedRpcError& operator=(const UnexpectedRpcError&) = delete;

  /// Default destructor.
  ~UnexpectedRpcError() noexcept final = default;

  /// Creates a `UnexpectedRpcError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit UnexpectedRpcError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.UnexpectedRpcError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.UnexpectedRpcError"; }

  /// The full name of the message: `horus.pb.logs.UnexpectedRpcError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  UnexpectedRpcError& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  UnexpectedRpcError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #91.
/// 
///  > Failed to poll license server: $details
///
/// Source: horus/pb/logs/logs.proto:713:1
class LicensePollFailed final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicensePollFailed`.
  LicensePollFailed() noexcept = default;

  /// Move constructor.
  LicensePollFailed(LicensePollFailed&&) noexcept = default;
  /// Move assignment operator.
  LicensePollFailed& operator=(LicensePollFailed&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicensePollFailed(const LicensePollFailed& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicensePollFailed& operator=(const LicensePollFailed&) = delete;

  /// Default destructor.
  ~LicensePollFailed() noexcept final = default;

  /// Creates a `LicensePollFailed` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicensePollFailed(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicensePollFailed`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicensePollFailed"; }

  /// The full name of the message: `horus.pb.logs.LicensePollFailed`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  LicensePollFailed& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  LicensePollFailed&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #92.
/// 
///  > License expired on $expiration_time.
///
/// Source: horus/pb/logs/logs.proto:720:1
class LicenseExpiredWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseExpiredWarning`.
  LicenseExpiredWarning() noexcept = default;

  /// Move constructor.
  LicenseExpiredWarning(LicenseExpiredWarning&&) noexcept = default;
  /// Move assignment operator.
  LicenseExpiredWarning& operator=(LicenseExpiredWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseExpiredWarning(const LicenseExpiredWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseExpiredWarning& operator=(const LicenseExpiredWarning&) = delete;

  /// Default destructor.
  ~LicenseExpiredWarning() noexcept final = default;

  /// Creates a `LicenseExpiredWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseExpiredWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseExpiredWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseExpiredWarning"; }

  /// The full name of the message: `horus.pb.logs.LicenseExpiredWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `expiration_time` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& expiration_time() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return expiration_time_;
  }

  /// If `expiration_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp expiration_time() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(expiration_time_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_expiration_time() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return expiration_time_;
  }

  /// Returns whether `expiration_time` (no 1) is set.
  constexpr bool has_expiration_time() const noexcept { return set_fields_[0]; }

  /// Clears `expiration_time` (no 1).
  void clear_expiration_time() & noexcept {
    set_fields_[0] = false;
    expiration_time_ = {};
  }

  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseExpiredWarning& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) & noexcept {
    set_fields_[0] = true;
    expiration_time_ = std::move(expiration_time);
    return *this;
  }
  /// Sets `expiration_time` (no 1) and returns `*this`.
  LicenseExpiredWarning&& set_expiration_time(horus::pb::LogMetadata_Timestamp&& expiration_time) && noexcept {
    return std::move(set_expiration_time(std::move(expiration_time)));
  }

 private:
  /// @see expiration_time()
  horus::pb::LogMetadata_Timestamp expiration_time_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #93.
/// 
///  > License count of $lidar_count exceeds allowed usage of $max_lidar_count
///
/// Source: horus/pb/logs/logs.proto:727:1
class LicenseUsageExceededWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseUsageExceededWarning`.
  LicenseUsageExceededWarning() noexcept = default;

  /// Move constructor.
  LicenseUsageExceededWarning(LicenseUsageExceededWarning&&) noexcept = default;
  /// Move assignment operator.
  LicenseUsageExceededWarning& operator=(LicenseUsageExceededWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseUsageExceededWarning(const LicenseUsageExceededWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseUsageExceededWarning& operator=(const LicenseUsageExceededWarning&) = delete;

  /// Default destructor.
  ~LicenseUsageExceededWarning() noexcept final = default;

  /// Creates a `LicenseUsageExceededWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseUsageExceededWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LicenseUsageExceededWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LicenseUsageExceededWarning"; }

  /// The full name of the message: `horus.pb.logs.LicenseUsageExceededWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_count` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t lidar_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_count_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_lidar_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_count_;
  }

  /// Returns whether `lidar_count` (no 1) is set.
  constexpr bool has_lidar_count() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_count` (no 1).
  void clear_lidar_count() & noexcept {
    set_fields_[0] = false;
    lidar_count_ = {};
  }

  /// Sets `lidar_count` (no 1) and returns `*this`.
  LicenseUsageExceededWarning& set_lidar_count(std::uint64_t lidar_count) & noexcept {
    set_fields_[0] = true;
    lidar_count_ = lidar_count;
    return *this;
  }
  /// Sets `lidar_count` (no 1) and returns `*this`.
  LicenseUsageExceededWarning&& set_lidar_count(std::uint64_t lidar_count) && noexcept {
    return std::move(set_lidar_count(lidar_count));
  }

  // Field `max_lidar_count` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::int64_t max_lidar_count() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return max_lidar_count_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::int64_t& mutable_max_lidar_count() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return max_lidar_count_;
  }

  /// Returns whether `max_lidar_count` (no 2) is set.
  constexpr bool has_max_lidar_count() const noexcept { return set_fields_[1]; }

  /// Clears `max_lidar_count` (no 2).
  void clear_max_lidar_count() & noexcept {
    set_fields_[1] = false;
    max_lidar_count_ = {};
  }

  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseUsageExceededWarning& set_max_lidar_count(std::int64_t max_lidar_count) & noexcept {
    set_fields_[1] = true;
    max_lidar_count_ = max_lidar_count;
    return *this;
  }
  /// Sets `max_lidar_count` (no 2) and returns `*this`.
  LicenseUsageExceededWarning&& set_max_lidar_count(std::int64_t max_lidar_count) && noexcept {
    return std::move(set_max_lidar_count(max_lidar_count));
  }

 private:
  /// @see lidar_count()
  std::uint64_t lidar_count_{};
  /// @see max_lidar_count()
  std::int64_t max_lidar_count_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #94.
/// 
///  > ThreadPool task took $time_elapsed to complete task enqueued in $enqueue_location
///
/// Source: horus/pb/logs/logs.proto:735:1
class StaticThreadPoolSlowTaskWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `StaticThreadPoolSlowTaskWarning`.
  StaticThreadPoolSlowTaskWarning() noexcept = default;

  /// Move constructor.
  StaticThreadPoolSlowTaskWarning(StaticThreadPoolSlowTaskWarning&&) noexcept = default;
  /// Move assignment operator.
  StaticThreadPoolSlowTaskWarning& operator=(StaticThreadPoolSlowTaskWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit StaticThreadPoolSlowTaskWarning(const StaticThreadPoolSlowTaskWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  StaticThreadPoolSlowTaskWarning& operator=(const StaticThreadPoolSlowTaskWarning&) = delete;

  /// Default destructor.
  ~StaticThreadPoolSlowTaskWarning() noexcept final = default;

  /// Creates a `StaticThreadPoolSlowTaskWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit StaticThreadPoolSlowTaskWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.StaticThreadPoolSlowTaskWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.StaticThreadPoolSlowTaskWarning"; }

  /// The full name of the message: `horus.pb.logs.StaticThreadPoolSlowTaskWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `time_elapsed` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Duration& time_elapsed() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return time_elapsed_;
  }

  /// If `time_elapsed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Duration time_elapsed() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(time_elapsed_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Duration& mutable_time_elapsed() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return time_elapsed_;
  }

  /// Returns whether `time_elapsed` (no 1) is set.
  constexpr bool has_time_elapsed() const noexcept { return set_fields_[0]; }

  /// Clears `time_elapsed` (no 1).
  void clear_time_elapsed() & noexcept {
    set_fields_[0] = false;
    time_elapsed_ = {};
  }

  /// Sets `time_elapsed` (no 1) and returns `*this`.
  StaticThreadPoolSlowTaskWarning& set_time_elapsed(horus::pb::LogMetadata_Duration&& time_elapsed) & noexcept {
    set_fields_[0] = true;
    time_elapsed_ = std::move(time_elapsed);
    return *this;
  }
  /// Sets `time_elapsed` (no 1) and returns `*this`.
  StaticThreadPoolSlowTaskWarning&& set_time_elapsed(horus::pb::LogMetadata_Duration&& time_elapsed) && noexcept {
    return std::move(set_time_elapsed(std::move(time_elapsed)));
  }

  // Field `enqueue_location` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_SourceLocation& enqueue_location() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return enqueue_location_;
  }

  /// If `enqueue_location` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation enqueue_location() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(enqueue_location_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_SourceLocation& mutable_enqueue_location() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return enqueue_location_;
  }

  /// Returns whether `enqueue_location` (no 2) is set.
  constexpr bool has_enqueue_location() const noexcept { return set_fields_[1]; }

  /// Clears `enqueue_location` (no 2).
  void clear_enqueue_location() & noexcept {
    set_fields_[1] = false;
    enqueue_location_ = {};
  }

  /// Sets `enqueue_location` (no 2) and returns `*this`.
  StaticThreadPoolSlowTaskWarning& set_enqueue_location(horus::pb::LogMetadata_SourceLocation&& enqueue_location) & noexcept {
    set_fields_[1] = true;
    enqueue_location_ = std::move(enqueue_location);
    return *this;
  }
  /// Sets `enqueue_location` (no 2) and returns `*this`.
  StaticThreadPoolSlowTaskWarning&& set_enqueue_location(horus::pb::LogMetadata_SourceLocation&& enqueue_location) && noexcept {
    return std::move(set_enqueue_location(std::move(enqueue_location)));
  }

 private:
  /// @see time_elapsed()
  horus::pb::LogMetadata_Duration time_elapsed_{};
  /// @see enqueue_location()
  horus::pb::LogMetadata_SourceLocation enqueue_location_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #95.
/// 
///  > Received request for unsupported service: $service_id
///
/// Source: horus/pb/logs/logs.proto:743:1
class RpcUnsupportedServiceWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcUnsupportedServiceWarning`.
  RpcUnsupportedServiceWarning() noexcept = default;

  /// Move constructor.
  RpcUnsupportedServiceWarning(RpcUnsupportedServiceWarning&&) noexcept = default;
  /// Move assignment operator.
  RpcUnsupportedServiceWarning& operator=(RpcUnsupportedServiceWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcUnsupportedServiceWarning(const RpcUnsupportedServiceWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcUnsupportedServiceWarning& operator=(const RpcUnsupportedServiceWarning&) = delete;

  /// Default destructor.
  ~RpcUnsupportedServiceWarning() noexcept final = default;

  /// Creates a `RpcUnsupportedServiceWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcUnsupportedServiceWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcUnsupportedServiceWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcUnsupportedServiceWarning"; }

  /// The full name of the message: `horus.pb.logs.RpcUnsupportedServiceWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint32_t service_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return service_id_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_service_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_id_;
  }

  /// Returns whether `service_id` (no 1) is set.
  constexpr bool has_service_id() const noexcept { return set_fields_[0]; }

  /// Clears `service_id` (no 1).
  void clear_service_id() & noexcept {
    set_fields_[0] = false;
    service_id_ = {};
  }

  /// Sets `service_id` (no 1) and returns `*this`.
  RpcUnsupportedServiceWarning& set_service_id(std::uint32_t service_id) & noexcept {
    set_fields_[0] = true;
    service_id_ = service_id;
    return *this;
  }
  /// Sets `service_id` (no 1) and returns `*this`.
  RpcUnsupportedServiceWarning&& set_service_id(std::uint32_t service_id) && noexcept {
    return std::move(set_service_id(service_id));
  }

 private:
  /// @see service_id()
  std::uint32_t service_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #96.
/// 
///  > WebSocket RPC handler encountered an error: $what
///
/// Source: horus/pb/logs/logs.proto:750:1
class WebsocketHandlerProblem final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketHandlerProblem`.
  WebsocketHandlerProblem() noexcept = default;

  /// Move constructor.
  WebsocketHandlerProblem(WebsocketHandlerProblem&&) noexcept = default;
  /// Move assignment operator.
  WebsocketHandlerProblem& operator=(WebsocketHandlerProblem&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketHandlerProblem(const WebsocketHandlerProblem& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketHandlerProblem& operator=(const WebsocketHandlerProblem&) = delete;

  /// Default destructor.
  ~WebsocketHandlerProblem() noexcept final = default;

  /// Creates a `WebsocketHandlerProblem` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketHandlerProblem(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketHandlerProblem`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketHandlerProblem"; }

  /// The full name of the message: `horus.pb.logs.WebsocketHandlerProblem`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `what` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& what() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return what_;
  }

  /// If `what` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes what() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(what_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_what() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return what_;
  }

  /// Returns whether `what` (no 1) is set.
  constexpr bool has_what() const noexcept { return set_fields_[0]; }

  /// Clears `what` (no 1).
  void clear_what() & noexcept {
    set_fields_[0] = false;
    what_ = {};
  }

  /// Sets `what` (no 1) and returns `*this`.
  WebsocketHandlerProblem& set_what(CowBytes&& what) & noexcept {
    set_fields_[0] = true;
    what_ = std::move(what);
    return *this;
  }
  /// Sets `what` (no 1) and returns `*this`.
  WebsocketHandlerProblem&& set_what(CowBytes&& what) && noexcept {
    return std::move(set_what(std::move(what)));
  }

 private:
  /// @see what()
  CowBytes what_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #97.
/// 
///  > WebSocket RPC received message cannot be deserialized: $what
///
/// Source: horus/pb/logs/logs.proto:757:1
class WebsocketDeserializeError final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketDeserializeError`.
  WebsocketDeserializeError() noexcept = default;

  /// Move constructor.
  WebsocketDeserializeError(WebsocketDeserializeError&&) noexcept = default;
  /// Move assignment operator.
  WebsocketDeserializeError& operator=(WebsocketDeserializeError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketDeserializeError(const WebsocketDeserializeError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketDeserializeError& operator=(const WebsocketDeserializeError&) = delete;

  /// Default destructor.
  ~WebsocketDeserializeError() noexcept final = default;

  /// Creates a `WebsocketDeserializeError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketDeserializeError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketDeserializeError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketDeserializeError"; }

  /// The full name of the message: `horus.pb.logs.WebsocketDeserializeError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `what` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& what() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return what_;
  }

  /// If `what` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes what() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(what_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_what() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return what_;
  }

  /// Returns whether `what` (no 1) is set.
  constexpr bool has_what() const noexcept { return set_fields_[0]; }

  /// Clears `what` (no 1).
  void clear_what() & noexcept {
    set_fields_[0] = false;
    what_ = {};
  }

  /// Sets `what` (no 1) and returns `*this`.
  WebsocketDeserializeError& set_what(CowBytes&& what) & noexcept {
    set_fields_[0] = true;
    what_ = std::move(what);
    return *this;
  }
  /// Sets `what` (no 1) and returns `*this`.
  WebsocketDeserializeError&& set_what(CowBytes&& what) && noexcept {
    return std::move(set_what(std::move(what)));
  }

 private:
  /// @see what()
  CowBytes what_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #98.
/// 
///  > Attempting to access expired WebSocket RPC endpoint $uri
///
/// Source: horus/pb/logs/logs.proto:764:1
class WebsocketExpiredRpcEndpointError final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketExpiredRpcEndpointError`.
  WebsocketExpiredRpcEndpointError() noexcept = default;

  /// Move constructor.
  WebsocketExpiredRpcEndpointError(WebsocketExpiredRpcEndpointError&&) noexcept = default;
  /// Move assignment operator.
  WebsocketExpiredRpcEndpointError& operator=(WebsocketExpiredRpcEndpointError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketExpiredRpcEndpointError(const WebsocketExpiredRpcEndpointError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketExpiredRpcEndpointError& operator=(const WebsocketExpiredRpcEndpointError&) = delete;

  /// Default destructor.
  ~WebsocketExpiredRpcEndpointError() noexcept final = default;

  /// Creates a `WebsocketExpiredRpcEndpointError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketExpiredRpcEndpointError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketExpiredRpcEndpointError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketExpiredRpcEndpointError"; }

  /// The full name of the message: `horus.pb.logs.WebsocketExpiredRpcEndpointError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `uri` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return uri_;
  }

  /// If `uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes uri() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(uri_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return uri_;
  }

  /// Returns whether `uri` (no 1) is set.
  constexpr bool has_uri() const noexcept { return set_fields_[0]; }

  /// Clears `uri` (no 1).
  void clear_uri() & noexcept {
    set_fields_[0] = false;
    uri_ = {};
  }

  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketExpiredRpcEndpointError& set_uri(CowBytes&& uri) & noexcept {
    set_fields_[0] = true;
    uri_ = std::move(uri);
    return *this;
  }
  /// Sets `uri` (no 1) and returns `*this`.
  WebsocketExpiredRpcEndpointError&& set_uri(CowBytes&& uri) && noexcept {
    return std::move(set_uri(std::move(uri)));
  }

 private:
  /// @see uri()
  CowBytes uri_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #99.
/// 
///  > Websocket message queue overloaded: $current / $max
///
/// Source: horus/pb/logs/logs.proto:771:1
class WebsocketQueueOverloadedWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `WebsocketQueueOverloadedWarning`.
  WebsocketQueueOverloadedWarning() noexcept = default;

  /// Move constructor.
  WebsocketQueueOverloadedWarning(WebsocketQueueOverloadedWarning&&) noexcept = default;
  /// Move assignment operator.
  WebsocketQueueOverloadedWarning& operator=(WebsocketQueueOverloadedWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit WebsocketQueueOverloadedWarning(const WebsocketQueueOverloadedWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  WebsocketQueueOverloadedWarning& operator=(const WebsocketQueueOverloadedWarning&) = delete;

  /// Default destructor.
  ~WebsocketQueueOverloadedWarning() noexcept final = default;

  /// Creates a `WebsocketQueueOverloadedWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit WebsocketQueueOverloadedWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.WebsocketQueueOverloadedWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.WebsocketQueueOverloadedWarning"; }

  /// The full name of the message: `horus.pb.logs.WebsocketQueueOverloadedWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `current` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t current() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return current_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_current() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return current_;
  }

  /// Returns whether `current` (no 1) is set.
  constexpr bool has_current() const noexcept { return set_fields_[0]; }

  /// Clears `current` (no 1).
  void clear_current() & noexcept {
    set_fields_[0] = false;
    current_ = {};
  }

  /// Sets `current` (no 1) and returns `*this`.
  WebsocketQueueOverloadedWarning& set_current(std::uint64_t current) & noexcept {
    set_fields_[0] = true;
    current_ = current;
    return *this;
  }
  /// Sets `current` (no 1) and returns `*this`.
  WebsocketQueueOverloadedWarning&& set_current(std::uint64_t current) && noexcept {
    return std::move(set_current(current));
  }

  // Field `max` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint64_t max() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return max_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint64_t& mutable_max() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return max_;
  }

  /// Returns whether `max` (no 2) is set.
  constexpr bool has_max() const noexcept { return set_fields_[1]; }

  /// Clears `max` (no 2).
  void clear_max() & noexcept {
    set_fields_[1] = false;
    max_ = {};
  }

  /// Sets `max` (no 2) and returns `*this`.
  WebsocketQueueOverloadedWarning& set_max(std::uint64_t max) & noexcept {
    set_fields_[1] = true;
    max_ = max;
    return *this;
  }
  /// Sets `max` (no 2) and returns `*this`.
  WebsocketQueueOverloadedWarning&& set_max(std::uint64_t max) && noexcept {
    return std::move(set_max(max));
  }

 private:
  /// @see current()
  std::uint64_t current_{};
  /// @see max()
  std::uint64_t max_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #100.
/// 
///  > Could not notify $notification_name to $service $uri: $what
///
/// Source: horus/pb/logs/logs.proto:779:1
class RpcFailedToNotifyWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcFailedToNotifyWarning`.
  RpcFailedToNotifyWarning() noexcept = default;

  /// Move constructor.
  RpcFailedToNotifyWarning(RpcFailedToNotifyWarning&&) noexcept = default;
  /// Move assignment operator.
  RpcFailedToNotifyWarning& operator=(RpcFailedToNotifyWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcFailedToNotifyWarning(const RpcFailedToNotifyWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcFailedToNotifyWarning& operator=(const RpcFailedToNotifyWarning&) = delete;

  /// Default destructor.
  ~RpcFailedToNotifyWarning() noexcept final = default;

  /// Creates a `RpcFailedToNotifyWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcFailedToNotifyWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcFailedToNotifyWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcFailedToNotifyWarning"; }

  /// The full name of the message: `horus.pb.logs.RpcFailedToNotifyWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& service() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return service_;
  }

  /// If `service` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes service() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(service_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_service() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_;
  }

  /// Returns whether `service` (no 1) is set.
  constexpr bool has_service() const noexcept { return set_fields_[0]; }

  /// Clears `service` (no 1).
  void clear_service() & noexcept {
    set_fields_[0] = false;
    service_ = {};
  }

  /// Sets `service` (no 1) and returns `*this`.
  RpcFailedToNotifyWarning& set_service(CowBytes&& service) & noexcept {
    set_fields_[0] = true;
    service_ = std::move(service);
    return *this;
  }
  /// Sets `service` (no 1) and returns `*this`.
  RpcFailedToNotifyWarning&& set_service(CowBytes&& service) && noexcept {
    return std::move(set_service(std::move(service)));
  }

  // Field `uri` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& uri() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return uri_;
  }

  /// If `uri` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes uri() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(uri_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_uri() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return uri_;
  }

  /// Returns whether `uri` (no 2) is set.
  constexpr bool has_uri() const noexcept { return set_fields_[1]; }

  /// Clears `uri` (no 2).
  void clear_uri() & noexcept {
    set_fields_[1] = false;
    uri_ = {};
  }

  /// Sets `uri` (no 2) and returns `*this`.
  RpcFailedToNotifyWarning& set_uri(CowBytes&& uri) & noexcept {
    set_fields_[1] = true;
    uri_ = std::move(uri);
    return *this;
  }
  /// Sets `uri` (no 2) and returns `*this`.
  RpcFailedToNotifyWarning&& set_uri(CowBytes&& uri) && noexcept {
    return std::move(set_uri(std::move(uri)));
  }

  // Field `notification_name` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& notification_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return notification_name_;
  }

  /// If `notification_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes notification_name() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(notification_name_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_notification_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return notification_name_;
  }

  /// Returns whether `notification_name` (no 3) is set.
  constexpr bool has_notification_name() const noexcept { return set_fields_[2]; }

  /// Clears `notification_name` (no 3).
  void clear_notification_name() & noexcept {
    set_fields_[2] = false;
    notification_name_ = {};
  }

  /// Sets `notification_name` (no 3) and returns `*this`.
  RpcFailedToNotifyWarning& set_notification_name(CowBytes&& notification_name) & noexcept {
    set_fields_[2] = true;
    notification_name_ = std::move(notification_name);
    return *this;
  }
  /// Sets `notification_name` (no 3) and returns `*this`.
  RpcFailedToNotifyWarning&& set_notification_name(CowBytes&& notification_name) && noexcept {
    return std::move(set_notification_name(std::move(notification_name)));
  }

  // Field `what` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const CowBytes& what() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return what_;
  }

  /// If `what` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  CowBytes what() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(what_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  CowBytes& mutable_what() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[3] = true;
    return what_;
  }

  /// Returns whether `what` (no 4) is set.
  constexpr bool has_what() const noexcept { return set_fields_[3]; }

  /// Clears `what` (no 4).
  void clear_what() & noexcept {
    set_fields_[3] = false;
    what_ = {};
  }

  /// Sets `what` (no 4) and returns `*this`.
  RpcFailedToNotifyWarning& set_what(CowBytes&& what) & noexcept {
    set_fields_[3] = true;
    what_ = std::move(what);
    return *this;
  }
  /// Sets `what` (no 4) and returns `*this`.
  RpcFailedToNotifyWarning&& set_what(CowBytes&& what) && noexcept {
    return std::move(set_what(std::move(what)));
  }

 private:
  /// @see service()
  CowBytes service_{};
  /// @see uri()
  CowBytes uri_{};
  /// @see notification_name()
  CowBytes notification_name_{};
  /// @see what()
  CowBytes what_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// Log #101.
/// 
///  > Failed to subscribe to config: $details
///
/// Source: horus/pb/logs/logs.proto:789:1
class ConfigSubscriptionFailedWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ConfigSubscriptionFailedWarning`.
  ConfigSubscriptionFailedWarning() noexcept = default;

  /// Move constructor.
  ConfigSubscriptionFailedWarning(ConfigSubscriptionFailedWarning&&) noexcept = default;
  /// Move assignment operator.
  ConfigSubscriptionFailedWarning& operator=(ConfigSubscriptionFailedWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ConfigSubscriptionFailedWarning(const ConfigSubscriptionFailedWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ConfigSubscriptionFailedWarning& operator=(const ConfigSubscriptionFailedWarning&) = delete;

  /// Default destructor.
  ~ConfigSubscriptionFailedWarning() noexcept final = default;

  /// Creates a `ConfigSubscriptionFailedWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ConfigSubscriptionFailedWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ConfigSubscriptionFailedWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ConfigSubscriptionFailedWarning"; }

  /// The full name of the message: `horus.pb.logs.ConfigSubscriptionFailedWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  ConfigSubscriptionFailedWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  ConfigSubscriptionFailedWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #102.
/// 
///  > Clamped thread pool workers to $clamped instead of $requested
///
/// Source: horus/pb/logs/logs.proto:796:1
class ThreadPoolClampedWorkersWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ThreadPoolClampedWorkersWarning`.
  ThreadPoolClampedWorkersWarning() noexcept = default;

  /// Move constructor.
  ThreadPoolClampedWorkersWarning(ThreadPoolClampedWorkersWarning&&) noexcept = default;
  /// Move assignment operator.
  ThreadPoolClampedWorkersWarning& operator=(ThreadPoolClampedWorkersWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ThreadPoolClampedWorkersWarning(const ThreadPoolClampedWorkersWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ThreadPoolClampedWorkersWarning& operator=(const ThreadPoolClampedWorkersWarning&) = delete;

  /// Default destructor.
  ~ThreadPoolClampedWorkersWarning() noexcept final = default;

  /// Creates a `ThreadPoolClampedWorkersWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ThreadPoolClampedWorkersWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ThreadPoolClampedWorkersWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ThreadPoolClampedWorkersWarning"; }

  /// The full name of the message: `horus.pb.logs.ThreadPoolClampedWorkersWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `clamped` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t clamped() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return clamped_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_clamped() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return clamped_;
  }

  /// Returns whether `clamped` (no 1) is set.
  constexpr bool has_clamped() const noexcept { return set_fields_[0]; }

  /// Clears `clamped` (no 1).
  void clear_clamped() & noexcept {
    set_fields_[0] = false;
    clamped_ = {};
  }

  /// Sets `clamped` (no 1) and returns `*this`.
  ThreadPoolClampedWorkersWarning& set_clamped(std::uint64_t clamped) & noexcept {
    set_fields_[0] = true;
    clamped_ = clamped;
    return *this;
  }
  /// Sets `clamped` (no 1) and returns `*this`.
  ThreadPoolClampedWorkersWarning&& set_clamped(std::uint64_t clamped) && noexcept {
    return std::move(set_clamped(clamped));
  }

  // Field `requested` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint64_t requested() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return requested_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint64_t& mutable_requested() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return requested_;
  }

  /// Returns whether `requested` (no 2) is set.
  constexpr bool has_requested() const noexcept { return set_fields_[1]; }

  /// Clears `requested` (no 2).
  void clear_requested() & noexcept {
    set_fields_[1] = false;
    requested_ = {};
  }

  /// Sets `requested` (no 2) and returns `*this`.
  ThreadPoolClampedWorkersWarning& set_requested(std::uint64_t requested) & noexcept {
    set_fields_[1] = true;
    requested_ = requested;
    return *this;
  }
  /// Sets `requested` (no 2) and returns `*this`.
  ThreadPoolClampedWorkersWarning&& set_requested(std::uint64_t requested) && noexcept {
    return std::move(set_requested(requested));
  }

 private:
  /// @see clamped()
  std::uint64_t clamped_{};
  /// @see requested()
  std::uint64_t requested_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #103.
/// 
///  > Trying to stop the Horus bag recorder which is already stopped.
///
/// Source: horus/pb/logs/logs.proto:804:1
class StoppingHorusBagRecorderAlreadyStopped final : public PbMessage {
 public:

  /// Constructs a default-initialized `StoppingHorusBagRecorderAlreadyStopped`.
  StoppingHorusBagRecorderAlreadyStopped() noexcept = default;

  /// Move constructor.
  StoppingHorusBagRecorderAlreadyStopped(StoppingHorusBagRecorderAlreadyStopped&&) noexcept = default;
  /// Move assignment operator.
  StoppingHorusBagRecorderAlreadyStopped& operator=(StoppingHorusBagRecorderAlreadyStopped&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit StoppingHorusBagRecorderAlreadyStopped(const StoppingHorusBagRecorderAlreadyStopped&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  StoppingHorusBagRecorderAlreadyStopped& operator=(const StoppingHorusBagRecorderAlreadyStopped&) = delete;

  /// Default destructor.
  ~StoppingHorusBagRecorderAlreadyStopped() noexcept final = default;

  /// Creates a `StoppingHorusBagRecorderAlreadyStopped` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit StoppingHorusBagRecorderAlreadyStopped(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.StoppingHorusBagRecorderAlreadyStopped`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.StoppingHorusBagRecorderAlreadyStopped"; }

  /// The full name of the message: `horus.pb.logs.StoppingHorusBagRecorderAlreadyStopped`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #104.
/// 
///  > An update for the Horus bag recorder has been received while it was running. This update will not be taken into account until the next recording.
///
/// Source: horus/pb/logs/logs.proto:810:1
class RecorderConfigUpdateWhileRunning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RecorderConfigUpdateWhileRunning`.
  RecorderConfigUpdateWhileRunning() noexcept = default;

  /// Move constructor.
  RecorderConfigUpdateWhileRunning(RecorderConfigUpdateWhileRunning&&) noexcept = default;
  /// Move assignment operator.
  RecorderConfigUpdateWhileRunning& operator=(RecorderConfigUpdateWhileRunning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RecorderConfigUpdateWhileRunning(const RecorderConfigUpdateWhileRunning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RecorderConfigUpdateWhileRunning& operator=(const RecorderConfigUpdateWhileRunning&) = delete;

  /// Default destructor.
  ~RecorderConfigUpdateWhileRunning() noexcept final = default;

  /// Creates a `RecorderConfigUpdateWhileRunning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RecorderConfigUpdateWhileRunning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RecorderConfigUpdateWhileRunning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RecorderConfigUpdateWhileRunning"; }

  /// The full name of the message: `horus.pb.logs.RecorderConfigUpdateWhileRunning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #105.
/// 
///  > Clamping point cloud: $details
///
/// Source: horus/pb/logs/logs.proto:816:1
class ClampingDataWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ClampingDataWarning`.
  ClampingDataWarning() noexcept = default;

  /// Move constructor.
  ClampingDataWarning(ClampingDataWarning&&) noexcept = default;
  /// Move assignment operator.
  ClampingDataWarning& operator=(ClampingDataWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ClampingDataWarning(const ClampingDataWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ClampingDataWarning& operator=(const ClampingDataWarning&) = delete;

  /// Default destructor.
  ~ClampingDataWarning() noexcept final = default;

  /// Creates a `ClampingDataWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ClampingDataWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ClampingDataWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ClampingDataWarning"; }

  /// The full name of the message: `horus.pb.logs.ClampingDataWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  ClampingDataWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  ClampingDataWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #106.
/// 
///  > Lidars $lidar_ip1 and $lidar_ip2 have incompatible $value_names: $value1 vs. $value2; $resolution.
///
/// Source: horus/pb/logs/logs.proto:823:1
class LidarIncompatibleValues final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarIncompatibleValues`.
  LidarIncompatibleValues() noexcept = default;

  /// Move constructor.
  LidarIncompatibleValues(LidarIncompatibleValues&&) noexcept = default;
  /// Move assignment operator.
  LidarIncompatibleValues& operator=(LidarIncompatibleValues&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarIncompatibleValues(const LidarIncompatibleValues& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarIncompatibleValues& operator=(const LidarIncompatibleValues&) = delete;

  /// Default destructor.
  ~LidarIncompatibleValues() noexcept final = default;

  /// Creates a `LidarIncompatibleValues` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarIncompatibleValues(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarIncompatibleValues`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarIncompatibleValues"; }

  /// The full name of the message: `horus.pb.logs.LidarIncompatibleValues`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_ip1` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_ip1() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_ip1_;
  }

  /// If `lidar_ip1` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_ip1() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_ip1_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_ip1() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_ip1_;
  }

  /// Returns whether `lidar_ip1` (no 1) is set.
  constexpr bool has_lidar_ip1() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_ip1` (no 1).
  void clear_lidar_ip1() & noexcept {
    set_fields_[0] = false;
    lidar_ip1_ = {};
  }

  /// Sets `lidar_ip1` (no 1) and returns `*this`.
  LidarIncompatibleValues& set_lidar_ip1(CowBytes&& lidar_ip1) & noexcept {
    set_fields_[0] = true;
    lidar_ip1_ = std::move(lidar_ip1);
    return *this;
  }
  /// Sets `lidar_ip1` (no 1) and returns `*this`.
  LidarIncompatibleValues&& set_lidar_ip1(CowBytes&& lidar_ip1) && noexcept {
    return std::move(set_lidar_ip1(std::move(lidar_ip1)));
  }

  // Field `lidar_ip2` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& lidar_ip2() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_ip2_;
  }

  /// If `lidar_ip2` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes lidar_ip2() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(lidar_ip2_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_lidar_ip2() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return lidar_ip2_;
  }

  /// Returns whether `lidar_ip2` (no 2) is set.
  constexpr bool has_lidar_ip2() const noexcept { return set_fields_[1]; }

  /// Clears `lidar_ip2` (no 2).
  void clear_lidar_ip2() & noexcept {
    set_fields_[1] = false;
    lidar_ip2_ = {};
  }

  /// Sets `lidar_ip2` (no 2) and returns `*this`.
  LidarIncompatibleValues& set_lidar_ip2(CowBytes&& lidar_ip2) & noexcept {
    set_fields_[1] = true;
    lidar_ip2_ = std::move(lidar_ip2);
    return *this;
  }
  /// Sets `lidar_ip2` (no 2) and returns `*this`.
  LidarIncompatibleValues&& set_lidar_ip2(CowBytes&& lidar_ip2) && noexcept {
    return std::move(set_lidar_ip2(std::move(lidar_ip2)));
  }

  // Field `value1` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& value1() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return value1_;
  }

  /// If `value1` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes value1() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(value1_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_value1() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return value1_;
  }

  /// Returns whether `value1` (no 3) is set.
  constexpr bool has_value1() const noexcept { return set_fields_[2]; }

  /// Clears `value1` (no 3).
  void clear_value1() & noexcept {
    set_fields_[2] = false;
    value1_ = {};
  }

  /// Sets `value1` (no 3) and returns `*this`.
  LidarIncompatibleValues& set_value1(CowBytes&& value1) & noexcept {
    set_fields_[2] = true;
    value1_ = std::move(value1);
    return *this;
  }
  /// Sets `value1` (no 3) and returns `*this`.
  LidarIncompatibleValues&& set_value1(CowBytes&& value1) && noexcept {
    return std::move(set_value1(std::move(value1)));
  }

  // Field `value2` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const CowBytes& value2() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return value2_;
  }

  /// If `value2` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  CowBytes value2() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(value2_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  CowBytes& mutable_value2() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[3] = true;
    return value2_;
  }

  /// Returns whether `value2` (no 4) is set.
  constexpr bool has_value2() const noexcept { return set_fields_[3]; }

  /// Clears `value2` (no 4).
  void clear_value2() & noexcept {
    set_fields_[3] = false;
    value2_ = {};
  }

  /// Sets `value2` (no 4) and returns `*this`.
  LidarIncompatibleValues& set_value2(CowBytes&& value2) & noexcept {
    set_fields_[3] = true;
    value2_ = std::move(value2);
    return *this;
  }
  /// Sets `value2` (no 4) and returns `*this`.
  LidarIncompatibleValues&& set_value2(CowBytes&& value2) && noexcept {
    return std::move(set_value2(std::move(value2)));
  }

  // Field `value_names` (no 5).
  // -----

  /// No documentation.
  ///
  /// Field no: 5.
  constexpr const CowBytes& value_names() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return value_names_;
  }

  /// If `value_names` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 5.
  CowBytes value_names() && noexcept {
    if (!set_fields_[4]) {
      return {};
    }
    return std::move(value_names_);
  }

  /// No documentation.
  ///
  /// Field no: 5.
  CowBytes& mutable_value_names() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[4] = true;
    return value_names_;
  }

  /// Returns whether `value_names` (no 5) is set.
  constexpr bool has_value_names() const noexcept { return set_fields_[4]; }

  /// Clears `value_names` (no 5).
  void clear_value_names() & noexcept {
    set_fields_[4] = false;
    value_names_ = {};
  }

  /// Sets `value_names` (no 5) and returns `*this`.
  LidarIncompatibleValues& set_value_names(CowBytes&& value_names) & noexcept {
    set_fields_[4] = true;
    value_names_ = std::move(value_names);
    return *this;
  }
  /// Sets `value_names` (no 5) and returns `*this`.
  LidarIncompatibleValues&& set_value_names(CowBytes&& value_names) && noexcept {
    return std::move(set_value_names(std::move(value_names)));
  }

  // Field `resolution` (no 6).
  // -----

  /// No documentation.
  ///
  /// Field no: 6.
  constexpr const CowBytes& resolution() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return resolution_;
  }

  /// If `resolution` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 6.
  CowBytes resolution() && noexcept {
    if (!set_fields_[5]) {
      return {};
    }
    return std::move(resolution_);
  }

  /// No documentation.
  ///
  /// Field no: 6.
  CowBytes& mutable_resolution() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[5] = true;
    return resolution_;
  }

  /// Returns whether `resolution` (no 6) is set.
  constexpr bool has_resolution() const noexcept { return set_fields_[5]; }

  /// Clears `resolution` (no 6).
  void clear_resolution() & noexcept {
    set_fields_[5] = false;
    resolution_ = {};
  }

  /// Sets `resolution` (no 6) and returns `*this`.
  LidarIncompatibleValues& set_resolution(CowBytes&& resolution) & noexcept {
    set_fields_[5] = true;
    resolution_ = std::move(resolution);
    return *this;
  }
  /// Sets `resolution` (no 6) and returns `*this`.
  LidarIncompatibleValues&& set_resolution(CowBytes&& resolution) && noexcept {
    return std::move(set_resolution(std::move(resolution)));
  }

 private:
  /// @see lidar_ip1()
  CowBytes lidar_ip1_{};
  /// @see lidar_ip2()
  CowBytes lidar_ip2_{};
  /// @see value1()
  CowBytes value1_{};
  /// @see value2()
  CowBytes value2_{};
  /// @see value_names()
  CowBytes value_names_{};
  /// @see resolution()
  CowBytes resolution_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<6> set_fields_;
};

/// Log #107.
/// 
///  > Cannot determine current Docker container ID; unknown $container_id_file_path format.
///
/// Source: horus/pb/logs/logs.proto:835:1
class CannotDetermineContainerIdError final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotDetermineContainerIdError`.
  CannotDetermineContainerIdError() noexcept = default;

  /// Move constructor.
  CannotDetermineContainerIdError(CannotDetermineContainerIdError&&) noexcept = default;
  /// Move assignment operator.
  CannotDetermineContainerIdError& operator=(CannotDetermineContainerIdError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotDetermineContainerIdError(const CannotDetermineContainerIdError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotDetermineContainerIdError& operator=(const CannotDetermineContainerIdError&) = delete;

  /// Default destructor.
  ~CannotDetermineContainerIdError() noexcept final = default;

  /// Creates a `CannotDetermineContainerIdError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotDetermineContainerIdError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotDetermineContainerIdError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotDetermineContainerIdError"; }

  /// The full name of the message: `horus.pb.logs.CannotDetermineContainerIdError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `container_id_file_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& container_id_file_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return container_id_file_path_;
  }

  /// If `container_id_file_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes container_id_file_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(container_id_file_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_container_id_file_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return container_id_file_path_;
  }

  /// Returns whether `container_id_file_path` (no 1) is set.
  constexpr bool has_container_id_file_path() const noexcept { return set_fields_[0]; }

  /// Clears `container_id_file_path` (no 1).
  void clear_container_id_file_path() & noexcept {
    set_fields_[0] = false;
    container_id_file_path_ = {};
  }

  /// Sets `container_id_file_path` (no 1) and returns `*this`.
  CannotDetermineContainerIdError& set_container_id_file_path(CowBytes&& container_id_file_path) & noexcept {
    set_fields_[0] = true;
    container_id_file_path_ = std::move(container_id_file_path);
    return *this;
  }
  /// Sets `container_id_file_path` (no 1) and returns `*this`.
  CannotDetermineContainerIdError&& set_container_id_file_path(CowBytes&& container_id_file_path) && noexcept {
    return std::move(set_container_id_file_path(std::move(container_id_file_path)));
  }

 private:
  /// @see container_id_file_path()
  CowBytes container_id_file_path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #108.
/// 
///  > Started lidar driver container $lidar_id.
///
/// Source: horus/pb/logs/logs.proto:842:1
class StartedLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `StartedLidarDriver`.
  StartedLidarDriver() noexcept = default;

  /// Move constructor.
  StartedLidarDriver(StartedLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  StartedLidarDriver& operator=(StartedLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit StartedLidarDriver(const StartedLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  StartedLidarDriver& operator=(const StartedLidarDriver&) = delete;

  /// Default destructor.
  ~StartedLidarDriver() noexcept final = default;

  /// Creates a `StartedLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit StartedLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.StartedLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.StartedLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.StartedLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  StartedLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  StartedLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #109.
/// 
///  > Cannot start lidar driver container $lidar_id: $details.
///
/// Source: horus/pb/logs/logs.proto:849:1
class CannotStartLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotStartLidarDriver`.
  CannotStartLidarDriver() noexcept = default;

  /// Move constructor.
  CannotStartLidarDriver(CannotStartLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  CannotStartLidarDriver& operator=(CannotStartLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotStartLidarDriver(const CannotStartLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotStartLidarDriver& operator=(const CannotStartLidarDriver&) = delete;

  /// Default destructor.
  ~CannotStartLidarDriver() noexcept final = default;

  /// Creates a `CannotStartLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotStartLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotStartLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotStartLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.CannotStartLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotStartLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotStartLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  CannotStartLidarDriver& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  CannotStartLidarDriver&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #110.
/// 
///  > Stopped lidar driver container $lidar_id.
///
/// Source: horus/pb/logs/logs.proto:857:1
class StoppedLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `StoppedLidarDriver`.
  StoppedLidarDriver() noexcept = default;

  /// Move constructor.
  StoppedLidarDriver(StoppedLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  StoppedLidarDriver& operator=(StoppedLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit StoppedLidarDriver(const StoppedLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  StoppedLidarDriver& operator=(const StoppedLidarDriver&) = delete;

  /// Default destructor.
  ~StoppedLidarDriver() noexcept final = default;

  /// Creates a `StoppedLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit StoppedLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.StoppedLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.StoppedLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.StoppedLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  StoppedLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  StoppedLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #111.
/// 
///  > Cannot stop lidar driver container $lidar_id: $details.
///
/// Source: horus/pb/logs/logs.proto:864:1
class CannotStopLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotStopLidarDriver`.
  CannotStopLidarDriver() noexcept = default;

  /// Move constructor.
  CannotStopLidarDriver(CannotStopLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  CannotStopLidarDriver& operator=(CannotStopLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotStopLidarDriver(const CannotStopLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotStopLidarDriver& operator=(const CannotStopLidarDriver&) = delete;

  /// Default destructor.
  ~CannotStopLidarDriver() noexcept final = default;

  /// Creates a `CannotStopLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotStopLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotStopLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotStopLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.CannotStopLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotStopLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotStopLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  CannotStopLidarDriver& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  CannotStopLidarDriver&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #112.
/// 
///  > Restarted lidar driver container $lidar_id.
///
/// Source: horus/pb/logs/logs.proto:872:1
class RestartedLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `RestartedLidarDriver`.
  RestartedLidarDriver() noexcept = default;

  /// Move constructor.
  RestartedLidarDriver(RestartedLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  RestartedLidarDriver& operator=(RestartedLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RestartedLidarDriver(const RestartedLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RestartedLidarDriver& operator=(const RestartedLidarDriver&) = delete;

  /// Default destructor.
  ~RestartedLidarDriver() noexcept final = default;

  /// Creates a `RestartedLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RestartedLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RestartedLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RestartedLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.RestartedLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  RestartedLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  RestartedLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #113.
/// 
///  > Cannot restart lidar driver container $lidar_id: $details.
///
/// Source: horus/pb/logs/logs.proto:879:1
class CannotRestartLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotRestartLidarDriver`.
  CannotRestartLidarDriver() noexcept = default;

  /// Move constructor.
  CannotRestartLidarDriver(CannotRestartLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  CannotRestartLidarDriver& operator=(CannotRestartLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotRestartLidarDriver(const CannotRestartLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotRestartLidarDriver& operator=(const CannotRestartLidarDriver&) = delete;

  /// Default destructor.
  ~CannotRestartLidarDriver() noexcept final = default;

  /// Creates a `CannotRestartLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotRestartLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotRestartLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotRestartLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.CannotRestartLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotRestartLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotRestartLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  CannotRestartLidarDriver& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  CannotRestartLidarDriver&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #114.
/// 
///  > Removed unused lidar driver container $lidar_id.
///
/// Source: horus/pb/logs/logs.proto:887:1
class RemovedUnusedLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `RemovedUnusedLidarDriver`.
  RemovedUnusedLidarDriver() noexcept = default;

  /// Move constructor.
  RemovedUnusedLidarDriver(RemovedUnusedLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  RemovedUnusedLidarDriver& operator=(RemovedUnusedLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RemovedUnusedLidarDriver(const RemovedUnusedLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RemovedUnusedLidarDriver& operator=(const RemovedUnusedLidarDriver&) = delete;

  /// Default destructor.
  ~RemovedUnusedLidarDriver() noexcept final = default;

  /// Creates a `RemovedUnusedLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RemovedUnusedLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RemovedUnusedLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RemovedUnusedLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.RemovedUnusedLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  RemovedUnusedLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  RemovedUnusedLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #115.
/// 
///  > Cannot remove unused lidar driver container $lidar_id: $details.
///
/// Source: horus/pb/logs/logs.proto:894:1
class CannotRemoveUnusedLidarDriver final : public PbMessage {
 public:

  /// Constructs a default-initialized `CannotRemoveUnusedLidarDriver`.
  CannotRemoveUnusedLidarDriver() noexcept = default;

  /// Move constructor.
  CannotRemoveUnusedLidarDriver(CannotRemoveUnusedLidarDriver&&) noexcept = default;
  /// Move assignment operator.
  CannotRemoveUnusedLidarDriver& operator=(CannotRemoveUnusedLidarDriver&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CannotRemoveUnusedLidarDriver(const CannotRemoveUnusedLidarDriver& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CannotRemoveUnusedLidarDriver& operator=(const CannotRemoveUnusedLidarDriver&) = delete;

  /// Default destructor.
  ~CannotRemoveUnusedLidarDriver() noexcept final = default;

  /// Creates a `CannotRemoveUnusedLidarDriver` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CannotRemoveUnusedLidarDriver(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CannotRemoveUnusedLidarDriver`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CannotRemoveUnusedLidarDriver"; }

  /// The full name of the message: `horus.pb.logs.CannotRemoveUnusedLidarDriver`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotRemoveUnusedLidarDriver& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  CannotRemoveUnusedLidarDriver&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  CannotRemoveUnusedLidarDriver& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  CannotRemoveUnusedLidarDriver&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #116.
/// 
///  > Error encountered while removing unused lidar driver containers: $details.
///
/// Source: horus/pb/logs/logs.proto:902:1
class LidarDriverGcFailure final : public PbMessage {
 public:

  /// Constructs a default-initialized `LidarDriverGcFailure`.
  LidarDriverGcFailure() noexcept = default;

  /// Move constructor.
  LidarDriverGcFailure(LidarDriverGcFailure&&) noexcept = default;
  /// Move assignment operator.
  LidarDriverGcFailure& operator=(LidarDriverGcFailure&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LidarDriverGcFailure(const LidarDriverGcFailure& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LidarDriverGcFailure& operator=(const LidarDriverGcFailure&) = delete;

  /// Default destructor.
  ~LidarDriverGcFailure() noexcept final = default;

  /// Creates a `LidarDriverGcFailure` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LidarDriverGcFailure(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LidarDriverGcFailure`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LidarDriverGcFailure"; }

  /// The full name of the message: `horus.pb.logs.LidarDriverGcFailure`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  LidarDriverGcFailure& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  LidarDriverGcFailure&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #117.
/// 
///  > Cannot allocate new identifier with prefix "$prefix".
///
/// Source: horus/pb/logs/logs.proto:909:1
class IdSpaceExhausted final : public PbMessage {
 public:

  /// Constructs a default-initialized `IdSpaceExhausted`.
  IdSpaceExhausted() noexcept = default;

  /// Move constructor.
  IdSpaceExhausted(IdSpaceExhausted&&) noexcept = default;
  /// Move assignment operator.
  IdSpaceExhausted& operator=(IdSpaceExhausted&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit IdSpaceExhausted(const IdSpaceExhausted& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  IdSpaceExhausted& operator=(const IdSpaceExhausted&) = delete;

  /// Default destructor.
  ~IdSpaceExhausted() noexcept final = default;

  /// Creates a `IdSpaceExhausted` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit IdSpaceExhausted(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.IdSpaceExhausted`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.IdSpaceExhausted"; }

  /// The full name of the message: `horus.pb.logs.IdSpaceExhausted`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `prefix` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& prefix() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return prefix_;
  }

  /// If `prefix` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes prefix() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(prefix_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_prefix() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return prefix_;
  }

  /// Returns whether `prefix` (no 1) is set.
  constexpr bool has_prefix() const noexcept { return set_fields_[0]; }

  /// Clears `prefix` (no 1).
  void clear_prefix() & noexcept {
    set_fields_[0] = false;
    prefix_ = {};
  }

  /// Sets `prefix` (no 1) and returns `*this`.
  IdSpaceExhausted& set_prefix(CowBytes&& prefix) & noexcept {
    set_fields_[0] = true;
    prefix_ = std::move(prefix);
    return *this;
  }
  /// Sets `prefix` (no 1) and returns `*this`.
  IdSpaceExhausted&& set_prefix(CowBytes&& prefix) && noexcept {
    return std::move(set_prefix(std::move(prefix)));
  }

 private:
  /// @see prefix()
  CowBytes prefix_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #118.
/// 
///  > The point cloud publishing to the point aggregator service has been skipped $num_skipped_points time(s) in the last $check_interval.
///
/// Source: horus/pb/logs/logs.proto:916:1
class PreprocessingToPointAggregatorPointsSkipped final : public PbMessage {
 public:

  /// Constructs a default-initialized `PreprocessingToPointAggregatorPointsSkipped`.
  PreprocessingToPointAggregatorPointsSkipped() noexcept = default;

  /// Move constructor.
  PreprocessingToPointAggregatorPointsSkipped(PreprocessingToPointAggregatorPointsSkipped&&) noexcept = default;
  /// Move assignment operator.
  PreprocessingToPointAggregatorPointsSkipped& operator=(PreprocessingToPointAggregatorPointsSkipped&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit PreprocessingToPointAggregatorPointsSkipped(const PreprocessingToPointAggregatorPointsSkipped& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  PreprocessingToPointAggregatorPointsSkipped& operator=(const PreprocessingToPointAggregatorPointsSkipped&) = delete;

  /// Default destructor.
  ~PreprocessingToPointAggregatorPointsSkipped() noexcept final = default;

  /// Creates a `PreprocessingToPointAggregatorPointsSkipped` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit PreprocessingToPointAggregatorPointsSkipped(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.PreprocessingToPointAggregatorPointsSkipped`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.PreprocessingToPointAggregatorPointsSkipped"; }

  /// The full name of the message: `horus.pb.logs.PreprocessingToPointAggregatorPointsSkipped`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `num_skipped_points` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr std::uint64_t num_skipped_points() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return num_skipped_points_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_num_skipped_points() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return num_skipped_points_;
  }

  /// Returns whether `num_skipped_points` (no 1) is set.
  constexpr bool has_num_skipped_points() const noexcept { return set_fields_[0]; }

  /// Clears `num_skipped_points` (no 1).
  void clear_num_skipped_points() & noexcept {
    set_fields_[0] = false;
    num_skipped_points_ = {};
  }

  /// Sets `num_skipped_points` (no 1) and returns `*this`.
  PreprocessingToPointAggregatorPointsSkipped& set_num_skipped_points(std::uint64_t num_skipped_points) & noexcept {
    set_fields_[0] = true;
    num_skipped_points_ = num_skipped_points;
    return *this;
  }
  /// Sets `num_skipped_points` (no 1) and returns `*this`.
  PreprocessingToPointAggregatorPointsSkipped&& set_num_skipped_points(std::uint64_t num_skipped_points) && noexcept {
    return std::move(set_num_skipped_points(num_skipped_points));
  }

  // Field `check_interval` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Duration& check_interval() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return check_interval_;
  }

  /// If `check_interval` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration check_interval() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(check_interval_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration& mutable_check_interval() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return check_interval_;
  }

  /// Returns whether `check_interval` (no 2) is set.
  constexpr bool has_check_interval() const noexcept { return set_fields_[1]; }

  /// Clears `check_interval` (no 2).
  void clear_check_interval() & noexcept {
    set_fields_[1] = false;
    check_interval_ = {};
  }

  /// Sets `check_interval` (no 2) and returns `*this`.
  PreprocessingToPointAggregatorPointsSkipped& set_check_interval(horus::pb::LogMetadata_Duration&& check_interval) & noexcept {
    set_fields_[1] = true;
    check_interval_ = std::move(check_interval);
    return *this;
  }
  /// Sets `check_interval` (no 2) and returns `*this`.
  PreprocessingToPointAggregatorPointsSkipped&& set_check_interval(horus::pb::LogMetadata_Duration&& check_interval) && noexcept {
    return std::move(set_check_interval(std::move(check_interval)));
  }

 private:
  /// @see num_skipped_points()
  std::uint64_t num_skipped_points_{};
  /// @see check_interval()
  horus::pb::LogMetadata_Duration check_interval_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #119.
/// 
///  > Discarding lidar points from $lidar_id since the time interval between two point-cloud messages is too close (<$threshold). Adjust the Min-Message Interval parameter to change this behavior.
///
/// Source: horus/pb/logs/logs.proto:924:1
class MinMsgIntervalLessThanThreshold final : public PbMessage {
 public:

  /// Constructs a default-initialized `MinMsgIntervalLessThanThreshold`.
  MinMsgIntervalLessThanThreshold() noexcept = default;

  /// Move constructor.
  MinMsgIntervalLessThanThreshold(MinMsgIntervalLessThanThreshold&&) noexcept = default;
  /// Move assignment operator.
  MinMsgIntervalLessThanThreshold& operator=(MinMsgIntervalLessThanThreshold&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit MinMsgIntervalLessThanThreshold(const MinMsgIntervalLessThanThreshold& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  MinMsgIntervalLessThanThreshold& operator=(const MinMsgIntervalLessThanThreshold&) = delete;

  /// Default destructor.
  ~MinMsgIntervalLessThanThreshold() noexcept final = default;

  /// Creates a `MinMsgIntervalLessThanThreshold` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit MinMsgIntervalLessThanThreshold(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.MinMsgIntervalLessThanThreshold`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.MinMsgIntervalLessThanThreshold"; }

  /// The full name of the message: `horus.pb.logs.MinMsgIntervalLessThanThreshold`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `lidar_id` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& lidar_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return lidar_id_;
  }

  /// If `lidar_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes lidar_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(lidar_id_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_lidar_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return lidar_id_;
  }

  /// Returns whether `lidar_id` (no 1) is set.
  constexpr bool has_lidar_id() const noexcept { return set_fields_[0]; }

  /// Clears `lidar_id` (no 1).
  void clear_lidar_id() & noexcept {
    set_fields_[0] = false;
    lidar_id_ = {};
  }

  /// Sets `lidar_id` (no 1) and returns `*this`.
  MinMsgIntervalLessThanThreshold& set_lidar_id(CowBytes&& lidar_id) & noexcept {
    set_fields_[0] = true;
    lidar_id_ = std::move(lidar_id);
    return *this;
  }
  /// Sets `lidar_id` (no 1) and returns `*this`.
  MinMsgIntervalLessThanThreshold&& set_lidar_id(CowBytes&& lidar_id) && noexcept {
    return std::move(set_lidar_id(std::move(lidar_id)));
  }

  // Field `threshold` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Duration& threshold() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return threshold_;
  }

  /// If `threshold` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration threshold() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(threshold_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Duration& mutable_threshold() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return threshold_;
  }

  /// Returns whether `threshold` (no 2) is set.
  constexpr bool has_threshold() const noexcept { return set_fields_[1]; }

  /// Clears `threshold` (no 2).
  void clear_threshold() & noexcept {
    set_fields_[1] = false;
    threshold_ = {};
  }

  /// Sets `threshold` (no 2) and returns `*this`.
  MinMsgIntervalLessThanThreshold& set_threshold(horus::pb::LogMetadata_Duration&& threshold) & noexcept {
    set_fields_[1] = true;
    threshold_ = std::move(threshold);
    return *this;
  }
  /// Sets `threshold` (no 2) and returns `*this`.
  MinMsgIntervalLessThanThreshold&& set_threshold(horus::pb::LogMetadata_Duration&& threshold) && noexcept {
    return std::move(set_threshold(std::move(threshold)));
  }

 private:
  /// @see lidar_id()
  CowBytes lidar_id_{};
  /// @see threshold()
  horus::pb::LogMetadata_Duration threshold_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #120.
/// 
///  > Failed to clean up ROS nodes and processes: $details
///
/// Source: horus/pb/logs/logs.proto:932:1
class FailedToCleanupRosWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `FailedToCleanupRosWarning`.
  FailedToCleanupRosWarning() noexcept = default;

  /// Move constructor.
  FailedToCleanupRosWarning(FailedToCleanupRosWarning&&) noexcept = default;
  /// Move assignment operator.
  FailedToCleanupRosWarning& operator=(FailedToCleanupRosWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FailedToCleanupRosWarning(const FailedToCleanupRosWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FailedToCleanupRosWarning& operator=(const FailedToCleanupRosWarning&) = delete;

  /// Default destructor.
  ~FailedToCleanupRosWarning() noexcept final = default;

  /// Creates a `FailedToCleanupRosWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FailedToCleanupRosWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FailedToCleanupRosWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FailedToCleanupRosWarning"; }

  /// The full name of the message: `horus.pb.logs.FailedToCleanupRosWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `details` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes details() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return details_;
  }

  /// Returns whether `details` (no 1) is set.
  constexpr bool has_details() const noexcept { return set_fields_[0]; }

  /// Clears `details` (no 1).
  void clear_details() & noexcept {
    set_fields_[0] = false;
    details_ = {};
  }

  /// Sets `details` (no 1) and returns `*this`.
  FailedToCleanupRosWarning& set_details(CowBytes&& details) & noexcept {
    set_fields_[0] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 1) and returns `*this`.
  FailedToCleanupRosWarning&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #121.
/// 
///  > RPC request $request_name to $endpoint failed since endpoint is disconnected.
///
/// Source: horus/pb/logs/logs.proto:939:1
class RpcDisconnectedWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcDisconnectedWarning`.
  RpcDisconnectedWarning() noexcept = default;

  /// Move constructor.
  RpcDisconnectedWarning(RpcDisconnectedWarning&&) noexcept = default;
  /// Move assignment operator.
  RpcDisconnectedWarning& operator=(RpcDisconnectedWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcDisconnectedWarning(const RpcDisconnectedWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcDisconnectedWarning& operator=(const RpcDisconnectedWarning&) = delete;

  /// Default destructor.
  ~RpcDisconnectedWarning() noexcept final = default;

  /// Creates a `RpcDisconnectedWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcDisconnectedWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcDisconnectedWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcDisconnectedWarning"; }

  /// The full name of the message: `horus.pb.logs.RpcDisconnectedWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `request_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& request_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return request_name_;
  }

  /// If `request_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes request_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(request_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_request_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return request_name_;
  }

  /// Returns whether `request_name` (no 1) is set.
  constexpr bool has_request_name() const noexcept { return set_fields_[0]; }

  /// Clears `request_name` (no 1).
  void clear_request_name() & noexcept {
    set_fields_[0] = false;
    request_name_ = {};
  }

  /// Sets `request_name` (no 1) and returns `*this`.
  RpcDisconnectedWarning& set_request_name(CowBytes&& request_name) & noexcept {
    set_fields_[0] = true;
    request_name_ = std::move(request_name);
    return *this;
  }
  /// Sets `request_name` (no 1) and returns `*this`.
  RpcDisconnectedWarning&& set_request_name(CowBytes&& request_name) && noexcept {
    return std::move(set_request_name(std::move(request_name)));
  }

  // Field `endpoint` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& endpoint() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return endpoint_;
  }

  /// If `endpoint` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes endpoint() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(endpoint_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_endpoint() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return endpoint_;
  }

  /// Returns whether `endpoint` (no 2) is set.
  constexpr bool has_endpoint() const noexcept { return set_fields_[1]; }

  /// Clears `endpoint` (no 2).
  void clear_endpoint() & noexcept {
    set_fields_[1] = false;
    endpoint_ = {};
  }

  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcDisconnectedWarning& set_endpoint(CowBytes&& endpoint) & noexcept {
    set_fields_[1] = true;
    endpoint_ = std::move(endpoint);
    return *this;
  }
  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcDisconnectedWarning&& set_endpoint(CowBytes&& endpoint) && noexcept {
    return std::move(set_endpoint(std::move(endpoint)));
  }

 private:
  /// @see request_name()
  CowBytes request_name_{};
  /// @see endpoint()
  CowBytes endpoint_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #122.
/// 
///  > RPC request handler for $request_name failed due to an unhandled internal error: $details.
///
/// Source: horus/pb/logs/logs.proto:947:1
class RpcUnhandledError final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcUnhandledError`.
  RpcUnhandledError() noexcept = default;

  /// Move constructor.
  RpcUnhandledError(RpcUnhandledError&&) noexcept = default;
  /// Move assignment operator.
  RpcUnhandledError& operator=(RpcUnhandledError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcUnhandledError(const RpcUnhandledError& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcUnhandledError& operator=(const RpcUnhandledError&) = delete;

  /// Default destructor.
  ~RpcUnhandledError() noexcept final = default;

  /// Creates a `RpcUnhandledError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcUnhandledError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcUnhandledError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcUnhandledError"; }

  /// The full name of the message: `horus.pb.logs.RpcUnhandledError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `request_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& request_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return request_name_;
  }

  /// If `request_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes request_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(request_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_request_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return request_name_;
  }

  /// Returns whether `request_name` (no 1) is set.
  constexpr bool has_request_name() const noexcept { return set_fields_[0]; }

  /// Clears `request_name` (no 1).
  void clear_request_name() & noexcept {
    set_fields_[0] = false;
    request_name_ = {};
  }

  /// Sets `request_name` (no 1) and returns `*this`.
  RpcUnhandledError& set_request_name(CowBytes&& request_name) & noexcept {
    set_fields_[0] = true;
    request_name_ = std::move(request_name);
    return *this;
  }
  /// Sets `request_name` (no 1) and returns `*this`.
  RpcUnhandledError&& set_request_name(CowBytes&& request_name) && noexcept {
    return std::move(set_request_name(std::move(request_name)));
  }

  // Field `details` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes details() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return details_;
  }

  /// Returns whether `details` (no 2) is set.
  constexpr bool has_details() const noexcept { return set_fields_[1]; }

  /// Clears `details` (no 2).
  void clear_details() & noexcept {
    set_fields_[1] = false;
    details_ = {};
  }

  /// Sets `details` (no 2) and returns `*this`.
  RpcUnhandledError& set_details(CowBytes&& details) & noexcept {
    set_fields_[1] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 2) and returns `*this`.
  RpcUnhandledError&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see request_name()
  CowBytes request_name_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #123.
/// 
///  > Time difference is out of range: $diff. Previous timestamp: $prev_time, Current timestamp: $curr_time.
///
/// Source: horus/pb/logs/logs.proto:955:1
class TimeDiffOutOfRangeWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `TimeDiffOutOfRangeWarning`.
  TimeDiffOutOfRangeWarning() noexcept = default;

  /// Move constructor.
  TimeDiffOutOfRangeWarning(TimeDiffOutOfRangeWarning&&) noexcept = default;
  /// Move assignment operator.
  TimeDiffOutOfRangeWarning& operator=(TimeDiffOutOfRangeWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit TimeDiffOutOfRangeWarning(const TimeDiffOutOfRangeWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  TimeDiffOutOfRangeWarning& operator=(const TimeDiffOutOfRangeWarning&) = delete;

  /// Default destructor.
  ~TimeDiffOutOfRangeWarning() noexcept final = default;

  /// Creates a `TimeDiffOutOfRangeWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit TimeDiffOutOfRangeWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.TimeDiffOutOfRangeWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.TimeDiffOutOfRangeWarning"; }

  /// The full name of the message: `horus.pb.logs.TimeDiffOutOfRangeWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `prev_time` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const horus::pb::LogMetadata_Timestamp& prev_time() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return prev_time_;
  }

  /// If `prev_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp prev_time() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(prev_time_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  horus::pb::LogMetadata_Timestamp& mutable_prev_time() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return prev_time_;
  }

  /// Returns whether `prev_time` (no 1) is set.
  constexpr bool has_prev_time() const noexcept { return set_fields_[0]; }

  /// Clears `prev_time` (no 1).
  void clear_prev_time() & noexcept {
    set_fields_[0] = false;
    prev_time_ = {};
  }

  /// Sets `prev_time` (no 1) and returns `*this`.
  TimeDiffOutOfRangeWarning& set_prev_time(horus::pb::LogMetadata_Timestamp&& prev_time) & noexcept {
    set_fields_[0] = true;
    prev_time_ = std::move(prev_time);
    return *this;
  }
  /// Sets `prev_time` (no 1) and returns `*this`.
  TimeDiffOutOfRangeWarning&& set_prev_time(horus::pb::LogMetadata_Timestamp&& prev_time) && noexcept {
    return std::move(set_prev_time(std::move(prev_time)));
  }

  // Field `curr_time` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const horus::pb::LogMetadata_Timestamp& curr_time() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return curr_time_;
  }

  /// If `curr_time` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp curr_time() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(curr_time_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  horus::pb::LogMetadata_Timestamp& mutable_curr_time() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return curr_time_;
  }

  /// Returns whether `curr_time` (no 2) is set.
  constexpr bool has_curr_time() const noexcept { return set_fields_[1]; }

  /// Clears `curr_time` (no 2).
  void clear_curr_time() & noexcept {
    set_fields_[1] = false;
    curr_time_ = {};
  }

  /// Sets `curr_time` (no 2) and returns `*this`.
  TimeDiffOutOfRangeWarning& set_curr_time(horus::pb::LogMetadata_Timestamp&& curr_time) & noexcept {
    set_fields_[1] = true;
    curr_time_ = std::move(curr_time);
    return *this;
  }
  /// Sets `curr_time` (no 2) and returns `*this`.
  TimeDiffOutOfRangeWarning&& set_curr_time(horus::pb::LogMetadata_Timestamp&& curr_time) && noexcept {
    return std::move(set_curr_time(std::move(curr_time)));
  }

  // Field `diff` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const horus::pb::LogMetadata_Duration& diff() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return diff_;
  }

  /// If `diff` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration diff() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(diff_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration& mutable_diff() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return diff_;
  }

  /// Returns whether `diff` (no 3) is set.
  constexpr bool has_diff() const noexcept { return set_fields_[2]; }

  /// Clears `diff` (no 3).
  void clear_diff() & noexcept {
    set_fields_[2] = false;
    diff_ = {};
  }

  /// Sets `diff` (no 3) and returns `*this`.
  TimeDiffOutOfRangeWarning& set_diff(horus::pb::LogMetadata_Duration&& diff) & noexcept {
    set_fields_[2] = true;
    diff_ = std::move(diff);
    return *this;
  }
  /// Sets `diff` (no 3) and returns `*this`.
  TimeDiffOutOfRangeWarning&& set_diff(horus::pb::LogMetadata_Duration&& diff) && noexcept {
    return std::move(set_diff(std::move(diff)));
  }

 private:
  /// @see prev_time()
  horus::pb::LogMetadata_Timestamp prev_time_{};
  /// @see curr_time()
  horus::pb::LogMetadata_Timestamp curr_time_{};
  /// @see diff()
  horus::pb::LogMetadata_Duration diff_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #124.
/// 
///  > [TensorRT] $log
///
/// Source: horus/pb/logs/logs.proto:964:1
class TensorrtLog final : public PbMessage {
 public:

  /// Constructs a default-initialized `TensorrtLog`.
  TensorrtLog() noexcept = default;

  /// Move constructor.
  TensorrtLog(TensorrtLog&&) noexcept = default;
  /// Move assignment operator.
  TensorrtLog& operator=(TensorrtLog&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit TensorrtLog(const TensorrtLog& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  TensorrtLog& operator=(const TensorrtLog&) = delete;

  /// Default destructor.
  ~TensorrtLog() noexcept final = default;

  /// Creates a `TensorrtLog` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit TensorrtLog(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.TensorrtLog`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.TensorrtLog"; }

  /// The full name of the message: `horus.pb.logs.TensorrtLog`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `log` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& log() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return log_;
  }

  /// If `log` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes log() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(log_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_log() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return log_;
  }

  /// Returns whether `log` (no 1) is set.
  constexpr bool has_log() const noexcept { return set_fields_[0]; }

  /// Clears `log` (no 1).
  void clear_log() & noexcept {
    set_fields_[0] = false;
    log_ = {};
  }

  /// Sets `log` (no 1) and returns `*this`.
  TensorrtLog& set_log(CowBytes&& log) & noexcept {
    set_fields_[0] = true;
    log_ = std::move(log);
    return *this;
  }
  /// Sets `log` (no 1) and returns `*this`.
  TensorrtLog&& set_log(CowBytes&& log) && noexcept {
    return std::move(set_log(std::move(log)));
  }

 private:
  /// @see log()
  CowBytes log_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #125.
/// 
///  > Building TensorRT engine since the model has changed or the engine is not available. This may take a while.
///
/// Source: horus/pb/logs/logs.proto:971:1
class BuildingTensorrtEngineInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `BuildingTensorrtEngineInfo`.
  BuildingTensorrtEngineInfo() noexcept = default;

  /// Move constructor.
  BuildingTensorrtEngineInfo(BuildingTensorrtEngineInfo&&) noexcept = default;
  /// Move assignment operator.
  BuildingTensorrtEngineInfo& operator=(BuildingTensorrtEngineInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BuildingTensorrtEngineInfo(const BuildingTensorrtEngineInfo&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BuildingTensorrtEngineInfo& operator=(const BuildingTensorrtEngineInfo&) = delete;

  /// Default destructor.
  ~BuildingTensorrtEngineInfo() noexcept final = default;

  /// Creates a `BuildingTensorrtEngineInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BuildingTensorrtEngineInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BuildingTensorrtEngineInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BuildingTensorrtEngineInfo"; }

  /// The full name of the message: `horus.pb.logs.BuildingTensorrtEngineInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #126.
/// 
///  > Loading TensorRT engine. This may take a while.
///
/// Source: horus/pb/logs/logs.proto:977:1
class LoadingTensorrtEngineInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `LoadingTensorrtEngineInfo`.
  LoadingTensorrtEngineInfo() noexcept = default;

  /// Move constructor.
  LoadingTensorrtEngineInfo(LoadingTensorrtEngineInfo&&) noexcept = default;
  /// Move assignment operator.
  LoadingTensorrtEngineInfo& operator=(LoadingTensorrtEngineInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LoadingTensorrtEngineInfo(const LoadingTensorrtEngineInfo&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LoadingTensorrtEngineInfo& operator=(const LoadingTensorrtEngineInfo&) = delete;

  /// Default destructor.
  ~LoadingTensorrtEngineInfo() noexcept final = default;

  /// Creates a `LoadingTensorrtEngineInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LoadingTensorrtEngineInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.LoadingTensorrtEngineInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.LoadingTensorrtEngineInfo"; }

  /// The full name of the message: `horus.pb.logs.LoadingTensorrtEngineInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #127.
/// 
///  > The calibration map $path was not found.
///
/// Source: horus/pb/logs/logs.proto:983:1
class CalibrationMapNotFound final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationMapNotFound`.
  CalibrationMapNotFound() noexcept = default;

  /// Move constructor.
  CalibrationMapNotFound(CalibrationMapNotFound&&) noexcept = default;
  /// Move assignment operator.
  CalibrationMapNotFound& operator=(CalibrationMapNotFound&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationMapNotFound(const CalibrationMapNotFound& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationMapNotFound& operator=(const CalibrationMapNotFound&) = delete;

  /// Default destructor.
  ~CalibrationMapNotFound() noexcept final = default;

  /// Creates a `CalibrationMapNotFound` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationMapNotFound(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationMapNotFound`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationMapNotFound"; }

  /// The full name of the message: `horus.pb.logs.CalibrationMapNotFound`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapNotFound& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapNotFound&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #128.
/// 
///  > The calibration map $path is not valid.
///
/// Source: horus/pb/logs/logs.proto:990:1
class CalibrationMapNotValid final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationMapNotValid`.
  CalibrationMapNotValid() noexcept = default;

  /// Move constructor.
  CalibrationMapNotValid(CalibrationMapNotValid&&) noexcept = default;
  /// Move assignment operator.
  CalibrationMapNotValid& operator=(CalibrationMapNotValid&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationMapNotValid(const CalibrationMapNotValid& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationMapNotValid& operator=(const CalibrationMapNotValid&) = delete;

  /// Default destructor.
  ~CalibrationMapNotValid() noexcept final = default;

  /// Creates a `CalibrationMapNotValid` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationMapNotValid(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationMapNotValid`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationMapNotValid"; }

  /// The full name of the message: `horus.pb.logs.CalibrationMapNotValid`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapNotValid& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapNotValid&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #129.
/// 
///  > The calibration map path $path already exists.
///
/// Source: horus/pb/logs/logs.proto:997:1
class CalibrationMapPathAlreadyExists final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationMapPathAlreadyExists`.
  CalibrationMapPathAlreadyExists() noexcept = default;

  /// Move constructor.
  CalibrationMapPathAlreadyExists(CalibrationMapPathAlreadyExists&&) noexcept = default;
  /// Move assignment operator.
  CalibrationMapPathAlreadyExists& operator=(CalibrationMapPathAlreadyExists&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationMapPathAlreadyExists(const CalibrationMapPathAlreadyExists& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationMapPathAlreadyExists& operator=(const CalibrationMapPathAlreadyExists&) = delete;

  /// Default destructor.
  ~CalibrationMapPathAlreadyExists() noexcept final = default;

  /// Creates a `CalibrationMapPathAlreadyExists` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationMapPathAlreadyExists(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationMapPathAlreadyExists`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationMapPathAlreadyExists"; }

  /// The full name of the message: `horus.pb.logs.CalibrationMapPathAlreadyExists`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapPathAlreadyExists& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapPathAlreadyExists&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #130.
/// 
///  > Failed to save the calibration map to $path.
///
/// Source: horus/pb/logs/logs.proto:1004:1
class FailedToSaveCalibrationMap final : public PbMessage {
 public:

  /// Constructs a default-initialized `FailedToSaveCalibrationMap`.
  FailedToSaveCalibrationMap() noexcept = default;

  /// Move constructor.
  FailedToSaveCalibrationMap(FailedToSaveCalibrationMap&&) noexcept = default;
  /// Move assignment operator.
  FailedToSaveCalibrationMap& operator=(FailedToSaveCalibrationMap&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FailedToSaveCalibrationMap(const FailedToSaveCalibrationMap& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FailedToSaveCalibrationMap& operator=(const FailedToSaveCalibrationMap&) = delete;

  /// Default destructor.
  ~FailedToSaveCalibrationMap() noexcept final = default;

  /// Creates a `FailedToSaveCalibrationMap` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FailedToSaveCalibrationMap(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FailedToSaveCalibrationMap`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FailedToSaveCalibrationMap"; }

  /// The full name of the message: `horus.pb.logs.FailedToSaveCalibrationMap`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  FailedToSaveCalibrationMap& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  FailedToSaveCalibrationMap&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #131.
/// 
///  > Failed to remove the calibration map at $path.
///
/// Source: horus/pb/logs/logs.proto:1011:1
class FailedToRemoveCalibrationMap final : public PbMessage {
 public:

  /// Constructs a default-initialized `FailedToRemoveCalibrationMap`.
  FailedToRemoveCalibrationMap() noexcept = default;

  /// Move constructor.
  FailedToRemoveCalibrationMap(FailedToRemoveCalibrationMap&&) noexcept = default;
  /// Move assignment operator.
  FailedToRemoveCalibrationMap& operator=(FailedToRemoveCalibrationMap&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FailedToRemoveCalibrationMap(const FailedToRemoveCalibrationMap& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FailedToRemoveCalibrationMap& operator=(const FailedToRemoveCalibrationMap&) = delete;

  /// Default destructor.
  ~FailedToRemoveCalibrationMap() noexcept final = default;

  /// Creates a `FailedToRemoveCalibrationMap` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FailedToRemoveCalibrationMap(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FailedToRemoveCalibrationMap`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FailedToRemoveCalibrationMap"; }

  /// The full name of the message: `horus.pb.logs.FailedToRemoveCalibrationMap`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  FailedToRemoveCalibrationMap& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  FailedToRemoveCalibrationMap&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #132.
/// 
///  > Failed to iterate in the $directory_name directory $directory_path: $details.
///
/// Source: horus/pb/logs/logs.proto:1018:1
class FailedToIterateInDirectory final : public PbMessage {
 public:

  /// Constructs a default-initialized `FailedToIterateInDirectory`.
  FailedToIterateInDirectory() noexcept = default;

  /// Move constructor.
  FailedToIterateInDirectory(FailedToIterateInDirectory&&) noexcept = default;
  /// Move assignment operator.
  FailedToIterateInDirectory& operator=(FailedToIterateInDirectory&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit FailedToIterateInDirectory(const FailedToIterateInDirectory& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  FailedToIterateInDirectory& operator=(const FailedToIterateInDirectory&) = delete;

  /// Default destructor.
  ~FailedToIterateInDirectory() noexcept final = default;

  /// Creates a `FailedToIterateInDirectory` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit FailedToIterateInDirectory(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.FailedToIterateInDirectory`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.FailedToIterateInDirectory"; }

  /// The full name of the message: `horus.pb.logs.FailedToIterateInDirectory`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `directory_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& directory_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return directory_name_;
  }

  /// If `directory_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes directory_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(directory_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_directory_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return directory_name_;
  }

  /// Returns whether `directory_name` (no 1) is set.
  constexpr bool has_directory_name() const noexcept { return set_fields_[0]; }

  /// Clears `directory_name` (no 1).
  void clear_directory_name() & noexcept {
    set_fields_[0] = false;
    directory_name_ = {};
  }

  /// Sets `directory_name` (no 1) and returns `*this`.
  FailedToIterateInDirectory& set_directory_name(CowBytes&& directory_name) & noexcept {
    set_fields_[0] = true;
    directory_name_ = std::move(directory_name);
    return *this;
  }
  /// Sets `directory_name` (no 1) and returns `*this`.
  FailedToIterateInDirectory&& set_directory_name(CowBytes&& directory_name) && noexcept {
    return std::move(set_directory_name(std::move(directory_name)));
  }

  // Field `directory_path` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& directory_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return directory_path_;
  }

  /// If `directory_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes directory_path() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(directory_path_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_directory_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return directory_path_;
  }

  /// Returns whether `directory_path` (no 2) is set.
  constexpr bool has_directory_path() const noexcept { return set_fields_[1]; }

  /// Clears `directory_path` (no 2).
  void clear_directory_path() & noexcept {
    set_fields_[1] = false;
    directory_path_ = {};
  }

  /// Sets `directory_path` (no 2) and returns `*this`.
  FailedToIterateInDirectory& set_directory_path(CowBytes&& directory_path) & noexcept {
    set_fields_[1] = true;
    directory_path_ = std::move(directory_path);
    return *this;
  }
  /// Sets `directory_path` (no 2) and returns `*this`.
  FailedToIterateInDirectory&& set_directory_path(CowBytes&& directory_path) && noexcept {
    return std::move(set_directory_path(std::move(directory_path)));
  }

  // Field `details` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const CowBytes& details() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return details_;
  }

  /// If `details` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes details() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(details_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  CowBytes& mutable_details() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return details_;
  }

  /// Returns whether `details` (no 3) is set.
  constexpr bool has_details() const noexcept { return set_fields_[2]; }

  /// Clears `details` (no 3).
  void clear_details() & noexcept {
    set_fields_[2] = false;
    details_ = {};
  }

  /// Sets `details` (no 3) and returns `*this`.
  FailedToIterateInDirectory& set_details(CowBytes&& details) & noexcept {
    set_fields_[2] = true;
    details_ = std::move(details);
    return *this;
  }
  /// Sets `details` (no 3) and returns `*this`.
  FailedToIterateInDirectory&& set_details(CowBytes&& details) && noexcept {
    return std::move(set_details(std::move(details)));
  }

 private:
  /// @see directory_name()
  CowBytes directory_name_{};
  /// @see directory_path()
  CowBytes directory_path_{};
  /// @see details()
  CowBytes details_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Log #133.
/// 
///  > The calibration map must be running before triggering the map-based calibration.
///
/// Source: horus/pb/logs/logs.proto:1027:1
class MapBasedCalibrationWithoutMapLoading final : public PbMessage {
 public:

  /// Constructs a default-initialized `MapBasedCalibrationWithoutMapLoading`.
  MapBasedCalibrationWithoutMapLoading() noexcept = default;

  /// Move constructor.
  MapBasedCalibrationWithoutMapLoading(MapBasedCalibrationWithoutMapLoading&&) noexcept = default;
  /// Move assignment operator.
  MapBasedCalibrationWithoutMapLoading& operator=(MapBasedCalibrationWithoutMapLoading&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit MapBasedCalibrationWithoutMapLoading(const MapBasedCalibrationWithoutMapLoading&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  MapBasedCalibrationWithoutMapLoading& operator=(const MapBasedCalibrationWithoutMapLoading&) = delete;

  /// Default destructor.
  ~MapBasedCalibrationWithoutMapLoading() noexcept final = default;

  /// Creates a `MapBasedCalibrationWithoutMapLoading` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit MapBasedCalibrationWithoutMapLoading(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.MapBasedCalibrationWithoutMapLoading`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.MapBasedCalibrationWithoutMapLoading"; }

  /// The full name of the message: `horus.pb.logs.MapBasedCalibrationWithoutMapLoading`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #134.
/// 
///  > The map-based calibration is already running.
///
/// Source: horus/pb/logs/logs.proto:1033:1
class MapBasedCalibrationAlreadyRunning final : public PbMessage {
 public:

  /// Constructs a default-initialized `MapBasedCalibrationAlreadyRunning`.
  MapBasedCalibrationAlreadyRunning() noexcept = default;

  /// Move constructor.
  MapBasedCalibrationAlreadyRunning(MapBasedCalibrationAlreadyRunning&&) noexcept = default;
  /// Move assignment operator.
  MapBasedCalibrationAlreadyRunning& operator=(MapBasedCalibrationAlreadyRunning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit MapBasedCalibrationAlreadyRunning(const MapBasedCalibrationAlreadyRunning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  MapBasedCalibrationAlreadyRunning& operator=(const MapBasedCalibrationAlreadyRunning&) = delete;

  /// Default destructor.
  ~MapBasedCalibrationAlreadyRunning() noexcept final = default;

  /// Creates a `MapBasedCalibrationAlreadyRunning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit MapBasedCalibrationAlreadyRunning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.MapBasedCalibrationAlreadyRunning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.MapBasedCalibrationAlreadyRunning"; }

  /// The full name of the message: `horus.pb.logs.MapBasedCalibrationAlreadyRunning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #135.
/// 
///  > A cancel map-based calibration request has been received while the calibration is not running.
///
/// Source: horus/pb/logs/logs.proto:1039:1
class CancelMapBasedCalibrationNotRunning final : public PbMessage {
 public:

  /// Constructs a default-initialized `CancelMapBasedCalibrationNotRunning`.
  CancelMapBasedCalibrationNotRunning() noexcept = default;

  /// Move constructor.
  CancelMapBasedCalibrationNotRunning(CancelMapBasedCalibrationNotRunning&&) noexcept = default;
  /// Move assignment operator.
  CancelMapBasedCalibrationNotRunning& operator=(CancelMapBasedCalibrationNotRunning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CancelMapBasedCalibrationNotRunning(const CancelMapBasedCalibrationNotRunning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CancelMapBasedCalibrationNotRunning& operator=(const CancelMapBasedCalibrationNotRunning&) = delete;

  /// Default destructor.
  ~CancelMapBasedCalibrationNotRunning() noexcept final = default;

  /// Creates a `CancelMapBasedCalibrationNotRunning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CancelMapBasedCalibrationNotRunning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CancelMapBasedCalibrationNotRunning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CancelMapBasedCalibrationNotRunning"; }

  /// The full name of the message: `horus.pb.logs.CancelMapBasedCalibrationNotRunning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #136.
/// 
///  > The stream $stream_id was not found from $bag_path.
///
/// Source: horus/pb/logs/logs.proto:1045:1
class BagStreamNotFound final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagStreamNotFound`.
  BagStreamNotFound() noexcept = default;

  /// Move constructor.
  BagStreamNotFound(BagStreamNotFound&&) noexcept = default;
  /// Move assignment operator.
  BagStreamNotFound& operator=(BagStreamNotFound&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagStreamNotFound(const BagStreamNotFound& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagStreamNotFound& operator=(const BagStreamNotFound&) = delete;

  /// Default destructor.
  ~BagStreamNotFound() noexcept final = default;

  /// Creates a `BagStreamNotFound` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagStreamNotFound(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagStreamNotFound`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagStreamNotFound"; }

  /// The full name of the message: `horus.pb.logs.BagStreamNotFound`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return bag_path_;
  }

  /// If `bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bag_path_;
  }

  /// Returns whether `bag_path` (no 1) is set.
  constexpr bool has_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `bag_path` (no 1).
  void clear_bag_path() & noexcept {
    set_fields_[0] = false;
    bag_path_ = {};
  }

  /// Sets `bag_path` (no 1) and returns `*this`.
  BagStreamNotFound& set_bag_path(CowBytes&& bag_path) & noexcept {
    set_fields_[0] = true;
    bag_path_ = std::move(bag_path);
    return *this;
  }
  /// Sets `bag_path` (no 1) and returns `*this`.
  BagStreamNotFound&& set_bag_path(CowBytes&& bag_path) && noexcept {
    return std::move(set_bag_path(std::move(bag_path)));
  }

  // Field `stream_id` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& stream_id() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return stream_id_;
  }

  /// If `stream_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes stream_id() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(stream_id_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_stream_id() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return stream_id_;
  }

  /// Returns whether `stream_id` (no 2) is set.
  constexpr bool has_stream_id() const noexcept { return set_fields_[1]; }

  /// Clears `stream_id` (no 2).
  void clear_stream_id() & noexcept {
    set_fields_[1] = false;
    stream_id_ = {};
  }

  /// Sets `stream_id` (no 2) and returns `*this`.
  BagStreamNotFound& set_stream_id(CowBytes&& stream_id) & noexcept {
    set_fields_[1] = true;
    stream_id_ = std::move(stream_id);
    return *this;
  }
  /// Sets `stream_id` (no 2) and returns `*this`.
  BagStreamNotFound&& set_stream_id(CowBytes&& stream_id) && noexcept {
    return std::move(set_stream_id(std::move(stream_id)));
  }

 private:
  /// @see bag_path()
  CowBytes bag_path_{};
  /// @see stream_id()
  CowBytes stream_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Log #137.
/// 
///  > Evaluation bag started for $bag_path
///
/// Source: horus/pb/logs/logs.proto:1053:1
class EvaluationBagStartedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `EvaluationBagStartedInfo`.
  EvaluationBagStartedInfo() noexcept = default;

  /// Move constructor.
  EvaluationBagStartedInfo(EvaluationBagStartedInfo&&) noexcept = default;
  /// Move assignment operator.
  EvaluationBagStartedInfo& operator=(EvaluationBagStartedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit EvaluationBagStartedInfo(const EvaluationBagStartedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  EvaluationBagStartedInfo& operator=(const EvaluationBagStartedInfo&) = delete;

  /// Default destructor.
  ~EvaluationBagStartedInfo() noexcept final = default;

  /// Creates a `EvaluationBagStartedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit EvaluationBagStartedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.EvaluationBagStartedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.EvaluationBagStartedInfo"; }

  /// The full name of the message: `horus.pb.logs.EvaluationBagStartedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return bag_path_;
  }

  /// If `bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bag_path_;
  }

  /// Returns whether `bag_path` (no 1) is set.
  constexpr bool has_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `bag_path` (no 1).
  void clear_bag_path() & noexcept {
    set_fields_[0] = false;
    bag_path_ = {};
  }

  /// Sets `bag_path` (no 1) and returns `*this`.
  EvaluationBagStartedInfo& set_bag_path(CowBytes&& bag_path) & noexcept {
    set_fields_[0] = true;
    bag_path_ = std::move(bag_path);
    return *this;
  }
  /// Sets `bag_path` (no 1) and returns `*this`.
  EvaluationBagStartedInfo&& set_bag_path(CowBytes&& bag_path) && noexcept {
    return std::move(set_bag_path(std::move(bag_path)));
  }

 private:
  /// @see bag_path()
  CowBytes bag_path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #138.
/// 
///  > Evaluation bag finished for $bag_path
///
/// Source: horus/pb/logs/logs.proto:1060:1
class EvaluationBagFinishedInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `EvaluationBagFinishedInfo`.
  EvaluationBagFinishedInfo() noexcept = default;

  /// Move constructor.
  EvaluationBagFinishedInfo(EvaluationBagFinishedInfo&&) noexcept = default;
  /// Move assignment operator.
  EvaluationBagFinishedInfo& operator=(EvaluationBagFinishedInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit EvaluationBagFinishedInfo(const EvaluationBagFinishedInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  EvaluationBagFinishedInfo& operator=(const EvaluationBagFinishedInfo&) = delete;

  /// Default destructor.
  ~EvaluationBagFinishedInfo() noexcept final = default;

  /// Creates a `EvaluationBagFinishedInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit EvaluationBagFinishedInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.EvaluationBagFinishedInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.EvaluationBagFinishedInfo"; }

  /// The full name of the message: `horus.pb.logs.EvaluationBagFinishedInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return bag_path_;
  }

  /// If `bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bag_path_;
  }

  /// Returns whether `bag_path` (no 1) is set.
  constexpr bool has_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `bag_path` (no 1).
  void clear_bag_path() & noexcept {
    set_fields_[0] = false;
    bag_path_ = {};
  }

  /// Sets `bag_path` (no 1) and returns `*this`.
  EvaluationBagFinishedInfo& set_bag_path(CowBytes&& bag_path) & noexcept {
    set_fields_[0] = true;
    bag_path_ = std::move(bag_path);
    return *this;
  }
  /// Sets `bag_path` (no 1) and returns `*this`.
  EvaluationBagFinishedInfo&& set_bag_path(CowBytes&& bag_path) && noexcept {
    return std::move(set_bag_path(std::move(bag_path)));
  }

 private:
  /// @see bag_path()
  CowBytes bag_path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #139.
/// 
///  > The bag $bag_path was not found.
///
/// Source: horus/pb/logs/logs.proto:1067:1
class BagNotFound final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagNotFound`.
  BagNotFound() noexcept = default;

  /// Move constructor.
  BagNotFound(BagNotFound&&) noexcept = default;
  /// Move assignment operator.
  BagNotFound& operator=(BagNotFound&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagNotFound(const BagNotFound& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagNotFound& operator=(const BagNotFound&) = delete;

  /// Default destructor.
  ~BagNotFound() noexcept final = default;

  /// Creates a `BagNotFound` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagNotFound(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagNotFound`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagNotFound"; }

  /// The full name of the message: `horus.pb.logs.BagNotFound`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return bag_path_;
  }

  /// If `bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bag_path_;
  }

  /// Returns whether `bag_path` (no 1) is set.
  constexpr bool has_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `bag_path` (no 1).
  void clear_bag_path() & noexcept {
    set_fields_[0] = false;
    bag_path_ = {};
  }

  /// Sets `bag_path` (no 1) and returns `*this`.
  BagNotFound& set_bag_path(CowBytes&& bag_path) & noexcept {
    set_fields_[0] = true;
    bag_path_ = std::move(bag_path);
    return *this;
  }
  /// Sets `bag_path` (no 1) and returns `*this`.
  BagNotFound&& set_bag_path(CowBytes&& bag_path) && noexcept {
    return std::move(set_bag_path(std::move(bag_path)));
  }

 private:
  /// @see bag_path()
  CowBytes bag_path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #140.
/// 
///  > Building the $pipeline_name pipeline.
///
/// Source: horus/pb/logs/logs.proto:1074:1
class BuildingPipelineInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `BuildingPipelineInfo`.
  BuildingPipelineInfo() noexcept = default;

  /// Move constructor.
  BuildingPipelineInfo(BuildingPipelineInfo&&) noexcept = default;
  /// Move assignment operator.
  BuildingPipelineInfo& operator=(BuildingPipelineInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BuildingPipelineInfo(const BuildingPipelineInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BuildingPipelineInfo& operator=(const BuildingPipelineInfo&) = delete;

  /// Default destructor.
  ~BuildingPipelineInfo() noexcept final = default;

  /// Creates a `BuildingPipelineInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BuildingPipelineInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BuildingPipelineInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BuildingPipelineInfo"; }

  /// The full name of the message: `horus.pb.logs.BuildingPipelineInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `pipeline_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& pipeline_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return pipeline_name_;
  }

  /// If `pipeline_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes pipeline_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(pipeline_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_pipeline_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return pipeline_name_;
  }

  /// Returns whether `pipeline_name` (no 1) is set.
  constexpr bool has_pipeline_name() const noexcept { return set_fields_[0]; }

  /// Clears `pipeline_name` (no 1).
  void clear_pipeline_name() & noexcept {
    set_fields_[0] = false;
    pipeline_name_ = {};
  }

  /// Sets `pipeline_name` (no 1) and returns `*this`.
  BuildingPipelineInfo& set_pipeline_name(CowBytes&& pipeline_name) & noexcept {
    set_fields_[0] = true;
    pipeline_name_ = std::move(pipeline_name);
    return *this;
  }
  /// Sets `pipeline_name` (no 1) and returns `*this`.
  BuildingPipelineInfo&& set_pipeline_name(CowBytes&& pipeline_name) && noexcept {
    return std::move(set_pipeline_name(std::move(pipeline_name)));
  }

 private:
  /// @see pipeline_name()
  CowBytes pipeline_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #141.
/// 
///  > The bag $bag_path is not an evaluation bag.
///
/// Source: horus/pb/logs/logs.proto:1081:1
class BagIsNotEvaluation final : public PbMessage {
 public:

  /// Constructs a default-initialized `BagIsNotEvaluation`.
  BagIsNotEvaluation() noexcept = default;

  /// Move constructor.
  BagIsNotEvaluation(BagIsNotEvaluation&&) noexcept = default;
  /// Move assignment operator.
  BagIsNotEvaluation& operator=(BagIsNotEvaluation&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BagIsNotEvaluation(const BagIsNotEvaluation& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BagIsNotEvaluation& operator=(const BagIsNotEvaluation&) = delete;

  /// Default destructor.
  ~BagIsNotEvaluation() noexcept final = default;

  /// Creates a `BagIsNotEvaluation` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BagIsNotEvaluation(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.BagIsNotEvaluation`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.BagIsNotEvaluation"; }

  /// The full name of the message: `horus.pb.logs.BagIsNotEvaluation`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bag_path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& bag_path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return bag_path_;
  }

  /// If `bag_path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes bag_path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bag_path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_bag_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bag_path_;
  }

  /// Returns whether `bag_path` (no 1) is set.
  constexpr bool has_bag_path() const noexcept { return set_fields_[0]; }

  /// Clears `bag_path` (no 1).
  void clear_bag_path() & noexcept {
    set_fields_[0] = false;
    bag_path_ = {};
  }

  /// Sets `bag_path` (no 1) and returns `*this`.
  BagIsNotEvaluation& set_bag_path(CowBytes&& bag_path) & noexcept {
    set_fields_[0] = true;
    bag_path_ = std::move(bag_path);
    return *this;
  }
  /// Sets `bag_path` (no 1) and returns `*this`.
  BagIsNotEvaluation&& set_bag_path(CowBytes&& bag_path) && noexcept {
    return std::move(set_bag_path(std::move(bag_path)));
  }

 private:
  /// @see bag_path()
  CowBytes bag_path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #142.
/// 
///  > A Horus bag is currently running.
///
/// Source: horus/pb/logs/logs.proto:1088:1
class HorusBagRunning final : public PbMessage {
 public:

  /// Constructs a default-initialized `HorusBagRunning`.
  HorusBagRunning() noexcept = default;

  /// Move constructor.
  HorusBagRunning(HorusBagRunning&&) noexcept = default;
  /// Move assignment operator.
  HorusBagRunning& operator=(HorusBagRunning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit HorusBagRunning(const HorusBagRunning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  HorusBagRunning& operator=(const HorusBagRunning&) = delete;

  /// Default destructor.
  ~HorusBagRunning() noexcept final = default;

  /// Creates a `HorusBagRunning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit HorusBagRunning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.HorusBagRunning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.HorusBagRunning"; }

  /// The full name of the message: `horus.pb.logs.HorusBagRunning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #143.
/// 
///  > Automatic ground calibration failed for the following lidars: $failed_lidar_ids.
///
/// Source: horus/pb/logs/logs.proto:1094:1
class AutoGroundCalibrationWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `AutoGroundCalibrationWarning`.
  AutoGroundCalibrationWarning() noexcept = default;

  /// Move constructor.
  AutoGroundCalibrationWarning(AutoGroundCalibrationWarning&&) noexcept = default;
  /// Move assignment operator.
  AutoGroundCalibrationWarning& operator=(AutoGroundCalibrationWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit AutoGroundCalibrationWarning(const AutoGroundCalibrationWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  AutoGroundCalibrationWarning& operator=(const AutoGroundCalibrationWarning&) = delete;

  /// Default destructor.
  ~AutoGroundCalibrationWarning() noexcept final = default;

  /// Creates a `AutoGroundCalibrationWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit AutoGroundCalibrationWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.AutoGroundCalibrationWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.AutoGroundCalibrationWarning"; }

  /// The full name of the message: `horus.pb.logs.AutoGroundCalibrationWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `failed_lidar_ids` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& failed_lidar_ids() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return failed_lidar_ids_;
  }

  /// If `failed_lidar_ids` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes failed_lidar_ids() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(failed_lidar_ids_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_failed_lidar_ids() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return failed_lidar_ids_;
  }

  /// Returns whether `failed_lidar_ids` (no 2) is set.
  constexpr bool has_failed_lidar_ids() const noexcept { return set_fields_[0]; }

  /// Clears `failed_lidar_ids` (no 2).
  void clear_failed_lidar_ids() & noexcept {
    set_fields_[0] = false;
    failed_lidar_ids_ = {};
  }

  /// Sets `failed_lidar_ids` (no 2) and returns `*this`.
  AutoGroundCalibrationWarning& set_failed_lidar_ids(CowBytes&& failed_lidar_ids) & noexcept {
    set_fields_[0] = true;
    failed_lidar_ids_ = std::move(failed_lidar_ids);
    return *this;
  }
  /// Sets `failed_lidar_ids` (no 2) and returns `*this`.
  AutoGroundCalibrationWarning&& set_failed_lidar_ids(CowBytes&& failed_lidar_ids) && noexcept {
    return std::move(set_failed_lidar_ids(std::move(failed_lidar_ids)));
  }

 private:
  /// @see failed_lidar_ids()
  CowBytes failed_lidar_ids_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #144.
/// 
///  > Automatic ground calibration failed for all lidars.
///
/// Source: horus/pb/logs/logs.proto:1101:1
class AutoGroundCalibrationError final : public PbMessage {
 public:

  /// Constructs a default-initialized `AutoGroundCalibrationError`.
  AutoGroundCalibrationError() noexcept = default;

  /// Move constructor.
  AutoGroundCalibrationError(AutoGroundCalibrationError&&) noexcept = default;
  /// Move assignment operator.
  AutoGroundCalibrationError& operator=(AutoGroundCalibrationError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit AutoGroundCalibrationError(const AutoGroundCalibrationError&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  AutoGroundCalibrationError& operator=(const AutoGroundCalibrationError&) = delete;

  /// Default destructor.
  ~AutoGroundCalibrationError() noexcept final = default;

  /// Creates a `AutoGroundCalibrationError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit AutoGroundCalibrationError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.AutoGroundCalibrationError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.AutoGroundCalibrationError"; }

  /// The full name of the message: `horus.pb.logs.AutoGroundCalibrationError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #151.
/// 
///  > The object detector is not loaded yet. Temporarily using rule based detection which may result in degraded detection results.
///
/// Source: horus/pb/logs/logs.proto:1107:1
class ObjectDetectorNotLoadedWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `ObjectDetectorNotLoadedWarning`.
  ObjectDetectorNotLoadedWarning() noexcept = default;

  /// Move constructor.
  ObjectDetectorNotLoadedWarning(ObjectDetectorNotLoadedWarning&&) noexcept = default;
  /// Move assignment operator.
  ObjectDetectorNotLoadedWarning& operator=(ObjectDetectorNotLoadedWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ObjectDetectorNotLoadedWarning(const ObjectDetectorNotLoadedWarning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ObjectDetectorNotLoadedWarning& operator=(const ObjectDetectorNotLoadedWarning&) = delete;

  /// Default destructor.
  ~ObjectDetectorNotLoadedWarning() noexcept final = default;

  /// Creates a `ObjectDetectorNotLoadedWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ObjectDetectorNotLoadedWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ObjectDetectorNotLoadedWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ObjectDetectorNotLoadedWarning"; }

  /// The full name of the message: `horus.pb.logs.ObjectDetectorNotLoadedWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #152.
/// 
///  > A calibration process is already running.
///
/// Source: horus/pb/logs/logs.proto:1113:1
class CalibrationIsRunningError final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationIsRunningError`.
  CalibrationIsRunningError() noexcept = default;

  /// Move constructor.
  CalibrationIsRunningError(CalibrationIsRunningError&&) noexcept = default;
  /// Move assignment operator.
  CalibrationIsRunningError& operator=(CalibrationIsRunningError&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationIsRunningError(const CalibrationIsRunningError&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationIsRunningError& operator=(const CalibrationIsRunningError&) = delete;

  /// Default destructor.
  ~CalibrationIsRunningError() noexcept final = default;

  /// Creates a `CalibrationIsRunningError` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationIsRunningError(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationIsRunningError`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationIsRunningError"; }

  /// The full name of the message: `horus.pb.logs.CalibrationIsRunningError`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Log #153.
/// 
///  > $component will start processing data once all models have finished initializing.
///
/// Source: horus/pb/logs/logs.proto:1119:1
class ModelInitInProgressInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `ModelInitInProgressInfo`.
  ModelInitInProgressInfo() noexcept = default;

  /// Move constructor.
  ModelInitInProgressInfo(ModelInitInProgressInfo&&) noexcept = default;
  /// Move assignment operator.
  ModelInitInProgressInfo& operator=(ModelInitInProgressInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit ModelInitInProgressInfo(const ModelInitInProgressInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  ModelInitInProgressInfo& operator=(const ModelInitInProgressInfo&) = delete;

  /// Default destructor.
  ~ModelInitInProgressInfo() noexcept final = default;

  /// Creates a `ModelInitInProgressInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit ModelInitInProgressInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.ModelInitInProgressInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.ModelInitInProgressInfo"; }

  /// The full name of the message: `horus.pb.logs.ModelInitInProgressInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `component` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& component() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return component_;
  }

  /// If `component` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes component() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(component_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_component() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return component_;
  }

  /// Returns whether `component` (no 1) is set.
  constexpr bool has_component() const noexcept { return set_fields_[0]; }

  /// Clears `component` (no 1).
  void clear_component() & noexcept {
    set_fields_[0] = false;
    component_ = {};
  }

  /// Sets `component` (no 1) and returns `*this`.
  ModelInitInProgressInfo& set_component(CowBytes&& component) & noexcept {
    set_fields_[0] = true;
    component_ = std::move(component);
    return *this;
  }
  /// Sets `component` (no 1) and returns `*this`.
  ModelInitInProgressInfo&& set_component(CowBytes&& component) && noexcept {
    return std::move(set_component(std::move(component)));
  }

 private:
  /// @see component()
  CowBytes component_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #154.
/// 
///  > RPC request "$request_name" to "$endpoint" timed out after $elapsed. Resolution: $resolution
///
/// Source: horus/pb/logs/logs.proto:1126:1
class RpcTimeoutWithResolutionWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `RpcTimeoutWithResolutionWarning`.
  RpcTimeoutWithResolutionWarning() noexcept = default;

  /// Move constructor.
  RpcTimeoutWithResolutionWarning(RpcTimeoutWithResolutionWarning&&) noexcept = default;
  /// Move assignment operator.
  RpcTimeoutWithResolutionWarning& operator=(RpcTimeoutWithResolutionWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit RpcTimeoutWithResolutionWarning(const RpcTimeoutWithResolutionWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  RpcTimeoutWithResolutionWarning& operator=(const RpcTimeoutWithResolutionWarning&) = delete;

  /// Default destructor.
  ~RpcTimeoutWithResolutionWarning() noexcept final = default;

  /// Creates a `RpcTimeoutWithResolutionWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit RpcTimeoutWithResolutionWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.RpcTimeoutWithResolutionWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.RpcTimeoutWithResolutionWarning"; }

  /// The full name of the message: `horus.pb.logs.RpcTimeoutWithResolutionWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `request_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& request_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return request_name_;
  }

  /// If `request_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes request_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(request_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_request_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return request_name_;
  }

  /// Returns whether `request_name` (no 1) is set.
  constexpr bool has_request_name() const noexcept { return set_fields_[0]; }

  /// Clears `request_name` (no 1).
  void clear_request_name() & noexcept {
    set_fields_[0] = false;
    request_name_ = {};
  }

  /// Sets `request_name` (no 1) and returns `*this`.
  RpcTimeoutWithResolutionWarning& set_request_name(CowBytes&& request_name) & noexcept {
    set_fields_[0] = true;
    request_name_ = std::move(request_name);
    return *this;
  }
  /// Sets `request_name` (no 1) and returns `*this`.
  RpcTimeoutWithResolutionWarning&& set_request_name(CowBytes&& request_name) && noexcept {
    return std::move(set_request_name(std::move(request_name)));
  }

  // Field `endpoint` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& endpoint() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return endpoint_;
  }

  /// If `endpoint` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes endpoint() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(endpoint_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_endpoint() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[1] = true;
    return endpoint_;
  }

  /// Returns whether `endpoint` (no 2) is set.
  constexpr bool has_endpoint() const noexcept { return set_fields_[1]; }

  /// Clears `endpoint` (no 2).
  void clear_endpoint() & noexcept {
    set_fields_[1] = false;
    endpoint_ = {};
  }

  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcTimeoutWithResolutionWarning& set_endpoint(CowBytes&& endpoint) & noexcept {
    set_fields_[1] = true;
    endpoint_ = std::move(endpoint);
    return *this;
  }
  /// Sets `endpoint` (no 2) and returns `*this`.
  RpcTimeoutWithResolutionWarning&& set_endpoint(CowBytes&& endpoint) && noexcept {
    return std::move(set_endpoint(std::move(endpoint)));
  }

  // Field `elapsed` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const horus::pb::LogMetadata_Duration& elapsed() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return elapsed_;
  }

  /// If `elapsed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration elapsed() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(elapsed_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  horus::pb::LogMetadata_Duration& mutable_elapsed() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[2] = true;
    return elapsed_;
  }

  /// Returns whether `elapsed` (no 3) is set.
  constexpr bool has_elapsed() const noexcept { return set_fields_[2]; }

  /// Clears `elapsed` (no 3).
  void clear_elapsed() & noexcept {
    set_fields_[2] = false;
    elapsed_ = {};
  }

  /// Sets `elapsed` (no 3) and returns `*this`.
  RpcTimeoutWithResolutionWarning& set_elapsed(horus::pb::LogMetadata_Duration&& elapsed) & noexcept {
    set_fields_[2] = true;
    elapsed_ = std::move(elapsed);
    return *this;
  }
  /// Sets `elapsed` (no 3) and returns `*this`.
  RpcTimeoutWithResolutionWarning&& set_elapsed(horus::pb::LogMetadata_Duration&& elapsed) && noexcept {
    return std::move(set_elapsed(std::move(elapsed)));
  }

  // Field `resolution` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const CowBytes& resolution() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return resolution_;
  }

  /// If `resolution` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  CowBytes resolution() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(resolution_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  CowBytes& mutable_resolution() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[3] = true;
    return resolution_;
  }

  /// Returns whether `resolution` (no 4) is set.
  constexpr bool has_resolution() const noexcept { return set_fields_[3]; }

  /// Clears `resolution` (no 4).
  void clear_resolution() & noexcept {
    set_fields_[3] = false;
    resolution_ = {};
  }

  /// Sets `resolution` (no 4) and returns `*this`.
  RpcTimeoutWithResolutionWarning& set_resolution(CowBytes&& resolution) & noexcept {
    set_fields_[3] = true;
    resolution_ = std::move(resolution);
    return *this;
  }
  /// Sets `resolution` (no 4) and returns `*this`.
  RpcTimeoutWithResolutionWarning&& set_resolution(CowBytes&& resolution) && noexcept {
    return std::move(set_resolution(std::move(resolution)));
  }

 private:
  /// @see request_name()
  CowBytes request_name_{};
  /// @see endpoint()
  CowBytes endpoint_{};
  /// @see elapsed()
  horus::pb::LogMetadata_Duration elapsed_{};
  /// @see resolution()
  CowBytes resolution_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// Log #155.
/// 
///  > The $calibration_process_name process was cancelled.
///
/// Source: horus/pb/logs/logs.proto:1136:1
class CalibrationWasCancelledInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationWasCancelledInfo`.
  CalibrationWasCancelledInfo() noexcept = default;

  /// Move constructor.
  CalibrationWasCancelledInfo(CalibrationWasCancelledInfo&&) noexcept = default;
  /// Move assignment operator.
  CalibrationWasCancelledInfo& operator=(CalibrationWasCancelledInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationWasCancelledInfo(const CalibrationWasCancelledInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationWasCancelledInfo& operator=(const CalibrationWasCancelledInfo&) = delete;

  /// Default destructor.
  ~CalibrationWasCancelledInfo() noexcept final = default;

  /// Creates a `CalibrationWasCancelledInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationWasCancelledInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationWasCancelledInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationWasCancelledInfo"; }

  /// The full name of the message: `horus.pb.logs.CalibrationWasCancelledInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `calibration_process_name` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& calibration_process_name() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return calibration_process_name_;
  }

  /// If `calibration_process_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes calibration_process_name() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(calibration_process_name_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_calibration_process_name() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return calibration_process_name_;
  }

  /// Returns whether `calibration_process_name` (no 1) is set.
  constexpr bool has_calibration_process_name() const noexcept { return set_fields_[0]; }

  /// Clears `calibration_process_name` (no 1).
  void clear_calibration_process_name() & noexcept {
    set_fields_[0] = false;
    calibration_process_name_ = {};
  }

  /// Sets `calibration_process_name` (no 1) and returns `*this`.
  CalibrationWasCancelledInfo& set_calibration_process_name(CowBytes&& calibration_process_name) & noexcept {
    set_fields_[0] = true;
    calibration_process_name_ = std::move(calibration_process_name);
    return *this;
  }
  /// Sets `calibration_process_name` (no 1) and returns `*this`.
  CalibrationWasCancelledInfo&& set_calibration_process_name(CowBytes&& calibration_process_name) && noexcept {
    return std::move(set_calibration_process_name(std::move(calibration_process_name)));
  }

 private:
  /// @see calibration_process_name()
  CowBytes calibration_process_name_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #156.
/// 
///  > Failed to start recording the calibration map: $path
///
/// Source: horus/pb/logs/logs.proto:1143:1
class CalibrationMapRecordingFailedToStart final : public PbMessage {
 public:

  /// Constructs a default-initialized `CalibrationMapRecordingFailedToStart`.
  CalibrationMapRecordingFailedToStart() noexcept = default;

  /// Move constructor.
  CalibrationMapRecordingFailedToStart(CalibrationMapRecordingFailedToStart&&) noexcept = default;
  /// Move assignment operator.
  CalibrationMapRecordingFailedToStart& operator=(CalibrationMapRecordingFailedToStart&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CalibrationMapRecordingFailedToStart(const CalibrationMapRecordingFailedToStart& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CalibrationMapRecordingFailedToStart& operator=(const CalibrationMapRecordingFailedToStart&) = delete;

  /// Default destructor.
  ~CalibrationMapRecordingFailedToStart() noexcept final = default;

  /// Creates a `CalibrationMapRecordingFailedToStart` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CalibrationMapRecordingFailedToStart(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CalibrationMapRecordingFailedToStart`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CalibrationMapRecordingFailedToStart"; }

  /// The full name of the message: `horus.pb.logs.CalibrationMapRecordingFailedToStart`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `path` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& path() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return path_;
  }

  /// If `path` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes path() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(path_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_path() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return path_;
  }

  /// Returns whether `path` (no 1) is set.
  constexpr bool has_path() const noexcept { return set_fields_[0]; }

  /// Clears `path` (no 1).
  void clear_path() & noexcept {
    set_fields_[0] = false;
    path_ = {};
  }

  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapRecordingFailedToStart& set_path(CowBytes&& path) & noexcept {
    set_fields_[0] = true;
    path_ = std::move(path);
    return *this;
  }
  /// Sets `path` (no 1) and returns `*this`.
  CalibrationMapRecordingFailedToStart&& set_path(CowBytes&& path) && noexcept {
    return std::move(set_path(std::move(path)));
  }

 private:
  /// @see path()
  CowBytes path_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #157.
/// 
///  > The detection pipeline has been requested to be reset because $reason.
///
/// Source: horus/pb/logs/logs.proto:1150:1
class DetectionPipelineRequestedResetInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectionPipelineRequestedResetInfo`.
  DetectionPipelineRequestedResetInfo() noexcept = default;

  /// Move constructor.
  DetectionPipelineRequestedResetInfo(DetectionPipelineRequestedResetInfo&&) noexcept = default;
  /// Move assignment operator.
  DetectionPipelineRequestedResetInfo& operator=(DetectionPipelineRequestedResetInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectionPipelineRequestedResetInfo(const DetectionPipelineRequestedResetInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectionPipelineRequestedResetInfo& operator=(const DetectionPipelineRequestedResetInfo&) = delete;

  /// Default destructor.
  ~DetectionPipelineRequestedResetInfo() noexcept final = default;

  /// Creates a `DetectionPipelineRequestedResetInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectionPipelineRequestedResetInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.DetectionPipelineRequestedResetInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.DetectionPipelineRequestedResetInfo"; }

  /// The full name of the message: `horus.pb.logs.DetectionPipelineRequestedResetInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `reason` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& reason() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return reason_;
  }

  /// If `reason` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes reason() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(reason_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_reason() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return reason_;
  }

  /// Returns whether `reason` (no 1) is set.
  constexpr bool has_reason() const noexcept { return set_fields_[0]; }

  /// Clears `reason` (no 1).
  void clear_reason() & noexcept {
    set_fields_[0] = false;
    reason_ = {};
  }

  /// Sets `reason` (no 1) and returns `*this`.
  DetectionPipelineRequestedResetInfo& set_reason(CowBytes&& reason) & noexcept {
    set_fields_[0] = true;
    reason_ = std::move(reason);
    return *this;
  }
  /// Sets `reason` (no 1) and returns `*this`.
  DetectionPipelineRequestedResetInfo&& set_reason(CowBytes&& reason) && noexcept {
    return std::move(set_reason(std::move(reason)));
  }

 private:
  /// @see reason()
  CowBytes reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #158.
/// 
///  > Preprocessing service pipeline is not available yet due to $reason.
///
/// Source: horus/pb/logs/logs.proto:1157:1
class PreprocessingServicePipelineUnavailable final : public PbMessage {
 public:

  /// Constructs a default-initialized `PreprocessingServicePipelineUnavailable`.
  PreprocessingServicePipelineUnavailable() noexcept = default;

  /// Move constructor.
  PreprocessingServicePipelineUnavailable(PreprocessingServicePipelineUnavailable&&) noexcept = default;
  /// Move assignment operator.
  PreprocessingServicePipelineUnavailable& operator=(PreprocessingServicePipelineUnavailable&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit PreprocessingServicePipelineUnavailable(const PreprocessingServicePipelineUnavailable& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  PreprocessingServicePipelineUnavailable& operator=(const PreprocessingServicePipelineUnavailable&) = delete;

  /// Default destructor.
  ~PreprocessingServicePipelineUnavailable() noexcept final = default;

  /// Creates a `PreprocessingServicePipelineUnavailable` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit PreprocessingServicePipelineUnavailable(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.PreprocessingServicePipelineUnavailable`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.PreprocessingServicePipelineUnavailable"; }

  /// The full name of the message: `horus.pb.logs.PreprocessingServicePipelineUnavailable`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `reason` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& reason() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return reason_;
  }

  /// If `reason` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes reason() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(reason_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_reason() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return reason_;
  }

  /// Returns whether `reason` (no 1) is set.
  constexpr bool has_reason() const noexcept { return set_fields_[0]; }

  /// Clears `reason` (no 1).
  void clear_reason() & noexcept {
    set_fields_[0] = false;
    reason_ = {};
  }

  /// Sets `reason` (no 1) and returns `*this`.
  PreprocessingServicePipelineUnavailable& set_reason(CowBytes&& reason) & noexcept {
    set_fields_[0] = true;
    reason_ = std::move(reason);
    return *this;
  }
  /// Sets `reason` (no 1) and returns `*this`.
  PreprocessingServicePipelineUnavailable&& set_reason(CowBytes&& reason) && noexcept {
    return std::move(set_reason(std::move(reason)));
  }

 private:
  /// @see reason()
  CowBytes reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #159.
/// 
///  > The circular recording is disabled: $reason
///
/// Source: horus/pb/logs/logs.proto:1164:1
class CircularRecordingDisabledWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `CircularRecordingDisabledWarning`.
  CircularRecordingDisabledWarning() noexcept = default;

  /// Move constructor.
  CircularRecordingDisabledWarning(CircularRecordingDisabledWarning&&) noexcept = default;
  /// Move assignment operator.
  CircularRecordingDisabledWarning& operator=(CircularRecordingDisabledWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit CircularRecordingDisabledWarning(const CircularRecordingDisabledWarning& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  CircularRecordingDisabledWarning& operator=(const CircularRecordingDisabledWarning&) = delete;

  /// Default destructor.
  ~CircularRecordingDisabledWarning() noexcept final = default;

  /// Creates a `CircularRecordingDisabledWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit CircularRecordingDisabledWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.CircularRecordingDisabledWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.CircularRecordingDisabledWarning"; }

  /// The full name of the message: `horus.pb.logs.CircularRecordingDisabledWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `reason` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& reason() const& noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    return reason_;
  }

  /// If `reason` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes reason() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(reason_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_reason() & noexcept HORUS_SDK_ATTRIBUTE_LIFETIME_BOUND {
    set_fields_[0] = true;
    return reason_;
  }

  /// Returns whether `reason` (no 1) is set.
  constexpr bool has_reason() const noexcept { return set_fields_[0]; }

  /// Clears `reason` (no 1).
  void clear_reason() & noexcept {
    set_fields_[0] = false;
    reason_ = {};
  }

  /// Sets `reason` (no 1) and returns `*this`.
  CircularRecordingDisabledWarning& set_reason(CowBytes&& reason) & noexcept {
    set_fields_[0] = true;
    reason_ = std::move(reason);
    return *this;
  }
  /// Sets `reason` (no 1) and returns `*this`.
  CircularRecordingDisabledWarning&& set_reason(CowBytes&& reason) && noexcept {
    return std::move(set_reason(std::move(reason)));
  }

 private:
  /// @see reason()
  CowBytes reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Log #160.
/// 
///  > A snapshot is already running.
///
/// Source: horus/pb/logs/logs.proto:1171:1
class SnapshotAlreadyRunningWarning final : public PbMessage {
 public:

  /// Constructs a default-initialized `SnapshotAlreadyRunningWarning`.
  SnapshotAlreadyRunningWarning() noexcept = default;

  /// Move constructor.
  SnapshotAlreadyRunningWarning(SnapshotAlreadyRunningWarning&&) noexcept = default;
  /// Move assignment operator.
  SnapshotAlreadyRunningWarning& operator=(SnapshotAlreadyRunningWarning&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit SnapshotAlreadyRunningWarning(const SnapshotAlreadyRunningWarning&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  SnapshotAlreadyRunningWarning& operator=(const SnapshotAlreadyRunningWarning&) = delete;

  /// Default destructor.
  ~SnapshotAlreadyRunningWarning() noexcept final = default;

  /// Creates a `SnapshotAlreadyRunningWarning` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit SnapshotAlreadyRunningWarning(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.logs.SnapshotAlreadyRunningWarning`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.logs.SnapshotAlreadyRunningWarning"; }

  /// The full name of the message: `horus.pb.logs.SnapshotAlreadyRunningWarning`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

}  // namespace logs
}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_LOGS_LOGS_PB_H_
