#ifndef HORUS_PB_LOGS_METADATA_PB_H_
#define HORUS_PB_LOGS_METADATA_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/logs/metadata.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/cow_bytes.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/pb/types.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Enum declarations

/// Severity of a log message.
/// 
///  Must be kept in sync with backend/common/logs/common.h.
///
/// Source: horus/pb/logs/metadata.proto:10:3
enum class LogMetadata_Severity : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// No documentation.
  kDebug = 1,
  /// No documentation.
  kInfo = 2,
  /// No documentation.
  kWarning = 3,
  /// No documentation.
  kError = 4,
  /// No documentation.
  kFatal = 5,

  /// Unknown value read from the wire.
  kUnknownWireValue = 6,
};

// MARK: Message forward declarations

class LogMetadata_SourceLocation;
class LogMetadata_Duration;
class LogMetadata_Timestamp;
class LogMetadata;

// MARK: Message declarations

/// Location in source code where a log was created.
///
/// Source: horus/pb/logs/metadata.proto:20:3
class LogMetadata_SourceLocation final : public PbMessage {
 public:

  /// Constructs a default-initialized `LogMetadata_SourceLocation`.
  LogMetadata_SourceLocation() noexcept = default;

  /// Move constructor.
  LogMetadata_SourceLocation(LogMetadata_SourceLocation&&) noexcept = default;
  /// Move assignment operator.
  LogMetadata_SourceLocation& operator=(LogMetadata_SourceLocation&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogMetadata_SourceLocation(const LogMetadata_SourceLocation& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogMetadata_SourceLocation& operator=(const LogMetadata_SourceLocation&) = delete;

  /// Default destructor.
  ~LogMetadata_SourceLocation() noexcept final = default;

  /// Creates a `LogMetadata_SourceLocation` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogMetadata_SourceLocation(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogMetadata.SourceLocation`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogMetadata.SourceLocation"; }

  /// The full name of the message: `horus.pb.LogMetadata.SourceLocation`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `file` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const CowBytes& file() const& noexcept HORUS_LIFETIME_BOUND {
    return file_;
  }

  /// If `file` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes file() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(file_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  CowBytes& mutable_file() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return file_;
  }

  /// Returns whether `file` (no 1) is set.
  constexpr bool has_file() const noexcept { return set_fields_[0]; }

  /// Clears `file` (no 1).
  void clear_file() & noexcept {
    set_fields_[0] = false;
    file_ = {};
  }

  /// Sets `file` (no 1) and returns `*this`.
  LogMetadata_SourceLocation& set_file(CowBytes&& file) & noexcept {
    set_fields_[0] = true;
    file_ = std::move(file);
    return *this;
  }
  /// Sets `file` (no 1) and returns `*this`.
  LogMetadata_SourceLocation&& set_file(CowBytes&& file) && noexcept {
    return std::move(set_file(std::move(file)));
  }

  // Field `line` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr std::uint32_t line() const& noexcept HORUS_LIFETIME_BOUND {
    return line_;
  }

  /// No documentation.
  ///
  /// Field no: 2.
  std::uint32_t& mutable_line() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return line_;
  }

  /// Returns whether `line` (no 2) is set.
  constexpr bool has_line() const noexcept { return set_fields_[1]; }

  /// Clears `line` (no 2).
  void clear_line() & noexcept {
    set_fields_[1] = false;
    line_ = {};
  }

  /// Sets `line` (no 2) and returns `*this`.
  LogMetadata_SourceLocation& set_line(std::uint32_t line) & noexcept {
    set_fields_[1] = true;
    line_ = line;
    return *this;
  }
  /// Sets `line` (no 2) and returns `*this`.
  LogMetadata_SourceLocation&& set_line(std::uint32_t line) && noexcept {
    return std::move(set_line(line));
  }

 private:
  /// @see file()
  CowBytes file_{};
  /// @see line()
  std::uint32_t line_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// Duration in time.
///
/// Source: horus/pb/logs/metadata.proto:26:3
class LogMetadata_Duration final : public PbMessage {
 public:

  /// Constructs a default-initialized `LogMetadata_Duration`.
  LogMetadata_Duration() noexcept = default;

  /// Move constructor.
  LogMetadata_Duration(LogMetadata_Duration&&) noexcept = default;
  /// Move assignment operator.
  LogMetadata_Duration& operator=(LogMetadata_Duration&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogMetadata_Duration(const LogMetadata_Duration& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogMetadata_Duration& operator=(const LogMetadata_Duration&) = delete;

  /// Default destructor.
  ~LogMetadata_Duration() noexcept final = default;

  /// Creates a `LogMetadata_Duration` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogMetadata_Duration(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogMetadata.Duration`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogMetadata.Duration"; }

  /// The full name of the message: `horus.pb.LogMetadata.Duration`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `ms` (no 1).
  // -----

  /// We don't care about sub-ms accuracy.
  ///
  /// Field no: 1.
  constexpr std::uint64_t ms() const& noexcept HORUS_LIFETIME_BOUND {
    return ms_;
  }

  /// We don't care about sub-ms accuracy.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_ms() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return ms_;
  }

  /// Returns whether `ms` (no 1) is set.
  constexpr bool has_ms() const noexcept { return set_fields_[0]; }

  /// Clears `ms` (no 1).
  void clear_ms() & noexcept {
    set_fields_[0] = false;
    ms_ = {};
  }

  /// Sets `ms` (no 1) and returns `*this`.
  LogMetadata_Duration& set_ms(std::uint64_t ms) & noexcept {
    set_fields_[0] = true;
    ms_ = ms;
    return *this;
  }
  /// Sets `ms` (no 1) and returns `*this`.
  LogMetadata_Duration&& set_ms(std::uint64_t ms) && noexcept {
    return std::move(set_ms(ms));
  }

 private:
  /// @see ms()
  std::uint64_t ms_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Timestamp in time.
///
/// Source: horus/pb/logs/metadata.proto:31:3
class LogMetadata_Timestamp final : public PbMessage {
 public:

  /// Constructs a default-initialized `LogMetadata_Timestamp`.
  LogMetadata_Timestamp() noexcept = default;

  /// Move constructor.
  LogMetadata_Timestamp(LogMetadata_Timestamp&&) noexcept = default;
  /// Move assignment operator.
  LogMetadata_Timestamp& operator=(LogMetadata_Timestamp&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogMetadata_Timestamp(const LogMetadata_Timestamp& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogMetadata_Timestamp& operator=(const LogMetadata_Timestamp&) = delete;

  /// Default destructor.
  ~LogMetadata_Timestamp() noexcept final = default;

  /// Creates a `LogMetadata_Timestamp` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogMetadata_Timestamp(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogMetadata.Timestamp`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogMetadata.Timestamp"; }

  /// The full name of the message: `horus.pb.LogMetadata.Timestamp`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `ms_since_epoch` (no 1).
  // -----

  /// We don't care about sub-ms accuracy.
  ///
  /// Field no: 1.
  constexpr std::uint64_t ms_since_epoch() const& noexcept HORUS_LIFETIME_BOUND {
    return ms_since_epoch_;
  }

  /// We don't care about sub-ms accuracy.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_ms_since_epoch() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return ms_since_epoch_;
  }

  /// Returns whether `ms_since_epoch` (no 1) is set.
  constexpr bool has_ms_since_epoch() const noexcept { return set_fields_[0]; }

  /// Clears `ms_since_epoch` (no 1).
  void clear_ms_since_epoch() & noexcept {
    set_fields_[0] = false;
    ms_since_epoch_ = {};
  }

  /// Sets `ms_since_epoch` (no 1) and returns `*this`.
  LogMetadata_Timestamp& set_ms_since_epoch(std::uint64_t ms_since_epoch) & noexcept {
    set_fields_[0] = true;
    ms_since_epoch_ = ms_since_epoch;
    return *this;
  }
  /// Sets `ms_since_epoch` (no 1) and returns `*this`.
  LogMetadata_Timestamp&& set_ms_since_epoch(std::uint64_t ms_since_epoch) && noexcept {
    return std::move(set_ms_since_epoch(ms_since_epoch));
  }

 private:
  /// @see ms_since_epoch()
  std::uint64_t ms_since_epoch_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// Metadata attached to a `LogMessage`.
///
/// Source: horus/pb/logs/metadata.proto:6:1
class LogMetadata final : public PbMessage {
 public:
  /// @see LogMetadata_Duration
  using Duration = LogMetadata_Duration;
  /// @see LogMetadata_Severity
  using Severity = LogMetadata_Severity;
  /// @see LogMetadata_SourceLocation
  using SourceLocation = LogMetadata_SourceLocation;
  /// @see LogMetadata_Timestamp
  using Timestamp = LogMetadata_Timestamp;

  /// Constructs a default-initialized `LogMetadata`.
  LogMetadata() noexcept = default;

  /// Move constructor.
  LogMetadata(LogMetadata&&) noexcept = default;
  /// Move assignment operator.
  LogMetadata& operator=(LogMetadata&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogMetadata(const LogMetadata& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogMetadata& operator=(const LogMetadata&) = delete;

  /// Default destructor.
  ~LogMetadata() noexcept final = default;

  /// Creates a `LogMetadata` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogMetadata(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogMetadata`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogMetadata"; }

  /// The full name of the message: `horus.pb.LogMetadata`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `ms_since_epoch` (no 1).
  // -----

  /// Time at which the log was generated represented as the number of ms since
  ///  the epoch.
  /// 
  ///  `Timestamp` is not used here since it is processed by our plugin, which
  ///  depends on `horus::common`, which depends on this file.
  ///
  /// Field no: 1.
  constexpr std::uint64_t ms_since_epoch() const& noexcept HORUS_LIFETIME_BOUND {
    return ms_since_epoch_;
  }

  /// Time at which the log was generated represented as the number of ms since
  ///  the epoch.
  /// 
  ///  `Timestamp` is not used here since it is processed by our plugin, which
  ///  depends on `horus::common`, which depends on this file.
  ///
  /// Field no: 1.
  std::uint64_t& mutable_ms_since_epoch() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return ms_since_epoch_;
  }

  /// Returns whether `ms_since_epoch` (no 1) is set.
  constexpr bool has_ms_since_epoch() const noexcept { return set_fields_[0]; }

  /// Clears `ms_since_epoch` (no 1).
  void clear_ms_since_epoch() & noexcept {
    set_fields_[0] = false;
    ms_since_epoch_ = {};
  }

  /// Sets `ms_since_epoch` (no 1) and returns `*this`.
  LogMetadata& set_ms_since_epoch(std::uint64_t ms_since_epoch) & noexcept {
    set_fields_[0] = true;
    ms_since_epoch_ = ms_since_epoch;
    return *this;
  }
  /// Sets `ms_since_epoch` (no 1) and returns `*this`.
  LogMetadata&& set_ms_since_epoch(std::uint64_t ms_since_epoch) && noexcept {
    return std::move(set_ms_since_epoch(ms_since_epoch));
  }

  // Field `severity` (no 2).
  // -----

  /// Severity of the log.
  ///
  /// Field no: 2.
  constexpr LogMetadata_Severity severity() const& noexcept HORUS_LIFETIME_BOUND {
    return severity_;
  }

  /// Severity of the log.
  ///
  /// Field no: 2.
  LogMetadata_Severity& mutable_severity() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return severity_;
  }

  /// Returns whether `severity` (no 2) is set.
  constexpr bool has_severity() const noexcept { return set_fields_[1]; }

  /// Clears `severity` (no 2).
  void clear_severity() & noexcept {
    set_fields_[1] = false;
    severity_ = {};
  }

  /// Sets `severity` (no 2) and returns `*this`.
  LogMetadata& set_severity(LogMetadata_Severity severity) & noexcept {
    set_fields_[1] = true;
    severity_ = severity;
    return *this;
  }
  /// Sets `severity` (no 2) and returns `*this`.
  LogMetadata&& set_severity(LogMetadata_Severity severity) && noexcept {
    return std::move(set_severity(severity));
  }

  // Field `node_id` (no 3).
  // -----

  /// Identifier of the node that sent the log.
  ///
  /// Field no: 3.
  constexpr const CowBytes& node_id() const& noexcept HORUS_LIFETIME_BOUND {
    return node_id_;
  }

  /// If `node_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowBytes node_id() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(node_id_);
  }

  /// Identifier of the node that sent the log.
  ///
  /// Field no: 3.
  CowBytes& mutable_node_id() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return node_id_;
  }

  /// Returns whether `node_id` (no 3) is set.
  constexpr bool has_node_id() const noexcept { return set_fields_[2]; }

  /// Clears `node_id` (no 3).
  void clear_node_id() & noexcept {
    set_fields_[2] = false;
    node_id_ = {};
  }

  /// Sets `node_id` (no 3) and returns `*this`.
  LogMetadata& set_node_id(CowBytes&& node_id) & noexcept {
    set_fields_[2] = true;
    node_id_ = std::move(node_id);
    return *this;
  }
  /// Sets `node_id` (no 3) and returns `*this`.
  LogMetadata&& set_node_id(CowBytes&& node_id) && noexcept {
    return std::move(set_node_id(std::move(node_id)));
  }

 private:
  /// @see ms_since_epoch()
  std::uint64_t ms_since_epoch_{};
  /// @see severity()
  LogMetadata_Severity severity_{};
  /// @see node_id()
  CowBytes node_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// MARK: Enum traits

namespace horus {

template <>
class PbEnumTraits<horus::sdk::pb::LogMetadata_Severity> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.LogMetadata.Severity`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.LogMetadata.Severity"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::LogMetadata_Severity value) noexcept {
    switch (value) {
      case horus::sdk::pb::LogMetadata_Severity::kUnspecified: {
        return "SEVERITY_UNSPECIFIED";
      }
      case horus::sdk::pb::LogMetadata_Severity::kDebug: {
        return "SEVERITY_DEBUG";
      }
      case horus::sdk::pb::LogMetadata_Severity::kInfo: {
        return "SEVERITY_INFO";
      }
      case horus::sdk::pb::LogMetadata_Severity::kWarning: {
        return "SEVERITY_WARNING";
      }
      case horus::sdk::pb::LogMetadata_Severity::kError: {
        return "SEVERITY_ERROR";
      }
      case horus::sdk::pb::LogMetadata_Severity::kFatal: {
        return "SEVERITY_FATAL";
      }
      case horus::sdk::pb::LogMetadata_Severity::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::LogMetadata_Severity ValueOf(PbEnum value, horus::sdk::pb::LogMetadata_Severity default_value = horus::sdk::pb::LogMetadata_Severity::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::LogMetadata_Severity::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::LogMetadata_Severity::kDebug;
      }
      case 2: {
        return horus::sdk::pb::LogMetadata_Severity::kInfo;
      }
      case 3: {
        return horus::sdk::pb::LogMetadata_Severity::kWarning;
      }
      case 4: {
        return horus::sdk::pb::LogMetadata_Severity::kError;
      }
      case 5: {
        return horus::sdk::pb::LogMetadata_Severity::kFatal;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::LogMetadata_Severity ValueOf(StringView name, horus::sdk::pb::LogMetadata_Severity default_value = horus::sdk::pb::LogMetadata_Severity::kUnknownWireValue) noexcept {
    if (name == "SEVERITY_UNSPECIFIED") {
      return horus::sdk::pb::LogMetadata_Severity::kUnspecified;
    }
    if (name == "SEVERITY_DEBUG") {
      return horus::sdk::pb::LogMetadata_Severity::kDebug;
    }
    if (name == "SEVERITY_INFO") {
      return horus::sdk::pb::LogMetadata_Severity::kInfo;
    }
    if (name == "SEVERITY_WARNING") {
      return horus::sdk::pb::LogMetadata_Severity::kWarning;
    }
    if (name == "SEVERITY_ERROR") {
      return horus::sdk::pb::LogMetadata_Severity::kError;
    }
    if (name == "SEVERITY_FATAL") {
      return horus::sdk::pb::LogMetadata_Severity::kFatal;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::LogMetadata_Severity> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::LogMetadata_Severity value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::LogMetadata_Severity` from `reader`.
  static horus::sdk::pb::LogMetadata_Severity Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::LogMetadata_Severity>::ValueOf(reader.Reader().get_enum());
  }
};

}  // namespace horus

namespace horus {
namespace sdk {
namespace pb {

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, LogMetadata_Severity value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<LogMetadata_Severity>::NameOf(value));
}

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_LOGS_METADATA_PB_H_
