#ifndef HORUS_PB_LOGS_MESSAGE_PB_H_
#define HORUS_PB_LOGS_MESSAGE_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/logs/message.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/logs/logs_pb.h"
#include "horus/pb/logs/metadata_pb.h"
#include "horus/pb/message.h"
#include "horus/pb/serialize.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Message forward declarations

class LogData;
class LogMessage;

// MARK: Message declarations

/// Data attached to a `LogMessage`.
/// 
///  This is automatically generated from `/home/runner/work/horus/horus/common/logs/db.yml`.
///
/// Source: horus/pb/logs/message.proto:17:1
class LogData final : public PbMessage {
 public:

  /// Constructs a default-initialized `LogData`.
  LogData() noexcept = default;

  /// Move constructor.
  LogData(LogData&&) noexcept = default;
  /// Move assignment operator.
  LogData& operator=(LogData&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogData(const LogData& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogData& operator=(const LogData&) = delete;

  /// Default destructor.
  ~LogData() noexcept final = default;

  /// Creates a `LogData` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogData(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogData`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogData"; }

  /// The full name of the message: `horus.pb.LogData`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `generic` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::Generic& generic() const& noexcept HORUS_LIFETIME_BOUND {
    return generic_;
  }

  /// If `generic` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::Generic generic() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(generic_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::Generic& mutable_generic() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kGeneric;
    set_fields_[0] = true;
    return generic_;
  }

  /// Returns whether `generic` (no 1) is set.
  constexpr bool has_generic() const noexcept { return set_fields_[0]; }

  /// Clears `generic` (no 1).
  void clear_generic() & noexcept {
    data_ = {};
    set_fields_[0] = false;
    generic_ = {};
  }

  /// Sets `generic` (no 1) and returns `*this`.
  LogData& set_generic(logs::Generic&& generic) & noexcept {
    clear_data();
    data_ = DataOneof::kGeneric;
    set_fields_[0] = true;
    generic_ = std::move(generic);
    return *this;
  }
  /// Sets `generic` (no 1) and returns `*this`.
  LogData&& set_generic(logs::Generic&& generic) && noexcept {
    return std::move(set_generic(std::move(generic)));
  }

  // Field `oom` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const logs::Oom& oom() const& noexcept HORUS_LIFETIME_BOUND {
    return oom_;
  }

  /// If `oom` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  logs::Oom oom() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(oom_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  logs::Oom& mutable_oom() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kOom;
    set_fields_[1] = true;
    return oom_;
  }

  /// Returns whether `oom` (no 2) is set.
  constexpr bool has_oom() const noexcept { return set_fields_[1]; }

  /// Clears `oom` (no 2).
  void clear_oom() & noexcept {
    data_ = {};
    set_fields_[1] = false;
    oom_ = {};
  }

  /// Sets `oom` (no 2) and returns `*this`.
  LogData& set_oom(logs::Oom&& oom) & noexcept {
    clear_data();
    data_ = DataOneof::kOom;
    set_fields_[1] = true;
    oom_ = std::move(oom);
    return *this;
  }
  /// Sets `oom` (no 2) and returns `*this`.
  LogData&& set_oom(logs::Oom&& oom) && noexcept {
    return std::move(set_oom(std::move(oom)));
  }

  // Field `rpc_connection_error` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const logs::RpcConnectionError& rpc_connection_error() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_connection_error_;
  }

  /// If `rpc_connection_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  logs::RpcConnectionError rpc_connection_error() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(rpc_connection_error_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  logs::RpcConnectionError& mutable_rpc_connection_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcConnectionError;
    set_fields_[2] = true;
    return rpc_connection_error_;
  }

  /// Returns whether `rpc_connection_error` (no 3) is set.
  constexpr bool has_rpc_connection_error() const noexcept { return set_fields_[2]; }

  /// Clears `rpc_connection_error` (no 3).
  void clear_rpc_connection_error() & noexcept {
    data_ = {};
    set_fields_[2] = false;
    rpc_connection_error_ = {};
  }

  /// Sets `rpc_connection_error` (no 3) and returns `*this`.
  LogData& set_rpc_connection_error(logs::RpcConnectionError&& rpc_connection_error) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcConnectionError;
    set_fields_[2] = true;
    rpc_connection_error_ = std::move(rpc_connection_error);
    return *this;
  }
  /// Sets `rpc_connection_error` (no 3) and returns `*this`.
  LogData&& set_rpc_connection_error(logs::RpcConnectionError&& rpc_connection_error) && noexcept {
    return std::move(set_rpc_connection_error(std::move(rpc_connection_error)));
  }

  // Field `invalid_project_name` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const logs::InvalidProjectName& invalid_project_name() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_project_name_;
  }

  /// If `invalid_project_name` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  logs::InvalidProjectName invalid_project_name() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(invalid_project_name_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  logs::InvalidProjectName& mutable_invalid_project_name() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidProjectName;
    set_fields_[3] = true;
    return invalid_project_name_;
  }

  /// Returns whether `invalid_project_name` (no 4) is set.
  constexpr bool has_invalid_project_name() const noexcept { return set_fields_[3]; }

  /// Clears `invalid_project_name` (no 4).
  void clear_invalid_project_name() & noexcept {
    data_ = {};
    set_fields_[3] = false;
    invalid_project_name_ = {};
  }

  /// Sets `invalid_project_name` (no 4) and returns `*this`.
  LogData& set_invalid_project_name(logs::InvalidProjectName&& invalid_project_name) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidProjectName;
    set_fields_[3] = true;
    invalid_project_name_ = std::move(invalid_project_name);
    return *this;
  }
  /// Sets `invalid_project_name` (no 4) and returns `*this`.
  LogData&& set_invalid_project_name(logs::InvalidProjectName&& invalid_project_name) && noexcept {
    return std::move(set_invalid_project_name(std::move(invalid_project_name)));
  }

  // Field `project_not_found` (no 5).
  // -----

  /// No documentation.
  ///
  /// Field no: 5.
  constexpr const logs::ProjectNotFound& project_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return project_not_found_;
  }

  /// If `project_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 5.
  logs::ProjectNotFound project_not_found() && noexcept {
    if (!set_fields_[4]) {
      return {};
    }
    return std::move(project_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 5.
  logs::ProjectNotFound& mutable_project_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kProjectNotFound;
    set_fields_[4] = true;
    return project_not_found_;
  }

  /// Returns whether `project_not_found` (no 5) is set.
  constexpr bool has_project_not_found() const noexcept { return set_fields_[4]; }

  /// Clears `project_not_found` (no 5).
  void clear_project_not_found() & noexcept {
    data_ = {};
    set_fields_[4] = false;
    project_not_found_ = {};
  }

  /// Sets `project_not_found` (no 5) and returns `*this`.
  LogData& set_project_not_found(logs::ProjectNotFound&& project_not_found) & noexcept {
    clear_data();
    data_ = DataOneof::kProjectNotFound;
    set_fields_[4] = true;
    project_not_found_ = std::move(project_not_found);
    return *this;
  }
  /// Sets `project_not_found` (no 5) and returns `*this`.
  LogData&& set_project_not_found(logs::ProjectNotFound&& project_not_found) && noexcept {
    return std::move(set_project_not_found(std::move(project_not_found)));
  }

  // Field `project_already_exists` (no 6).
  // -----

  /// No documentation.
  ///
  /// Field no: 6.
  constexpr const logs::ProjectAlreadyExists& project_already_exists() const& noexcept HORUS_LIFETIME_BOUND {
    return project_already_exists_;
  }

  /// If `project_already_exists` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 6.
  logs::ProjectAlreadyExists project_already_exists() && noexcept {
    if (!set_fields_[5]) {
      return {};
    }
    return std::move(project_already_exists_);
  }

  /// No documentation.
  ///
  /// Field no: 6.
  logs::ProjectAlreadyExists& mutable_project_already_exists() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kProjectAlreadyExists;
    set_fields_[5] = true;
    return project_already_exists_;
  }

  /// Returns whether `project_already_exists` (no 6) is set.
  constexpr bool has_project_already_exists() const noexcept { return set_fields_[5]; }

  /// Clears `project_already_exists` (no 6).
  void clear_project_already_exists() & noexcept {
    data_ = {};
    set_fields_[5] = false;
    project_already_exists_ = {};
  }

  /// Sets `project_already_exists` (no 6) and returns `*this`.
  LogData& set_project_already_exists(logs::ProjectAlreadyExists&& project_already_exists) & noexcept {
    clear_data();
    data_ = DataOneof::kProjectAlreadyExists;
    set_fields_[5] = true;
    project_already_exists_ = std::move(project_already_exists);
    return *this;
  }
  /// Sets `project_already_exists` (no 6) and returns `*this`.
  LogData&& set_project_already_exists(logs::ProjectAlreadyExists&& project_already_exists) && noexcept {
    return std::move(set_project_already_exists(std::move(project_already_exists)));
  }

  // Field `invalid_configuration` (no 7).
  // -----

  /// No documentation.
  ///
  /// Field no: 7.
  constexpr const logs::InvalidConfiguration& invalid_configuration() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_configuration_;
  }

  /// If `invalid_configuration` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 7.
  logs::InvalidConfiguration invalid_configuration() && noexcept {
    if (!set_fields_[6]) {
      return {};
    }
    return std::move(invalid_configuration_);
  }

  /// No documentation.
  ///
  /// Field no: 7.
  logs::InvalidConfiguration& mutable_invalid_configuration() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidConfiguration;
    set_fields_[6] = true;
    return invalid_configuration_;
  }

  /// Returns whether `invalid_configuration` (no 7) is set.
  constexpr bool has_invalid_configuration() const noexcept { return set_fields_[6]; }

  /// Clears `invalid_configuration` (no 7).
  void clear_invalid_configuration() & noexcept {
    data_ = {};
    set_fields_[6] = false;
    invalid_configuration_ = {};
  }

  /// Sets `invalid_configuration` (no 7) and returns `*this`.
  LogData& set_invalid_configuration(logs::InvalidConfiguration&& invalid_configuration) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidConfiguration;
    set_fields_[6] = true;
    invalid_configuration_ = std::move(invalid_configuration);
    return *this;
  }
  /// Sets `invalid_configuration` (no 7) and returns `*this`.
  LogData&& set_invalid_configuration(logs::InvalidConfiguration&& invalid_configuration) && noexcept {
    return std::move(set_invalid_configuration(std::move(invalid_configuration)));
  }

  // Field `entity_not_found` (no 8).
  // -----

  /// No documentation.
  ///
  /// Field no: 8.
  constexpr const logs::EntityNotFound& entity_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return entity_not_found_;
  }

  /// If `entity_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 8.
  logs::EntityNotFound entity_not_found() && noexcept {
    if (!set_fields_[7]) {
      return {};
    }
    return std::move(entity_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 8.
  logs::EntityNotFound& mutable_entity_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kEntityNotFound;
    set_fields_[7] = true;
    return entity_not_found_;
  }

  /// Returns whether `entity_not_found` (no 8) is set.
  constexpr bool has_entity_not_found() const noexcept { return set_fields_[7]; }

  /// Clears `entity_not_found` (no 8).
  void clear_entity_not_found() & noexcept {
    data_ = {};
    set_fields_[7] = false;
    entity_not_found_ = {};
  }

  /// Sets `entity_not_found` (no 8) and returns `*this`.
  LogData& set_entity_not_found(logs::EntityNotFound&& entity_not_found) & noexcept {
    clear_data();
    data_ = DataOneof::kEntityNotFound;
    set_fields_[7] = true;
    entity_not_found_ = std::move(entity_not_found);
    return *this;
  }
  /// Sets `entity_not_found` (no 8) and returns `*this`.
  LogData&& set_entity_not_found(logs::EntityNotFound&& entity_not_found) && noexcept {
    return std::move(set_entity_not_found(std::move(entity_not_found)));
  }

  // Field `active_project_cannot_be_deleted` (no 9).
  // -----

  /// No documentation.
  ///
  /// Field no: 9.
  constexpr const logs::ActiveProjectCannotBeDeleted& active_project_cannot_be_deleted() const& noexcept HORUS_LIFETIME_BOUND {
    return active_project_cannot_be_deleted_;
  }

  /// If `active_project_cannot_be_deleted` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 9.
  logs::ActiveProjectCannotBeDeleted active_project_cannot_be_deleted() && noexcept {
    if (!set_fields_[8]) {
      return {};
    }
    return std::move(active_project_cannot_be_deleted_);
  }

  /// No documentation.
  ///
  /// Field no: 9.
  logs::ActiveProjectCannotBeDeleted& mutable_active_project_cannot_be_deleted() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kActiveProjectCannotBeDeleted;
    set_fields_[8] = true;
    return active_project_cannot_be_deleted_;
  }

  /// Returns whether `active_project_cannot_be_deleted` (no 9) is set.
  constexpr bool has_active_project_cannot_be_deleted() const noexcept { return set_fields_[8]; }

  /// Clears `active_project_cannot_be_deleted` (no 9).
  void clear_active_project_cannot_be_deleted() & noexcept {
    data_ = {};
    set_fields_[8] = false;
    active_project_cannot_be_deleted_ = {};
  }

  /// Sets `active_project_cannot_be_deleted` (no 9) and returns `*this`.
  LogData& set_active_project_cannot_be_deleted(logs::ActiveProjectCannotBeDeleted&& active_project_cannot_be_deleted) & noexcept {
    clear_data();
    data_ = DataOneof::kActiveProjectCannotBeDeleted;
    set_fields_[8] = true;
    active_project_cannot_be_deleted_ = std::move(active_project_cannot_be_deleted);
    return *this;
  }
  /// Sets `active_project_cannot_be_deleted` (no 9) and returns `*this`.
  LogData&& set_active_project_cannot_be_deleted(logs::ActiveProjectCannotBeDeleted&& active_project_cannot_be_deleted) && noexcept {
    return std::move(set_active_project_cannot_be_deleted(std::move(active_project_cannot_be_deleted)));
  }

  // Field `rpc_disconnection_error` (no 10).
  // -----

  /// No documentation.
  ///
  /// Field no: 10.
  constexpr const logs::RpcDisconnectionError& rpc_disconnection_error() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_disconnection_error_;
  }

  /// If `rpc_disconnection_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 10.
  logs::RpcDisconnectionError rpc_disconnection_error() && noexcept {
    if (!set_fields_[9]) {
      return {};
    }
    return std::move(rpc_disconnection_error_);
  }

  /// No documentation.
  ///
  /// Field no: 10.
  logs::RpcDisconnectionError& mutable_rpc_disconnection_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcDisconnectionError;
    set_fields_[9] = true;
    return rpc_disconnection_error_;
  }

  /// Returns whether `rpc_disconnection_error` (no 10) is set.
  constexpr bool has_rpc_disconnection_error() const noexcept { return set_fields_[9]; }

  /// Clears `rpc_disconnection_error` (no 10).
  void clear_rpc_disconnection_error() & noexcept {
    data_ = {};
    set_fields_[9] = false;
    rpc_disconnection_error_ = {};
  }

  /// Sets `rpc_disconnection_error` (no 10) and returns `*this`.
  LogData& set_rpc_disconnection_error(logs::RpcDisconnectionError&& rpc_disconnection_error) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcDisconnectionError;
    set_fields_[9] = true;
    rpc_disconnection_error_ = std::move(rpc_disconnection_error);
    return *this;
  }
  /// Sets `rpc_disconnection_error` (no 10) and returns `*this`.
  LogData&& set_rpc_disconnection_error(logs::RpcDisconnectionError&& rpc_disconnection_error) && noexcept {
    return std::move(set_rpc_disconnection_error(std::move(rpc_disconnection_error)));
  }

  // Field `dropped_logs` (no 11).
  // -----

  /// No documentation.
  ///
  /// Field no: 11.
  constexpr const logs::DroppedLogs& dropped_logs() const& noexcept HORUS_LIFETIME_BOUND {
    return dropped_logs_;
  }

  /// If `dropped_logs` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 11.
  logs::DroppedLogs dropped_logs() && noexcept {
    if (!set_fields_[10]) {
      return {};
    }
    return std::move(dropped_logs_);
  }

  /// No documentation.
  ///
  /// Field no: 11.
  logs::DroppedLogs& mutable_dropped_logs() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kDroppedLogs;
    set_fields_[10] = true;
    return dropped_logs_;
  }

  /// Returns whether `dropped_logs` (no 11) is set.
  constexpr bool has_dropped_logs() const noexcept { return set_fields_[10]; }

  /// Clears `dropped_logs` (no 11).
  void clear_dropped_logs() & noexcept {
    data_ = {};
    set_fields_[10] = false;
    dropped_logs_ = {};
  }

  /// Sets `dropped_logs` (no 11) and returns `*this`.
  LogData& set_dropped_logs(logs::DroppedLogs&& dropped_logs) & noexcept {
    clear_data();
    data_ = DataOneof::kDroppedLogs;
    set_fields_[10] = true;
    dropped_logs_ = std::move(dropped_logs);
    return *this;
  }
  /// Sets `dropped_logs` (no 11) and returns `*this`.
  LogData&& set_dropped_logs(logs::DroppedLogs&& dropped_logs) && noexcept {
    return std::move(set_dropped_logs(std::move(dropped_logs)));
  }

  // Field `opened_project` (no 12).
  // -----

  /// No documentation.
  ///
  /// Field no: 12.
  constexpr const logs::OpenedProject& opened_project() const& noexcept HORUS_LIFETIME_BOUND {
    return opened_project_;
  }

  /// If `opened_project` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 12.
  logs::OpenedProject opened_project() && noexcept {
    if (!set_fields_[11]) {
      return {};
    }
    return std::move(opened_project_);
  }

  /// No documentation.
  ///
  /// Field no: 12.
  logs::OpenedProject& mutable_opened_project() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kOpenedProject;
    set_fields_[11] = true;
    return opened_project_;
  }

  /// Returns whether `opened_project` (no 12) is set.
  constexpr bool has_opened_project() const noexcept { return set_fields_[11]; }

  /// Clears `opened_project` (no 12).
  void clear_opened_project() & noexcept {
    data_ = {};
    set_fields_[11] = false;
    opened_project_ = {};
  }

  /// Sets `opened_project` (no 12) and returns `*this`.
  LogData& set_opened_project(logs::OpenedProject&& opened_project) & noexcept {
    clear_data();
    data_ = DataOneof::kOpenedProject;
    set_fields_[11] = true;
    opened_project_ = std::move(opened_project);
    return *this;
  }
  /// Sets `opened_project` (no 12) and returns `*this`.
  LogData&& set_opened_project(logs::OpenedProject&& opened_project) && noexcept {
    return std::move(set_opened_project(std::move(opened_project)));
  }

  // Field `created_project` (no 13).
  // -----

  /// No documentation.
  ///
  /// Field no: 13.
  constexpr const logs::CreatedProject& created_project() const& noexcept HORUS_LIFETIME_BOUND {
    return created_project_;
  }

  /// If `created_project` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 13.
  logs::CreatedProject created_project() && noexcept {
    if (!set_fields_[12]) {
      return {};
    }
    return std::move(created_project_);
  }

  /// No documentation.
  ///
  /// Field no: 13.
  logs::CreatedProject& mutable_created_project() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCreatedProject;
    set_fields_[12] = true;
    return created_project_;
  }

  /// Returns whether `created_project` (no 13) is set.
  constexpr bool has_created_project() const noexcept { return set_fields_[12]; }

  /// Clears `created_project` (no 13).
  void clear_created_project() & noexcept {
    data_ = {};
    set_fields_[12] = false;
    created_project_ = {};
  }

  /// Sets `created_project` (no 13) and returns `*this`.
  LogData& set_created_project(logs::CreatedProject&& created_project) & noexcept {
    clear_data();
    data_ = DataOneof::kCreatedProject;
    set_fields_[12] = true;
    created_project_ = std::move(created_project);
    return *this;
  }
  /// Sets `created_project` (no 13) and returns `*this`.
  LogData&& set_created_project(logs::CreatedProject&& created_project) && noexcept {
    return std::move(set_created_project(std::move(created_project)));
  }

  // Field `config_unavailable` (no 14).
  // -----

  /// No documentation.
  ///
  /// Field no: 14.
  constexpr const logs::ConfigUnavailable& config_unavailable() const& noexcept HORUS_LIFETIME_BOUND {
    return config_unavailable_;
  }

  /// If `config_unavailable` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 14.
  logs::ConfigUnavailable config_unavailable() && noexcept {
    if (!set_fields_[13]) {
      return {};
    }
    return std::move(config_unavailable_);
  }

  /// No documentation.
  ///
  /// Field no: 14.
  logs::ConfigUnavailable& mutable_config_unavailable() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kConfigUnavailable;
    set_fields_[13] = true;
    return config_unavailable_;
  }

  /// Returns whether `config_unavailable` (no 14) is set.
  constexpr bool has_config_unavailable() const noexcept { return set_fields_[13]; }

  /// Clears `config_unavailable` (no 14).
  void clear_config_unavailable() & noexcept {
    data_ = {};
    set_fields_[13] = false;
    config_unavailable_ = {};
  }

  /// Sets `config_unavailable` (no 14) and returns `*this`.
  LogData& set_config_unavailable(logs::ConfigUnavailable&& config_unavailable) & noexcept {
    clear_data();
    data_ = DataOneof::kConfigUnavailable;
    set_fields_[13] = true;
    config_unavailable_ = std::move(config_unavailable);
    return *this;
  }
  /// Sets `config_unavailable` (no 14) and returns `*this`.
  LogData&& set_config_unavailable(logs::ConfigUnavailable&& config_unavailable) && noexcept {
    return std::move(set_config_unavailable(std::move(config_unavailable)));
  }

  // Field `invalid_request` (no 15).
  // -----

  /// No documentation.
  ///
  /// Field no: 15.
  constexpr const logs::InvalidRequest& invalid_request() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_request_;
  }

  /// If `invalid_request` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 15.
  logs::InvalidRequest invalid_request() && noexcept {
    if (!set_fields_[14]) {
      return {};
    }
    return std::move(invalid_request_);
  }

  /// No documentation.
  ///
  /// Field no: 15.
  logs::InvalidRequest& mutable_invalid_request() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidRequest;
    set_fields_[14] = true;
    return invalid_request_;
  }

  /// Returns whether `invalid_request` (no 15) is set.
  constexpr bool has_invalid_request() const noexcept { return set_fields_[14]; }

  /// Clears `invalid_request` (no 15).
  void clear_invalid_request() & noexcept {
    data_ = {};
    set_fields_[14] = false;
    invalid_request_ = {};
  }

  /// Sets `invalid_request` (no 15) and returns `*this`.
  LogData& set_invalid_request(logs::InvalidRequest&& invalid_request) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidRequest;
    set_fields_[14] = true;
    invalid_request_ = std::move(invalid_request);
    return *this;
  }
  /// Sets `invalid_request` (no 15) and returns `*this`.
  LogData&& set_invalid_request(logs::InvalidRequest&& invalid_request) && noexcept {
    return std::move(set_invalid_request(std::move(invalid_request)));
  }

  // Field `sanity_check_error` (no 16).
  // -----

  /// No documentation.
  ///
  /// Field no: 16.
  constexpr const logs::SanityCheckError& sanity_check_error() const& noexcept HORUS_LIFETIME_BOUND {
    return sanity_check_error_;
  }

  /// If `sanity_check_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 16.
  logs::SanityCheckError sanity_check_error() && noexcept {
    if (!set_fields_[15]) {
      return {};
    }
    return std::move(sanity_check_error_);
  }

  /// No documentation.
  ///
  /// Field no: 16.
  logs::SanityCheckError& mutable_sanity_check_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kSanityCheckError;
    set_fields_[15] = true;
    return sanity_check_error_;
  }

  /// Returns whether `sanity_check_error` (no 16) is set.
  constexpr bool has_sanity_check_error() const noexcept { return set_fields_[15]; }

  /// Clears `sanity_check_error` (no 16).
  void clear_sanity_check_error() & noexcept {
    data_ = {};
    set_fields_[15] = false;
    sanity_check_error_ = {};
  }

  /// Sets `sanity_check_error` (no 16) and returns `*this`.
  LogData& set_sanity_check_error(logs::SanityCheckError&& sanity_check_error) & noexcept {
    clear_data();
    data_ = DataOneof::kSanityCheckError;
    set_fields_[15] = true;
    sanity_check_error_ = std::move(sanity_check_error);
    return *this;
  }
  /// Sets `sanity_check_error` (no 16) and returns `*this`.
  LogData&& set_sanity_check_error(logs::SanityCheckError&& sanity_check_error) && noexcept {
    return std::move(set_sanity_check_error(std::move(sanity_check_error)));
  }

  // Field `bag_failed_to_open` (no 17).
  // -----

  /// No documentation.
  ///
  /// Field no: 17.
  constexpr const logs::BagFailedToOpen& bag_failed_to_open() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_failed_to_open_;
  }

  /// If `bag_failed_to_open` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 17.
  logs::BagFailedToOpen bag_failed_to_open() && noexcept {
    if (!set_fields_[16]) {
      return {};
    }
    return std::move(bag_failed_to_open_);
  }

  /// No documentation.
  ///
  /// Field no: 17.
  logs::BagFailedToOpen& mutable_bag_failed_to_open() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagFailedToOpen;
    set_fields_[16] = true;
    return bag_failed_to_open_;
  }

  /// Returns whether `bag_failed_to_open` (no 17) is set.
  constexpr bool has_bag_failed_to_open() const noexcept { return set_fields_[16]; }

  /// Clears `bag_failed_to_open` (no 17).
  void clear_bag_failed_to_open() & noexcept {
    data_ = {};
    set_fields_[16] = false;
    bag_failed_to_open_ = {};
  }

  /// Sets `bag_failed_to_open` (no 17) and returns `*this`.
  LogData& set_bag_failed_to_open(logs::BagFailedToOpen&& bag_failed_to_open) & noexcept {
    clear_data();
    data_ = DataOneof::kBagFailedToOpen;
    set_fields_[16] = true;
    bag_failed_to_open_ = std::move(bag_failed_to_open);
    return *this;
  }
  /// Sets `bag_failed_to_open` (no 17) and returns `*this`.
  LogData&& set_bag_failed_to_open(logs::BagFailedToOpen&& bag_failed_to_open) && noexcept {
    return std::move(set_bag_failed_to_open(std::move(bag_failed_to_open)));
  }

  // Field `bag_failed_to_close` (no 18).
  // -----

  /// No documentation.
  ///
  /// Field no: 18.
  constexpr const logs::BagFailedToClose& bag_failed_to_close() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_failed_to_close_;
  }

  /// If `bag_failed_to_close` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 18.
  logs::BagFailedToClose bag_failed_to_close() && noexcept {
    if (!set_fields_[17]) {
      return {};
    }
    return std::move(bag_failed_to_close_);
  }

  /// No documentation.
  ///
  /// Field no: 18.
  logs::BagFailedToClose& mutable_bag_failed_to_close() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagFailedToClose;
    set_fields_[17] = true;
    return bag_failed_to_close_;
  }

  /// Returns whether `bag_failed_to_close` (no 18) is set.
  constexpr bool has_bag_failed_to_close() const noexcept { return set_fields_[17]; }

  /// Clears `bag_failed_to_close` (no 18).
  void clear_bag_failed_to_close() & noexcept {
    data_ = {};
    set_fields_[17] = false;
    bag_failed_to_close_ = {};
  }

  /// Sets `bag_failed_to_close` (no 18) and returns `*this`.
  LogData& set_bag_failed_to_close(logs::BagFailedToClose&& bag_failed_to_close) & noexcept {
    clear_data();
    data_ = DataOneof::kBagFailedToClose;
    set_fields_[17] = true;
    bag_failed_to_close_ = std::move(bag_failed_to_close);
    return *this;
  }
  /// Sets `bag_failed_to_close` (no 18) and returns `*this`.
  LogData&& set_bag_failed_to_close(logs::BagFailedToClose&& bag_failed_to_close) && noexcept {
    return std::move(set_bag_failed_to_close(std::move(bag_failed_to_close)));
  }

  // Field `bag_conversion_failed` (no 19).
  // -----

  /// No documentation.
  ///
  /// Field no: 19.
  constexpr const logs::BagConversionFailed& bag_conversion_failed() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_conversion_failed_;
  }

  /// If `bag_conversion_failed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 19.
  logs::BagConversionFailed bag_conversion_failed() && noexcept {
    if (!set_fields_[18]) {
      return {};
    }
    return std::move(bag_conversion_failed_);
  }

  /// No documentation.
  ///
  /// Field no: 19.
  logs::BagConversionFailed& mutable_bag_conversion_failed() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagConversionFailed;
    set_fields_[18] = true;
    return bag_conversion_failed_;
  }

  /// Returns whether `bag_conversion_failed` (no 19) is set.
  constexpr bool has_bag_conversion_failed() const noexcept { return set_fields_[18]; }

  /// Clears `bag_conversion_failed` (no 19).
  void clear_bag_conversion_failed() & noexcept {
    data_ = {};
    set_fields_[18] = false;
    bag_conversion_failed_ = {};
  }

  /// Sets `bag_conversion_failed` (no 19) and returns `*this`.
  LogData& set_bag_conversion_failed(logs::BagConversionFailed&& bag_conversion_failed) & noexcept {
    clear_data();
    data_ = DataOneof::kBagConversionFailed;
    set_fields_[18] = true;
    bag_conversion_failed_ = std::move(bag_conversion_failed);
    return *this;
  }
  /// Sets `bag_conversion_failed` (no 19) and returns `*this`.
  LogData&& set_bag_conversion_failed(logs::BagConversionFailed&& bag_conversion_failed) && noexcept {
    return std::move(set_bag_conversion_failed(std::move(bag_conversion_failed)));
  }

  // Field `bag_failed_to_write` (no 20).
  // -----

  /// No documentation.
  ///
  /// Field no: 20.
  constexpr const logs::BagFailedToWrite& bag_failed_to_write() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_failed_to_write_;
  }

  /// If `bag_failed_to_write` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 20.
  logs::BagFailedToWrite bag_failed_to_write() && noexcept {
    if (!set_fields_[19]) {
      return {};
    }
    return std::move(bag_failed_to_write_);
  }

  /// No documentation.
  ///
  /// Field no: 20.
  logs::BagFailedToWrite& mutable_bag_failed_to_write() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagFailedToWrite;
    set_fields_[19] = true;
    return bag_failed_to_write_;
  }

  /// Returns whether `bag_failed_to_write` (no 20) is set.
  constexpr bool has_bag_failed_to_write() const noexcept { return set_fields_[19]; }

  /// Clears `bag_failed_to_write` (no 20).
  void clear_bag_failed_to_write() & noexcept {
    data_ = {};
    set_fields_[19] = false;
    bag_failed_to_write_ = {};
  }

  /// Sets `bag_failed_to_write` (no 20) and returns `*this`.
  LogData& set_bag_failed_to_write(logs::BagFailedToWrite&& bag_failed_to_write) & noexcept {
    clear_data();
    data_ = DataOneof::kBagFailedToWrite;
    set_fields_[19] = true;
    bag_failed_to_write_ = std::move(bag_failed_to_write);
    return *this;
  }
  /// Sets `bag_failed_to_write` (no 20) and returns `*this`.
  LogData&& set_bag_failed_to_write(logs::BagFailedToWrite&& bag_failed_to_write) && noexcept {
    return std::move(set_bag_failed_to_write(std::move(bag_failed_to_write)));
  }

  // Field `calibration_error` (no 21).
  // -----

  /// No documentation.
  ///
  /// Field no: 21.
  constexpr const logs::CalibrationError& calibration_error() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_error_;
  }

  /// If `calibration_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 21.
  logs::CalibrationError calibration_error() && noexcept {
    if (!set_fields_[20]) {
      return {};
    }
    return std::move(calibration_error_);
  }

  /// No documentation.
  ///
  /// Field no: 21.
  logs::CalibrationError& mutable_calibration_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationError;
    set_fields_[20] = true;
    return calibration_error_;
  }

  /// Returns whether `calibration_error` (no 21) is set.
  constexpr bool has_calibration_error() const noexcept { return set_fields_[20]; }

  /// Clears `calibration_error` (no 21).
  void clear_calibration_error() & noexcept {
    data_ = {};
    set_fields_[20] = false;
    calibration_error_ = {};
  }

  /// Sets `calibration_error` (no 21) and returns `*this`.
  LogData& set_calibration_error(logs::CalibrationError&& calibration_error) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationError;
    set_fields_[20] = true;
    calibration_error_ = std::move(calibration_error);
    return *this;
  }
  /// Sets `calibration_error` (no 21) and returns `*this`.
  LogData&& set_calibration_error(logs::CalibrationError&& calibration_error) && noexcept {
    return std::move(set_calibration_error(std::move(calibration_error)));
  }

  // Field `project_manager_failed_to_start_recording` (no 22).
  // -----

  /// No documentation.
  ///
  /// Field no: 22.
  constexpr const logs::ProjectManagerFailedToStartRecording& project_manager_failed_to_start_recording() const& noexcept HORUS_LIFETIME_BOUND {
    return project_manager_failed_to_start_recording_;
  }

  /// If `project_manager_failed_to_start_recording` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 22.
  logs::ProjectManagerFailedToStartRecording project_manager_failed_to_start_recording() && noexcept {
    if (!set_fields_[21]) {
      return {};
    }
    return std::move(project_manager_failed_to_start_recording_);
  }

  /// No documentation.
  ///
  /// Field no: 22.
  logs::ProjectManagerFailedToStartRecording& mutable_project_manager_failed_to_start_recording() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kProjectManagerFailedToStartRecording;
    set_fields_[21] = true;
    return project_manager_failed_to_start_recording_;
  }

  /// Returns whether `project_manager_failed_to_start_recording` (no 22) is set.
  constexpr bool has_project_manager_failed_to_start_recording() const noexcept { return set_fields_[21]; }

  /// Clears `project_manager_failed_to_start_recording` (no 22).
  void clear_project_manager_failed_to_start_recording() & noexcept {
    data_ = {};
    set_fields_[21] = false;
    project_manager_failed_to_start_recording_ = {};
  }

  /// Sets `project_manager_failed_to_start_recording` (no 22) and returns `*this`.
  LogData& set_project_manager_failed_to_start_recording(logs::ProjectManagerFailedToStartRecording&& project_manager_failed_to_start_recording) & noexcept {
    clear_data();
    data_ = DataOneof::kProjectManagerFailedToStartRecording;
    set_fields_[21] = true;
    project_manager_failed_to_start_recording_ = std::move(project_manager_failed_to_start_recording);
    return *this;
  }
  /// Sets `project_manager_failed_to_start_recording` (no 22) and returns `*this`.
  LogData&& set_project_manager_failed_to_start_recording(logs::ProjectManagerFailedToStartRecording&& project_manager_failed_to_start_recording) && noexcept {
    return std::move(set_project_manager_failed_to_start_recording(std::move(project_manager_failed_to_start_recording)));
  }

  // Field `project_manager_failed_to_stop_recording` (no 23).
  // -----

  /// No documentation.
  ///
  /// Field no: 23.
  constexpr const logs::ProjectManagerFailedToStopRecording& project_manager_failed_to_stop_recording() const& noexcept HORUS_LIFETIME_BOUND {
    return project_manager_failed_to_stop_recording_;
  }

  /// If `project_manager_failed_to_stop_recording` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 23.
  logs::ProjectManagerFailedToStopRecording project_manager_failed_to_stop_recording() && noexcept {
    if (!set_fields_[22]) {
      return {};
    }
    return std::move(project_manager_failed_to_stop_recording_);
  }

  /// No documentation.
  ///
  /// Field no: 23.
  logs::ProjectManagerFailedToStopRecording& mutable_project_manager_failed_to_stop_recording() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kProjectManagerFailedToStopRecording;
    set_fields_[22] = true;
    return project_manager_failed_to_stop_recording_;
  }

  /// Returns whether `project_manager_failed_to_stop_recording` (no 23) is set.
  constexpr bool has_project_manager_failed_to_stop_recording() const noexcept { return set_fields_[22]; }

  /// Clears `project_manager_failed_to_stop_recording` (no 23).
  void clear_project_manager_failed_to_stop_recording() & noexcept {
    data_ = {};
    set_fields_[22] = false;
    project_manager_failed_to_stop_recording_ = {};
  }

  /// Sets `project_manager_failed_to_stop_recording` (no 23) and returns `*this`.
  LogData& set_project_manager_failed_to_stop_recording(logs::ProjectManagerFailedToStopRecording&& project_manager_failed_to_stop_recording) & noexcept {
    clear_data();
    data_ = DataOneof::kProjectManagerFailedToStopRecording;
    set_fields_[22] = true;
    project_manager_failed_to_stop_recording_ = std::move(project_manager_failed_to_stop_recording);
    return *this;
  }
  /// Sets `project_manager_failed_to_stop_recording` (no 23) and returns `*this`.
  LogData&& set_project_manager_failed_to_stop_recording(logs::ProjectManagerFailedToStopRecording&& project_manager_failed_to_stop_recording) && noexcept {
    return std::move(set_project_manager_failed_to_stop_recording(std::move(project_manager_failed_to_stop_recording)));
  }

  // Field `service_connection_timed_out` (no 24).
  // -----

  /// No documentation.
  ///
  /// Field no: 24.
  constexpr const logs::ServiceConnectionTimedOut& service_connection_timed_out() const& noexcept HORUS_LIFETIME_BOUND {
    return service_connection_timed_out_;
  }

  /// If `service_connection_timed_out` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 24.
  logs::ServiceConnectionTimedOut service_connection_timed_out() && noexcept {
    if (!set_fields_[23]) {
      return {};
    }
    return std::move(service_connection_timed_out_);
  }

  /// No documentation.
  ///
  /// Field no: 24.
  logs::ServiceConnectionTimedOut& mutable_service_connection_timed_out() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kServiceConnectionTimedOut;
    set_fields_[23] = true;
    return service_connection_timed_out_;
  }

  /// Returns whether `service_connection_timed_out` (no 24) is set.
  constexpr bool has_service_connection_timed_out() const noexcept { return set_fields_[23]; }

  /// Clears `service_connection_timed_out` (no 24).
  void clear_service_connection_timed_out() & noexcept {
    data_ = {};
    set_fields_[23] = false;
    service_connection_timed_out_ = {};
  }

  /// Sets `service_connection_timed_out` (no 24) and returns `*this`.
  LogData& set_service_connection_timed_out(logs::ServiceConnectionTimedOut&& service_connection_timed_out) & noexcept {
    clear_data();
    data_ = DataOneof::kServiceConnectionTimedOut;
    set_fields_[23] = true;
    service_connection_timed_out_ = std::move(service_connection_timed_out);
    return *this;
  }
  /// Sets `service_connection_timed_out` (no 24) and returns `*this`.
  LogData&& set_service_connection_timed_out(logs::ServiceConnectionTimedOut&& service_connection_timed_out) && noexcept {
    return std::move(set_service_connection_timed_out(std::move(service_connection_timed_out)));
  }

  // Field `bag_recorder_already_running` (no 25).
  // -----

  /// No documentation.
  ///
  /// Field no: 25.
  constexpr const logs::BagRecorderAlreadyRunning& bag_recorder_already_running() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_recorder_already_running_;
  }

  /// If `bag_recorder_already_running` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 25.
  logs::BagRecorderAlreadyRunning bag_recorder_already_running() && noexcept {
    if (!set_fields_[24]) {
      return {};
    }
    return std::move(bag_recorder_already_running_);
  }

  /// No documentation.
  ///
  /// Field no: 25.
  logs::BagRecorderAlreadyRunning& mutable_bag_recorder_already_running() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagRecorderAlreadyRunning;
    set_fields_[24] = true;
    return bag_recorder_already_running_;
  }

  /// Returns whether `bag_recorder_already_running` (no 25) is set.
  constexpr bool has_bag_recorder_already_running() const noexcept { return set_fields_[24]; }

  /// Clears `bag_recorder_already_running` (no 25).
  void clear_bag_recorder_already_running() & noexcept {
    data_ = {};
    set_fields_[24] = false;
    bag_recorder_already_running_ = {};
  }

  /// Sets `bag_recorder_already_running` (no 25) and returns `*this`.
  LogData& set_bag_recorder_already_running(logs::BagRecorderAlreadyRunning&& bag_recorder_already_running) & noexcept {
    clear_data();
    data_ = DataOneof::kBagRecorderAlreadyRunning;
    set_fields_[24] = true;
    bag_recorder_already_running_ = std::move(bag_recorder_already_running);
    return *this;
  }
  /// Sets `bag_recorder_already_running` (no 25) and returns `*this`.
  LogData&& set_bag_recorder_already_running(logs::BagRecorderAlreadyRunning&& bag_recorder_already_running) && noexcept {
    return std::move(set_bag_recorder_already_running(std::move(bag_recorder_already_running)));
  }

  // Field `license_server_connection_error` (no 26).
  // -----

  /// No documentation.
  ///
  /// Field no: 26.
  constexpr const logs::LicenseServerConnectionError& license_server_connection_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_server_connection_error_;
  }

  /// If `license_server_connection_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 26.
  logs::LicenseServerConnectionError license_server_connection_error() && noexcept {
    if (!set_fields_[25]) {
      return {};
    }
    return std::move(license_server_connection_error_);
  }

  /// No documentation.
  ///
  /// Field no: 26.
  logs::LicenseServerConnectionError& mutable_license_server_connection_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseServerConnectionError;
    set_fields_[25] = true;
    return license_server_connection_error_;
  }

  /// Returns whether `license_server_connection_error` (no 26) is set.
  constexpr bool has_license_server_connection_error() const noexcept { return set_fields_[25]; }

  /// Clears `license_server_connection_error` (no 26).
  void clear_license_server_connection_error() & noexcept {
    data_ = {};
    set_fields_[25] = false;
    license_server_connection_error_ = {};
  }

  /// Sets `license_server_connection_error` (no 26) and returns `*this`.
  LogData& set_license_server_connection_error(logs::LicenseServerConnectionError&& license_server_connection_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseServerConnectionError;
    set_fields_[25] = true;
    license_server_connection_error_ = std::move(license_server_connection_error);
    return *this;
  }
  /// Sets `license_server_connection_error` (no 26) and returns `*this`.
  LogData&& set_license_server_connection_error(logs::LicenseServerConnectionError&& license_server_connection_error) && noexcept {
    return std::move(set_license_server_connection_error(std::move(license_server_connection_error)));
  }

  // Field `license_error` (no 27).
  // -----

  /// No documentation.
  ///
  /// Field no: 27.
  constexpr const logs::LicenseError& license_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_error_;
  }

  /// If `license_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 27.
  logs::LicenseError license_error() && noexcept {
    if (!set_fields_[26]) {
      return {};
    }
    return std::move(license_error_);
  }

  /// No documentation.
  ///
  /// Field no: 27.
  logs::LicenseError& mutable_license_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseError;
    set_fields_[26] = true;
    return license_error_;
  }

  /// Returns whether `license_error` (no 27) is set.
  constexpr bool has_license_error() const noexcept { return set_fields_[26]; }

  /// Clears `license_error` (no 27).
  void clear_license_error() & noexcept {
    data_ = {};
    set_fields_[26] = false;
    license_error_ = {};
  }

  /// Sets `license_error` (no 27) and returns `*this`.
  LogData& set_license_error(logs::LicenseError&& license_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseError;
    set_fields_[26] = true;
    license_error_ = std::move(license_error);
    return *this;
  }
  /// Sets `license_error` (no 27) and returns `*this`.
  LogData&& set_license_error(logs::LicenseError&& license_error) && noexcept {
    return std::move(set_license_error(std::move(license_error)));
  }

  // Field `license_not_found_error` (no 145).
  // -----

  /// No documentation.
  ///
  /// Field no: 145.
  constexpr const logs::LicenseNotFoundError& license_not_found_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_not_found_error_;
  }

  /// If `license_not_found_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 145.
  logs::LicenseNotFoundError license_not_found_error() && noexcept {
    if (!set_fields_[27]) {
      return {};
    }
    return std::move(license_not_found_error_);
  }

  /// No documentation.
  ///
  /// Field no: 145.
  logs::LicenseNotFoundError& mutable_license_not_found_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseNotFoundError;
    set_fields_[27] = true;
    return license_not_found_error_;
  }

  /// Returns whether `license_not_found_error` (no 145) is set.
  constexpr bool has_license_not_found_error() const noexcept { return set_fields_[27]; }

  /// Clears `license_not_found_error` (no 145).
  void clear_license_not_found_error() & noexcept {
    data_ = {};
    set_fields_[27] = false;
    license_not_found_error_ = {};
  }

  /// Sets `license_not_found_error` (no 145) and returns `*this`.
  LogData& set_license_not_found_error(logs::LicenseNotFoundError&& license_not_found_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseNotFoundError;
    set_fields_[27] = true;
    license_not_found_error_ = std::move(license_not_found_error);
    return *this;
  }
  /// Sets `license_not_found_error` (no 145) and returns `*this`.
  LogData&& set_license_not_found_error(logs::LicenseNotFoundError&& license_not_found_error) && noexcept {
    return std::move(set_license_not_found_error(std::move(license_not_found_error)));
  }

  // Field `license_expired_error` (no 146).
  // -----

  /// No documentation.
  ///
  /// Field no: 146.
  constexpr const logs::LicenseExpiredError& license_expired_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_expired_error_;
  }

  /// If `license_expired_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 146.
  logs::LicenseExpiredError license_expired_error() && noexcept {
    if (!set_fields_[28]) {
      return {};
    }
    return std::move(license_expired_error_);
  }

  /// No documentation.
  ///
  /// Field no: 146.
  logs::LicenseExpiredError& mutable_license_expired_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseExpiredError;
    set_fields_[28] = true;
    return license_expired_error_;
  }

  /// Returns whether `license_expired_error` (no 146) is set.
  constexpr bool has_license_expired_error() const noexcept { return set_fields_[28]; }

  /// Clears `license_expired_error` (no 146).
  void clear_license_expired_error() & noexcept {
    data_ = {};
    set_fields_[28] = false;
    license_expired_error_ = {};
  }

  /// Sets `license_expired_error` (no 146) and returns `*this`.
  LogData& set_license_expired_error(logs::LicenseExpiredError&& license_expired_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseExpiredError;
    set_fields_[28] = true;
    license_expired_error_ = std::move(license_expired_error);
    return *this;
  }
  /// Sets `license_expired_error` (no 146) and returns `*this`.
  LogData&& set_license_expired_error(logs::LicenseExpiredError&& license_expired_error) && noexcept {
    return std::move(set_license_expired_error(std::move(license_expired_error)));
  }

  // Field `license_exceeded_error` (no 147).
  // -----

  /// No documentation.
  ///
  /// Field no: 147.
  constexpr const logs::LicenseExceededError& license_exceeded_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_exceeded_error_;
  }

  /// If `license_exceeded_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 147.
  logs::LicenseExceededError license_exceeded_error() && noexcept {
    if (!set_fields_[29]) {
      return {};
    }
    return std::move(license_exceeded_error_);
  }

  /// No documentation.
  ///
  /// Field no: 147.
  logs::LicenseExceededError& mutable_license_exceeded_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseExceededError;
    set_fields_[29] = true;
    return license_exceeded_error_;
  }

  /// Returns whether `license_exceeded_error` (no 147) is set.
  constexpr bool has_license_exceeded_error() const noexcept { return set_fields_[29]; }

  /// Clears `license_exceeded_error` (no 147).
  void clear_license_exceeded_error() & noexcept {
    data_ = {};
    set_fields_[29] = false;
    license_exceeded_error_ = {};
  }

  /// Sets `license_exceeded_error` (no 147) and returns `*this`.
  LogData& set_license_exceeded_error(logs::LicenseExceededError&& license_exceeded_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseExceededError;
    set_fields_[29] = true;
    license_exceeded_error_ = std::move(license_exceeded_error);
    return *this;
  }
  /// Sets `license_exceeded_error` (no 147) and returns `*this`.
  LogData&& set_license_exceeded_error(logs::LicenseExceededError&& license_exceeded_error) && noexcept {
    return std::move(set_license_exceeded_error(std::move(license_exceeded_error)));
  }

  // Field `license_host_machine_error` (no 28).
  // -----

  /// No documentation.
  ///
  /// Field no: 28.
  constexpr const logs::LicenseHostMachineError& license_host_machine_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_host_machine_error_;
  }

  /// If `license_host_machine_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 28.
  logs::LicenseHostMachineError license_host_machine_error() && noexcept {
    if (!set_fields_[30]) {
      return {};
    }
    return std::move(license_host_machine_error_);
  }

  /// No documentation.
  ///
  /// Field no: 28.
  logs::LicenseHostMachineError& mutable_license_host_machine_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseHostMachineError;
    set_fields_[30] = true;
    return license_host_machine_error_;
  }

  /// Returns whether `license_host_machine_error` (no 28) is set.
  constexpr bool has_license_host_machine_error() const noexcept { return set_fields_[30]; }

  /// Clears `license_host_machine_error` (no 28).
  void clear_license_host_machine_error() & noexcept {
    data_ = {};
    set_fields_[30] = false;
    license_host_machine_error_ = {};
  }

  /// Sets `license_host_machine_error` (no 28) and returns `*this`.
  LogData& set_license_host_machine_error(logs::LicenseHostMachineError&& license_host_machine_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseHostMachineError;
    set_fields_[30] = true;
    license_host_machine_error_ = std::move(license_host_machine_error);
    return *this;
  }
  /// Sets `license_host_machine_error` (no 28) and returns `*this`.
  LogData&& set_license_host_machine_error(logs::LicenseHostMachineError&& license_host_machine_error) && noexcept {
    return std::move(set_license_host_machine_error(std::move(license_host_machine_error)));
  }

  // Field `license_privilege_error` (no 148).
  // -----

  /// No documentation.
  ///
  /// Field no: 148.
  constexpr const logs::LicensePrivilegeError& license_privilege_error() const& noexcept HORUS_LIFETIME_BOUND {
    return license_privilege_error_;
  }

  /// If `license_privilege_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 148.
  logs::LicensePrivilegeError license_privilege_error() && noexcept {
    if (!set_fields_[31]) {
      return {};
    }
    return std::move(license_privilege_error_);
  }

  /// No documentation.
  ///
  /// Field no: 148.
  logs::LicensePrivilegeError& mutable_license_privilege_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicensePrivilegeError;
    set_fields_[31] = true;
    return license_privilege_error_;
  }

  /// Returns whether `license_privilege_error` (no 148) is set.
  constexpr bool has_license_privilege_error() const noexcept { return set_fields_[31]; }

  /// Clears `license_privilege_error` (no 148).
  void clear_license_privilege_error() & noexcept {
    data_ = {};
    set_fields_[31] = false;
    license_privilege_error_ = {};
  }

  /// Sets `license_privilege_error` (no 148) and returns `*this`.
  LogData& set_license_privilege_error(logs::LicensePrivilegeError&& license_privilege_error) & noexcept {
    clear_data();
    data_ = DataOneof::kLicensePrivilegeError;
    set_fields_[31] = true;
    license_privilege_error_ = std::move(license_privilege_error);
    return *this;
  }
  /// Sets `license_privilege_error` (no 148) and returns `*this`.
  LogData&& set_license_privilege_error(logs::LicensePrivilegeError&& license_privilege_error) && noexcept {
    return std::move(set_license_privilege_error(std::move(license_privilege_error)));
  }

  // Field `license_active_info` (no 149).
  // -----

  /// No documentation.
  ///
  /// Field no: 149.
  constexpr const logs::LicenseActiveInfo& license_active_info() const& noexcept HORUS_LIFETIME_BOUND {
    return license_active_info_;
  }

  /// If `license_active_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 149.
  logs::LicenseActiveInfo license_active_info() && noexcept {
    if (!set_fields_[32]) {
      return {};
    }
    return std::move(license_active_info_);
  }

  /// No documentation.
  ///
  /// Field no: 149.
  logs::LicenseActiveInfo& mutable_license_active_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseActiveInfo;
    set_fields_[32] = true;
    return license_active_info_;
  }

  /// Returns whether `license_active_info` (no 149) is set.
  constexpr bool has_license_active_info() const noexcept { return set_fields_[32]; }

  /// Clears `license_active_info` (no 149).
  void clear_license_active_info() & noexcept {
    data_ = {};
    set_fields_[32] = false;
    license_active_info_ = {};
  }

  /// Sets `license_active_info` (no 149) and returns `*this`.
  LogData& set_license_active_info(logs::LicenseActiveInfo&& license_active_info) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseActiveInfo;
    set_fields_[32] = true;
    license_active_info_ = std::move(license_active_info);
    return *this;
  }
  /// Sets `license_active_info` (no 149) and returns `*this`.
  LogData&& set_license_active_info(logs::LicenseActiveInfo&& license_active_info) && noexcept {
    return std::move(set_license_active_info(std::move(license_active_info)));
  }

  // Field `multiple_licenses_warning` (no 150).
  // -----

  /// No documentation.
  ///
  /// Field no: 150.
  constexpr const logs::MultipleLicensesWarning& multiple_licenses_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return multiple_licenses_warning_;
  }

  /// If `multiple_licenses_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 150.
  logs::MultipleLicensesWarning multiple_licenses_warning() && noexcept {
    if (!set_fields_[33]) {
      return {};
    }
    return std::move(multiple_licenses_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 150.
  logs::MultipleLicensesWarning& mutable_multiple_licenses_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kMultipleLicensesWarning;
    set_fields_[33] = true;
    return multiple_licenses_warning_;
  }

  /// Returns whether `multiple_licenses_warning` (no 150) is set.
  constexpr bool has_multiple_licenses_warning() const noexcept { return set_fields_[33]; }

  /// Clears `multiple_licenses_warning` (no 150).
  void clear_multiple_licenses_warning() & noexcept {
    data_ = {};
    set_fields_[33] = false;
    multiple_licenses_warning_ = {};
  }

  /// Sets `multiple_licenses_warning` (no 150) and returns `*this`.
  LogData& set_multiple_licenses_warning(logs::MultipleLicensesWarning&& multiple_licenses_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kMultipleLicensesWarning;
    set_fields_[33] = true;
    multiple_licenses_warning_ = std::move(multiple_licenses_warning);
    return *this;
  }
  /// Sets `multiple_licenses_warning` (no 150) and returns `*this`.
  LogData&& set_multiple_licenses_warning(logs::MultipleLicensesWarning&& multiple_licenses_warning) && noexcept {
    return std::move(set_multiple_licenses_warning(std::move(multiple_licenses_warning)));
  }

  // Field `license_current_license_status_info` (no 29).
  // -----

  /// No documentation.
  ///
  /// Field no: 29.
  constexpr const logs::LicenseCurrentLicenseStatusInfo& license_current_license_status_info() const& noexcept HORUS_LIFETIME_BOUND {
    return license_current_license_status_info_;
  }

  /// If `license_current_license_status_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 29.
  logs::LicenseCurrentLicenseStatusInfo license_current_license_status_info() && noexcept {
    if (!set_fields_[34]) {
      return {};
    }
    return std::move(license_current_license_status_info_);
  }

  /// No documentation.
  ///
  /// Field no: 29.
  logs::LicenseCurrentLicenseStatusInfo& mutable_license_current_license_status_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseCurrentLicenseStatusInfo;
    set_fields_[34] = true;
    return license_current_license_status_info_;
  }

  /// Returns whether `license_current_license_status_info` (no 29) is set.
  constexpr bool has_license_current_license_status_info() const noexcept { return set_fields_[34]; }

  /// Clears `license_current_license_status_info` (no 29).
  void clear_license_current_license_status_info() & noexcept {
    data_ = {};
    set_fields_[34] = false;
    license_current_license_status_info_ = {};
  }

  /// Sets `license_current_license_status_info` (no 29) and returns `*this`.
  LogData& set_license_current_license_status_info(logs::LicenseCurrentLicenseStatusInfo&& license_current_license_status_info) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseCurrentLicenseStatusInfo;
    set_fields_[34] = true;
    license_current_license_status_info_ = std::move(license_current_license_status_info);
    return *this;
  }
  /// Sets `license_current_license_status_info` (no 29) and returns `*this`.
  LogData&& set_license_current_license_status_info(logs::LicenseCurrentLicenseStatusInfo&& license_current_license_status_info) && noexcept {
    return std::move(set_license_current_license_status_info(std::move(license_current_license_status_info)));
  }

  // Field `bag_recording_stopped_info` (no 30).
  // -----

  /// No documentation.
  ///
  /// Field no: 30.
  constexpr const logs::BagRecordingStoppedInfo& bag_recording_stopped_info() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_recording_stopped_info_;
  }

  /// If `bag_recording_stopped_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 30.
  logs::BagRecordingStoppedInfo bag_recording_stopped_info() && noexcept {
    if (!set_fields_[35]) {
      return {};
    }
    return std::move(bag_recording_stopped_info_);
  }

  /// No documentation.
  ///
  /// Field no: 30.
  logs::BagRecordingStoppedInfo& mutable_bag_recording_stopped_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagRecordingStoppedInfo;
    set_fields_[35] = true;
    return bag_recording_stopped_info_;
  }

  /// Returns whether `bag_recording_stopped_info` (no 30) is set.
  constexpr bool has_bag_recording_stopped_info() const noexcept { return set_fields_[35]; }

  /// Clears `bag_recording_stopped_info` (no 30).
  void clear_bag_recording_stopped_info() & noexcept {
    data_ = {};
    set_fields_[35] = false;
    bag_recording_stopped_info_ = {};
  }

  /// Sets `bag_recording_stopped_info` (no 30) and returns `*this`.
  LogData& set_bag_recording_stopped_info(logs::BagRecordingStoppedInfo&& bag_recording_stopped_info) & noexcept {
    clear_data();
    data_ = DataOneof::kBagRecordingStoppedInfo;
    set_fields_[35] = true;
    bag_recording_stopped_info_ = std::move(bag_recording_stopped_info);
    return *this;
  }
  /// Sets `bag_recording_stopped_info` (no 30) and returns `*this`.
  LogData&& set_bag_recording_stopped_info(logs::BagRecordingStoppedInfo&& bag_recording_stopped_info) && noexcept {
    return std::move(set_bag_recording_stopped_info(std::move(bag_recording_stopped_info)));
  }

  // Field `bag_recording_failed_to_start` (no 31).
  // -----

  /// No documentation.
  ///
  /// Field no: 31.
  constexpr const logs::BagRecordingFailedToStart& bag_recording_failed_to_start() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_recording_failed_to_start_;
  }

  /// If `bag_recording_failed_to_start` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 31.
  logs::BagRecordingFailedToStart bag_recording_failed_to_start() && noexcept {
    if (!set_fields_[36]) {
      return {};
    }
    return std::move(bag_recording_failed_to_start_);
  }

  /// No documentation.
  ///
  /// Field no: 31.
  logs::BagRecordingFailedToStart& mutable_bag_recording_failed_to_start() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagRecordingFailedToStart;
    set_fields_[36] = true;
    return bag_recording_failed_to_start_;
  }

  /// Returns whether `bag_recording_failed_to_start` (no 31) is set.
  constexpr bool has_bag_recording_failed_to_start() const noexcept { return set_fields_[36]; }

  /// Clears `bag_recording_failed_to_start` (no 31).
  void clear_bag_recording_failed_to_start() & noexcept {
    data_ = {};
    set_fields_[36] = false;
    bag_recording_failed_to_start_ = {};
  }

  /// Sets `bag_recording_failed_to_start` (no 31) and returns `*this`.
  LogData& set_bag_recording_failed_to_start(logs::BagRecordingFailedToStart&& bag_recording_failed_to_start) & noexcept {
    clear_data();
    data_ = DataOneof::kBagRecordingFailedToStart;
    set_fields_[36] = true;
    bag_recording_failed_to_start_ = std::move(bag_recording_failed_to_start);
    return *this;
  }
  /// Sets `bag_recording_failed_to_start` (no 31) and returns `*this`.
  LogData&& set_bag_recording_failed_to_start(logs::BagRecordingFailedToStart&& bag_recording_failed_to_start) && noexcept {
    return std::move(set_bag_recording_failed_to_start(std::move(bag_recording_failed_to_start)));
  }

  // Field `bag_recording_started_info` (no 32).
  // -----

  /// No documentation.
  ///
  /// Field no: 32.
  constexpr const logs::BagRecordingStartedInfo& bag_recording_started_info() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_recording_started_info_;
  }

  /// If `bag_recording_started_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 32.
  logs::BagRecordingStartedInfo bag_recording_started_info() && noexcept {
    if (!set_fields_[37]) {
      return {};
    }
    return std::move(bag_recording_started_info_);
  }

  /// No documentation.
  ///
  /// Field no: 32.
  logs::BagRecordingStartedInfo& mutable_bag_recording_started_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagRecordingStartedInfo;
    set_fields_[37] = true;
    return bag_recording_started_info_;
  }

  /// Returns whether `bag_recording_started_info` (no 32) is set.
  constexpr bool has_bag_recording_started_info() const noexcept { return set_fields_[37]; }

  /// Clears `bag_recording_started_info` (no 32).
  void clear_bag_recording_started_info() & noexcept {
    data_ = {};
    set_fields_[37] = false;
    bag_recording_started_info_ = {};
  }

  /// Sets `bag_recording_started_info` (no 32) and returns `*this`.
  LogData& set_bag_recording_started_info(logs::BagRecordingStartedInfo&& bag_recording_started_info) & noexcept {
    clear_data();
    data_ = DataOneof::kBagRecordingStartedInfo;
    set_fields_[37] = true;
    bag_recording_started_info_ = std::move(bag_recording_started_info);
    return *this;
  }
  /// Sets `bag_recording_started_info` (no 32) and returns `*this`.
  LogData&& set_bag_recording_started_info(logs::BagRecordingStartedInfo&& bag_recording_started_info) && noexcept {
    return std::move(set_bag_recording_started_info(std::move(bag_recording_started_info)));
  }

  // Field `replay_restarted_info` (no 33).
  // -----

  /// No documentation.
  ///
  /// Field no: 33.
  constexpr const logs::ReplayRestartedInfo& replay_restarted_info() const& noexcept HORUS_LIFETIME_BOUND {
    return replay_restarted_info_;
  }

  /// If `replay_restarted_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 33.
  logs::ReplayRestartedInfo replay_restarted_info() && noexcept {
    if (!set_fields_[38]) {
      return {};
    }
    return std::move(replay_restarted_info_);
  }

  /// No documentation.
  ///
  /// Field no: 33.
  logs::ReplayRestartedInfo& mutable_replay_restarted_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kReplayRestartedInfo;
    set_fields_[38] = true;
    return replay_restarted_info_;
  }

  /// Returns whether `replay_restarted_info` (no 33) is set.
  constexpr bool has_replay_restarted_info() const noexcept { return set_fields_[38]; }

  /// Clears `replay_restarted_info` (no 33).
  void clear_replay_restarted_info() & noexcept {
    data_ = {};
    set_fields_[38] = false;
    replay_restarted_info_ = {};
  }

  /// Sets `replay_restarted_info` (no 33) and returns `*this`.
  LogData& set_replay_restarted_info(logs::ReplayRestartedInfo&& replay_restarted_info) & noexcept {
    clear_data();
    data_ = DataOneof::kReplayRestartedInfo;
    set_fields_[38] = true;
    replay_restarted_info_ = std::move(replay_restarted_info);
    return *this;
  }
  /// Sets `replay_restarted_info` (no 33) and returns `*this`.
  LogData&& set_replay_restarted_info(logs::ReplayRestartedInfo&& replay_restarted_info) && noexcept {
    return std::move(set_replay_restarted_info(std::move(replay_restarted_info)));
  }

  // Field `input_source_change_requested_info` (no 34).
  // -----

  /// No documentation.
  ///
  /// Field no: 34.
  constexpr const logs::InputSourceChangeRequestedInfo& input_source_change_requested_info() const& noexcept HORUS_LIFETIME_BOUND {
    return input_source_change_requested_info_;
  }

  /// If `input_source_change_requested_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 34.
  logs::InputSourceChangeRequestedInfo input_source_change_requested_info() && noexcept {
    if (!set_fields_[39]) {
      return {};
    }
    return std::move(input_source_change_requested_info_);
  }

  /// No documentation.
  ///
  /// Field no: 34.
  logs::InputSourceChangeRequestedInfo& mutable_input_source_change_requested_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInputSourceChangeRequestedInfo;
    set_fields_[39] = true;
    return input_source_change_requested_info_;
  }

  /// Returns whether `input_source_change_requested_info` (no 34) is set.
  constexpr bool has_input_source_change_requested_info() const noexcept { return set_fields_[39]; }

  /// Clears `input_source_change_requested_info` (no 34).
  void clear_input_source_change_requested_info() & noexcept {
    data_ = {};
    set_fields_[39] = false;
    input_source_change_requested_info_ = {};
  }

  /// Sets `input_source_change_requested_info` (no 34) and returns `*this`.
  LogData& set_input_source_change_requested_info(logs::InputSourceChangeRequestedInfo&& input_source_change_requested_info) & noexcept {
    clear_data();
    data_ = DataOneof::kInputSourceChangeRequestedInfo;
    set_fields_[39] = true;
    input_source_change_requested_info_ = std::move(input_source_change_requested_info);
    return *this;
  }
  /// Sets `input_source_change_requested_info` (no 34) and returns `*this`.
  LogData&& set_input_source_change_requested_info(logs::InputSourceChangeRequestedInfo&& input_source_change_requested_info) && noexcept {
    return std::move(set_input_source_change_requested_info(std::move(input_source_change_requested_info)));
  }

  // Field `input_source_switched_info` (no 35).
  // -----

  /// No documentation.
  ///
  /// Field no: 35.
  constexpr const logs::InputSourceSwitchedInfo& input_source_switched_info() const& noexcept HORUS_LIFETIME_BOUND {
    return input_source_switched_info_;
  }

  /// If `input_source_switched_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 35.
  logs::InputSourceSwitchedInfo input_source_switched_info() && noexcept {
    if (!set_fields_[40]) {
      return {};
    }
    return std::move(input_source_switched_info_);
  }

  /// No documentation.
  ///
  /// Field no: 35.
  logs::InputSourceSwitchedInfo& mutable_input_source_switched_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInputSourceSwitchedInfo;
    set_fields_[40] = true;
    return input_source_switched_info_;
  }

  /// Returns whether `input_source_switched_info` (no 35) is set.
  constexpr bool has_input_source_switched_info() const noexcept { return set_fields_[40]; }

  /// Clears `input_source_switched_info` (no 35).
  void clear_input_source_switched_info() & noexcept {
    data_ = {};
    set_fields_[40] = false;
    input_source_switched_info_ = {};
  }

  /// Sets `input_source_switched_info` (no 35) and returns `*this`.
  LogData& set_input_source_switched_info(logs::InputSourceSwitchedInfo&& input_source_switched_info) & noexcept {
    clear_data();
    data_ = DataOneof::kInputSourceSwitchedInfo;
    set_fields_[40] = true;
    input_source_switched_info_ = std::move(input_source_switched_info);
    return *this;
  }
  /// Sets `input_source_switched_info` (no 35) and returns `*this`.
  LogData&& set_input_source_switched_info(logs::InputSourceSwitchedInfo&& input_source_switched_info) && noexcept {
    return std::move(set_input_source_switched_info(std::move(input_source_switched_info)));
  }

  // Field `rpc_timeout_warning` (no 36).
  // -----

  /// No documentation.
  ///
  /// Field no: 36.
  constexpr const logs::RpcTimeoutWarning& rpc_timeout_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_timeout_warning_;
  }

  /// If `rpc_timeout_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 36.
  logs::RpcTimeoutWarning rpc_timeout_warning() && noexcept {
    if (!set_fields_[41]) {
      return {};
    }
    return std::move(rpc_timeout_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 36.
  logs::RpcTimeoutWarning& mutable_rpc_timeout_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcTimeoutWarning;
    set_fields_[41] = true;
    return rpc_timeout_warning_;
  }

  /// Returns whether `rpc_timeout_warning` (no 36) is set.
  constexpr bool has_rpc_timeout_warning() const noexcept { return set_fields_[41]; }

  /// Clears `rpc_timeout_warning` (no 36).
  void clear_rpc_timeout_warning() & noexcept {
    data_ = {};
    set_fields_[41] = false;
    rpc_timeout_warning_ = {};
  }

  /// Sets `rpc_timeout_warning` (no 36) and returns `*this`.
  LogData& set_rpc_timeout_warning(logs::RpcTimeoutWarning&& rpc_timeout_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcTimeoutWarning;
    set_fields_[41] = true;
    rpc_timeout_warning_ = std::move(rpc_timeout_warning);
    return *this;
  }
  /// Sets `rpc_timeout_warning` (no 36) and returns `*this`.
  LogData&& set_rpc_timeout_warning(logs::RpcTimeoutWarning&& rpc_timeout_warning) && noexcept {
    return std::move(set_rpc_timeout_warning(std::move(rpc_timeout_warning)));
  }

  // Field `cannot_write_log_file` (no 37).
  // -----

  /// No documentation.
  ///
  /// Field no: 37.
  constexpr const logs::CannotWriteLogFile& cannot_write_log_file() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_write_log_file_;
  }

  /// If `cannot_write_log_file` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 37.
  logs::CannotWriteLogFile cannot_write_log_file() && noexcept {
    if (!set_fields_[42]) {
      return {};
    }
    return std::move(cannot_write_log_file_);
  }

  /// No documentation.
  ///
  /// Field no: 37.
  logs::CannotWriteLogFile& mutable_cannot_write_log_file() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotWriteLogFile;
    set_fields_[42] = true;
    return cannot_write_log_file_;
  }

  /// Returns whether `cannot_write_log_file` (no 37) is set.
  constexpr bool has_cannot_write_log_file() const noexcept { return set_fields_[42]; }

  /// Clears `cannot_write_log_file` (no 37).
  void clear_cannot_write_log_file() & noexcept {
    data_ = {};
    set_fields_[42] = false;
    cannot_write_log_file_ = {};
  }

  /// Sets `cannot_write_log_file` (no 37) and returns `*this`.
  LogData& set_cannot_write_log_file(logs::CannotWriteLogFile&& cannot_write_log_file) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotWriteLogFile;
    set_fields_[42] = true;
    cannot_write_log_file_ = std::move(cannot_write_log_file);
    return *this;
  }
  /// Sets `cannot_write_log_file` (no 37) and returns `*this`.
  LogData&& set_cannot_write_log_file(logs::CannotWriteLogFile&& cannot_write_log_file) && noexcept {
    return std::move(set_cannot_write_log_file(std::move(cannot_write_log_file)));
  }

  // Field `point_cloud_parsing_failure_warning` (no 38).
  // -----

  /// No documentation.
  ///
  /// Field no: 38.
  constexpr const logs::PointCloudParsingFailureWarning& point_cloud_parsing_failure_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return point_cloud_parsing_failure_warning_;
  }

  /// If `point_cloud_parsing_failure_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 38.
  logs::PointCloudParsingFailureWarning point_cloud_parsing_failure_warning() && noexcept {
    if (!set_fields_[43]) {
      return {};
    }
    return std::move(point_cloud_parsing_failure_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 38.
  logs::PointCloudParsingFailureWarning& mutable_point_cloud_parsing_failure_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kPointCloudParsingFailureWarning;
    set_fields_[43] = true;
    return point_cloud_parsing_failure_warning_;
  }

  /// Returns whether `point_cloud_parsing_failure_warning` (no 38) is set.
  constexpr bool has_point_cloud_parsing_failure_warning() const noexcept { return set_fields_[43]; }

  /// Clears `point_cloud_parsing_failure_warning` (no 38).
  void clear_point_cloud_parsing_failure_warning() & noexcept {
    data_ = {};
    set_fields_[43] = false;
    point_cloud_parsing_failure_warning_ = {};
  }

  /// Sets `point_cloud_parsing_failure_warning` (no 38) and returns `*this`.
  LogData& set_point_cloud_parsing_failure_warning(logs::PointCloudParsingFailureWarning&& point_cloud_parsing_failure_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kPointCloudParsingFailureWarning;
    set_fields_[43] = true;
    point_cloud_parsing_failure_warning_ = std::move(point_cloud_parsing_failure_warning);
    return *this;
  }
  /// Sets `point_cloud_parsing_failure_warning` (no 38) and returns `*this`.
  LogData&& set_point_cloud_parsing_failure_warning(logs::PointCloudParsingFailureWarning&& point_cloud_parsing_failure_warning) && noexcept {
    return std::move(set_point_cloud_parsing_failure_warning(std::move(point_cloud_parsing_failure_warning)));
  }

  // Field `lidar_is_dead` (no 39).
  // -----

  /// No documentation.
  ///
  /// Field no: 39.
  constexpr const logs::LidarIsDead& lidar_is_dead() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_dead_;
  }

  /// If `lidar_is_dead` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 39.
  logs::LidarIsDead lidar_is_dead() && noexcept {
    if (!set_fields_[44]) {
      return {};
    }
    return std::move(lidar_is_dead_);
  }

  /// No documentation.
  ///
  /// Field no: 39.
  logs::LidarIsDead& mutable_lidar_is_dead() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsDead;
    set_fields_[44] = true;
    return lidar_is_dead_;
  }

  /// Returns whether `lidar_is_dead` (no 39) is set.
  constexpr bool has_lidar_is_dead() const noexcept { return set_fields_[44]; }

  /// Clears `lidar_is_dead` (no 39).
  void clear_lidar_is_dead() & noexcept {
    data_ = {};
    set_fields_[44] = false;
    lidar_is_dead_ = {};
  }

  /// Sets `lidar_is_dead` (no 39) and returns `*this`.
  LogData& set_lidar_is_dead(logs::LidarIsDead&& lidar_is_dead) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsDead;
    set_fields_[44] = true;
    lidar_is_dead_ = std::move(lidar_is_dead);
    return *this;
  }
  /// Sets `lidar_is_dead` (no 39) and returns `*this`.
  LogData&& set_lidar_is_dead(logs::LidarIsDead&& lidar_is_dead) && noexcept {
    return std::move(set_lidar_is_dead(std::move(lidar_is_dead)));
  }

  // Field `lidar_is_not_dead_anymore` (no 40).
  // -----

  /// No documentation.
  ///
  /// Field no: 40.
  constexpr const logs::LidarIsNotDeadAnymore& lidar_is_not_dead_anymore() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_not_dead_anymore_;
  }

  /// If `lidar_is_not_dead_anymore` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 40.
  logs::LidarIsNotDeadAnymore lidar_is_not_dead_anymore() && noexcept {
    if (!set_fields_[45]) {
      return {};
    }
    return std::move(lidar_is_not_dead_anymore_);
  }

  /// No documentation.
  ///
  /// Field no: 40.
  logs::LidarIsNotDeadAnymore& mutable_lidar_is_not_dead_anymore() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsNotDeadAnymore;
    set_fields_[45] = true;
    return lidar_is_not_dead_anymore_;
  }

  /// Returns whether `lidar_is_not_dead_anymore` (no 40) is set.
  constexpr bool has_lidar_is_not_dead_anymore() const noexcept { return set_fields_[45]; }

  /// Clears `lidar_is_not_dead_anymore` (no 40).
  void clear_lidar_is_not_dead_anymore() & noexcept {
    data_ = {};
    set_fields_[45] = false;
    lidar_is_not_dead_anymore_ = {};
  }

  /// Sets `lidar_is_not_dead_anymore` (no 40) and returns `*this`.
  LogData& set_lidar_is_not_dead_anymore(logs::LidarIsNotDeadAnymore&& lidar_is_not_dead_anymore) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsNotDeadAnymore;
    set_fields_[45] = true;
    lidar_is_not_dead_anymore_ = std::move(lidar_is_not_dead_anymore);
    return *this;
  }
  /// Sets `lidar_is_not_dead_anymore` (no 40) and returns `*this`.
  LogData&& set_lidar_is_not_dead_anymore(logs::LidarIsNotDeadAnymore&& lidar_is_not_dead_anymore) && noexcept {
    return std::move(set_lidar_is_not_dead_anymore(std::move(lidar_is_not_dead_anymore)));
  }

  // Field `lidar_is_obstructed` (no 41).
  // -----

  /// No documentation.
  ///
  /// Field no: 41.
  constexpr const logs::LidarIsObstructed& lidar_is_obstructed() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_obstructed_;
  }

  /// If `lidar_is_obstructed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 41.
  logs::LidarIsObstructed lidar_is_obstructed() && noexcept {
    if (!set_fields_[46]) {
      return {};
    }
    return std::move(lidar_is_obstructed_);
  }

  /// No documentation.
  ///
  /// Field no: 41.
  logs::LidarIsObstructed& mutable_lidar_is_obstructed() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsObstructed;
    set_fields_[46] = true;
    return lidar_is_obstructed_;
  }

  /// Returns whether `lidar_is_obstructed` (no 41) is set.
  constexpr bool has_lidar_is_obstructed() const noexcept { return set_fields_[46]; }

  /// Clears `lidar_is_obstructed` (no 41).
  void clear_lidar_is_obstructed() & noexcept {
    data_ = {};
    set_fields_[46] = false;
    lidar_is_obstructed_ = {};
  }

  /// Sets `lidar_is_obstructed` (no 41) and returns `*this`.
  LogData& set_lidar_is_obstructed(logs::LidarIsObstructed&& lidar_is_obstructed) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsObstructed;
    set_fields_[46] = true;
    lidar_is_obstructed_ = std::move(lidar_is_obstructed);
    return *this;
  }
  /// Sets `lidar_is_obstructed` (no 41) and returns `*this`.
  LogData&& set_lidar_is_obstructed(logs::LidarIsObstructed&& lidar_is_obstructed) && noexcept {
    return std::move(set_lidar_is_obstructed(std::move(lidar_is_obstructed)));
  }

  // Field `lidar_is_not_obstructed_anymore` (no 42).
  // -----

  /// No documentation.
  ///
  /// Field no: 42.
  constexpr const logs::LidarIsNotObstructedAnymore& lidar_is_not_obstructed_anymore() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_not_obstructed_anymore_;
  }

  /// If `lidar_is_not_obstructed_anymore` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 42.
  logs::LidarIsNotObstructedAnymore lidar_is_not_obstructed_anymore() && noexcept {
    if (!set_fields_[47]) {
      return {};
    }
    return std::move(lidar_is_not_obstructed_anymore_);
  }

  /// No documentation.
  ///
  /// Field no: 42.
  logs::LidarIsNotObstructedAnymore& mutable_lidar_is_not_obstructed_anymore() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsNotObstructedAnymore;
    set_fields_[47] = true;
    return lidar_is_not_obstructed_anymore_;
  }

  /// Returns whether `lidar_is_not_obstructed_anymore` (no 42) is set.
  constexpr bool has_lidar_is_not_obstructed_anymore() const noexcept { return set_fields_[47]; }

  /// Clears `lidar_is_not_obstructed_anymore` (no 42).
  void clear_lidar_is_not_obstructed_anymore() & noexcept {
    data_ = {};
    set_fields_[47] = false;
    lidar_is_not_obstructed_anymore_ = {};
  }

  /// Sets `lidar_is_not_obstructed_anymore` (no 42) and returns `*this`.
  LogData& set_lidar_is_not_obstructed_anymore(logs::LidarIsNotObstructedAnymore&& lidar_is_not_obstructed_anymore) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsNotObstructedAnymore;
    set_fields_[47] = true;
    lidar_is_not_obstructed_anymore_ = std::move(lidar_is_not_obstructed_anymore);
    return *this;
  }
  /// Sets `lidar_is_not_obstructed_anymore` (no 42) and returns `*this`.
  LogData&& set_lidar_is_not_obstructed_anymore(logs::LidarIsNotObstructedAnymore&& lidar_is_not_obstructed_anymore) && noexcept {
    return std::move(set_lidar_is_not_obstructed_anymore(std::move(lidar_is_not_obstructed_anymore)));
  }

  // Field `lidar_is_tilted` (no 43).
  // -----

  /// No documentation.
  ///
  /// Field no: 43.
  constexpr const logs::LidarIsTilted& lidar_is_tilted() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_tilted_;
  }

  /// If `lidar_is_tilted` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 43.
  logs::LidarIsTilted lidar_is_tilted() && noexcept {
    if (!set_fields_[48]) {
      return {};
    }
    return std::move(lidar_is_tilted_);
  }

  /// No documentation.
  ///
  /// Field no: 43.
  logs::LidarIsTilted& mutable_lidar_is_tilted() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsTilted;
    set_fields_[48] = true;
    return lidar_is_tilted_;
  }

  /// Returns whether `lidar_is_tilted` (no 43) is set.
  constexpr bool has_lidar_is_tilted() const noexcept { return set_fields_[48]; }

  /// Clears `lidar_is_tilted` (no 43).
  void clear_lidar_is_tilted() & noexcept {
    data_ = {};
    set_fields_[48] = false;
    lidar_is_tilted_ = {};
  }

  /// Sets `lidar_is_tilted` (no 43) and returns `*this`.
  LogData& set_lidar_is_tilted(logs::LidarIsTilted&& lidar_is_tilted) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsTilted;
    set_fields_[48] = true;
    lidar_is_tilted_ = std::move(lidar_is_tilted);
    return *this;
  }
  /// Sets `lidar_is_tilted` (no 43) and returns `*this`.
  LogData&& set_lidar_is_tilted(logs::LidarIsTilted&& lidar_is_tilted) && noexcept {
    return std::move(set_lidar_is_tilted(std::move(lidar_is_tilted)));
  }

  // Field `lidar_is_not_tilted_anymore` (no 44).
  // -----

  /// No documentation.
  ///
  /// Field no: 44.
  constexpr const logs::LidarIsNotTiltedAnymore& lidar_is_not_tilted_anymore() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_is_not_tilted_anymore_;
  }

  /// If `lidar_is_not_tilted_anymore` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 44.
  logs::LidarIsNotTiltedAnymore lidar_is_not_tilted_anymore() && noexcept {
    if (!set_fields_[49]) {
      return {};
    }
    return std::move(lidar_is_not_tilted_anymore_);
  }

  /// No documentation.
  ///
  /// Field no: 44.
  logs::LidarIsNotTiltedAnymore& mutable_lidar_is_not_tilted_anymore() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIsNotTiltedAnymore;
    set_fields_[49] = true;
    return lidar_is_not_tilted_anymore_;
  }

  /// Returns whether `lidar_is_not_tilted_anymore` (no 44) is set.
  constexpr bool has_lidar_is_not_tilted_anymore() const noexcept { return set_fields_[49]; }

  /// Clears `lidar_is_not_tilted_anymore` (no 44).
  void clear_lidar_is_not_tilted_anymore() & noexcept {
    data_ = {};
    set_fields_[49] = false;
    lidar_is_not_tilted_anymore_ = {};
  }

  /// Sets `lidar_is_not_tilted_anymore` (no 44) and returns `*this`.
  LogData& set_lidar_is_not_tilted_anymore(logs::LidarIsNotTiltedAnymore&& lidar_is_not_tilted_anymore) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIsNotTiltedAnymore;
    set_fields_[49] = true;
    lidar_is_not_tilted_anymore_ = std::move(lidar_is_not_tilted_anymore);
    return *this;
  }
  /// Sets `lidar_is_not_tilted_anymore` (no 44) and returns `*this`.
  LogData&& set_lidar_is_not_tilted_anymore(logs::LidarIsNotTiltedAnymore&& lidar_is_not_tilted_anymore) && noexcept {
    return std::move(set_lidar_is_not_tilted_anymore(std::move(lidar_is_not_tilted_anymore)));
  }

  // Field `lidar_has_been_automatically_recalibrated` (no 45).
  // -----

  /// No documentation.
  ///
  /// Field no: 45.
  constexpr const logs::LidarHasBeenAutomaticallyRecalibrated& lidar_has_been_automatically_recalibrated() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_has_been_automatically_recalibrated_;
  }

  /// If `lidar_has_been_automatically_recalibrated` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 45.
  logs::LidarHasBeenAutomaticallyRecalibrated lidar_has_been_automatically_recalibrated() && noexcept {
    if (!set_fields_[50]) {
      return {};
    }
    return std::move(lidar_has_been_automatically_recalibrated_);
  }

  /// No documentation.
  ///
  /// Field no: 45.
  logs::LidarHasBeenAutomaticallyRecalibrated& mutable_lidar_has_been_automatically_recalibrated() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarHasBeenAutomaticallyRecalibrated;
    set_fields_[50] = true;
    return lidar_has_been_automatically_recalibrated_;
  }

  /// Returns whether `lidar_has_been_automatically_recalibrated` (no 45) is set.
  constexpr bool has_lidar_has_been_automatically_recalibrated() const noexcept { return set_fields_[50]; }

  /// Clears `lidar_has_been_automatically_recalibrated` (no 45).
  void clear_lidar_has_been_automatically_recalibrated() & noexcept {
    data_ = {};
    set_fields_[50] = false;
    lidar_has_been_automatically_recalibrated_ = {};
  }

  /// Sets `lidar_has_been_automatically_recalibrated` (no 45) and returns `*this`.
  LogData& set_lidar_has_been_automatically_recalibrated(logs::LidarHasBeenAutomaticallyRecalibrated&& lidar_has_been_automatically_recalibrated) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarHasBeenAutomaticallyRecalibrated;
    set_fields_[50] = true;
    lidar_has_been_automatically_recalibrated_ = std::move(lidar_has_been_automatically_recalibrated);
    return *this;
  }
  /// Sets `lidar_has_been_automatically_recalibrated` (no 45) and returns `*this`.
  LogData&& set_lidar_has_been_automatically_recalibrated(logs::LidarHasBeenAutomaticallyRecalibrated&& lidar_has_been_automatically_recalibrated) && noexcept {
    return std::move(set_lidar_has_been_automatically_recalibrated(std::move(lidar_has_been_automatically_recalibrated)));
  }

  // Field `received_first_data_for_lidar` (no 46).
  // -----

  /// No documentation.
  ///
  /// Field no: 46.
  constexpr const logs::ReceivedFirstDataForLidar& received_first_data_for_lidar() const& noexcept HORUS_LIFETIME_BOUND {
    return received_first_data_for_lidar_;
  }

  /// If `received_first_data_for_lidar` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 46.
  logs::ReceivedFirstDataForLidar received_first_data_for_lidar() && noexcept {
    if (!set_fields_[51]) {
      return {};
    }
    return std::move(received_first_data_for_lidar_);
  }

  /// No documentation.
  ///
  /// Field no: 46.
  logs::ReceivedFirstDataForLidar& mutable_received_first_data_for_lidar() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kReceivedFirstDataForLidar;
    set_fields_[51] = true;
    return received_first_data_for_lidar_;
  }

  /// Returns whether `received_first_data_for_lidar` (no 46) is set.
  constexpr bool has_received_first_data_for_lidar() const noexcept { return set_fields_[51]; }

  /// Clears `received_first_data_for_lidar` (no 46).
  void clear_received_first_data_for_lidar() & noexcept {
    data_ = {};
    set_fields_[51] = false;
    received_first_data_for_lidar_ = {};
  }

  /// Sets `received_first_data_for_lidar` (no 46) and returns `*this`.
  LogData& set_received_first_data_for_lidar(logs::ReceivedFirstDataForLidar&& received_first_data_for_lidar) & noexcept {
    clear_data();
    data_ = DataOneof::kReceivedFirstDataForLidar;
    set_fields_[51] = true;
    received_first_data_for_lidar_ = std::move(received_first_data_for_lidar);
    return *this;
  }
  /// Sets `received_first_data_for_lidar` (no 46) and returns `*this`.
  LogData&& set_received_first_data_for_lidar(logs::ReceivedFirstDataForLidar&& received_first_data_for_lidar) && noexcept {
    return std::move(set_received_first_data_for_lidar(std::move(received_first_data_for_lidar)));
  }

  // Field `termination_failure_error` (no 47).
  // -----

  /// No documentation.
  ///
  /// Field no: 47.
  constexpr const logs::TerminationFailureError& termination_failure_error() const& noexcept HORUS_LIFETIME_BOUND {
    return termination_failure_error_;
  }

  /// If `termination_failure_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 47.
  logs::TerminationFailureError termination_failure_error() && noexcept {
    if (!set_fields_[52]) {
      return {};
    }
    return std::move(termination_failure_error_);
  }

  /// No documentation.
  ///
  /// Field no: 47.
  logs::TerminationFailureError& mutable_termination_failure_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kTerminationFailureError;
    set_fields_[52] = true;
    return termination_failure_error_;
  }

  /// Returns whether `termination_failure_error` (no 47) is set.
  constexpr bool has_termination_failure_error() const noexcept { return set_fields_[52]; }

  /// Clears `termination_failure_error` (no 47).
  void clear_termination_failure_error() & noexcept {
    data_ = {};
    set_fields_[52] = false;
    termination_failure_error_ = {};
  }

  /// Sets `termination_failure_error` (no 47) and returns `*this`.
  LogData& set_termination_failure_error(logs::TerminationFailureError&& termination_failure_error) & noexcept {
    clear_data();
    data_ = DataOneof::kTerminationFailureError;
    set_fields_[52] = true;
    termination_failure_error_ = std::move(termination_failure_error);
    return *this;
  }
  /// Sets `termination_failure_error` (no 47) and returns `*this`.
  LogData&& set_termination_failure_error(logs::TerminationFailureError&& termination_failure_error) && noexcept {
    return std::move(set_termination_failure_error(std::move(termination_failure_error)));
  }

  // Field `frame_processing_error` (no 48).
  // -----

  /// No documentation.
  ///
  /// Field no: 48.
  constexpr const logs::FrameProcessingError& frame_processing_error() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_processing_error_;
  }

  /// If `frame_processing_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 48.
  logs::FrameProcessingError frame_processing_error() && noexcept {
    if (!set_fields_[53]) {
      return {};
    }
    return std::move(frame_processing_error_);
  }

  /// No documentation.
  ///
  /// Field no: 48.
  logs::FrameProcessingError& mutable_frame_processing_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFrameProcessingError;
    set_fields_[53] = true;
    return frame_processing_error_;
  }

  /// Returns whether `frame_processing_error` (no 48) is set.
  constexpr bool has_frame_processing_error() const noexcept { return set_fields_[53]; }

  /// Clears `frame_processing_error` (no 48).
  void clear_frame_processing_error() & noexcept {
    data_ = {};
    set_fields_[53] = false;
    frame_processing_error_ = {};
  }

  /// Sets `frame_processing_error` (no 48) and returns `*this`.
  LogData& set_frame_processing_error(logs::FrameProcessingError&& frame_processing_error) & noexcept {
    clear_data();
    data_ = DataOneof::kFrameProcessingError;
    set_fields_[53] = true;
    frame_processing_error_ = std::move(frame_processing_error);
    return *this;
  }
  /// Sets `frame_processing_error` (no 48) and returns `*this`.
  LogData&& set_frame_processing_error(logs::FrameProcessingError&& frame_processing_error) && noexcept {
    return std::move(set_frame_processing_error(std::move(frame_processing_error)));
  }

  // Field `thread_pool_unavailable_error` (no 49).
  // -----

  /// No documentation.
  ///
  /// Field no: 49.
  constexpr const logs::ThreadPoolUnavailableError& thread_pool_unavailable_error() const& noexcept HORUS_LIFETIME_BOUND {
    return thread_pool_unavailable_error_;
  }

  /// If `thread_pool_unavailable_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 49.
  logs::ThreadPoolUnavailableError thread_pool_unavailable_error() && noexcept {
    if (!set_fields_[54]) {
      return {};
    }
    return std::move(thread_pool_unavailable_error_);
  }

  /// No documentation.
  ///
  /// Field no: 49.
  logs::ThreadPoolUnavailableError& mutable_thread_pool_unavailable_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kThreadPoolUnavailableError;
    set_fields_[54] = true;
    return thread_pool_unavailable_error_;
  }

  /// Returns whether `thread_pool_unavailable_error` (no 49) is set.
  constexpr bool has_thread_pool_unavailable_error() const noexcept { return set_fields_[54]; }

  /// Clears `thread_pool_unavailable_error` (no 49).
  void clear_thread_pool_unavailable_error() & noexcept {
    data_ = {};
    set_fields_[54] = false;
    thread_pool_unavailable_error_ = {};
  }

  /// Sets `thread_pool_unavailable_error` (no 49) and returns `*this`.
  LogData& set_thread_pool_unavailable_error(logs::ThreadPoolUnavailableError&& thread_pool_unavailable_error) & noexcept {
    clear_data();
    data_ = DataOneof::kThreadPoolUnavailableError;
    set_fields_[54] = true;
    thread_pool_unavailable_error_ = std::move(thread_pool_unavailable_error);
    return *this;
  }
  /// Sets `thread_pool_unavailable_error` (no 49) and returns `*this`.
  LogData&& set_thread_pool_unavailable_error(logs::ThreadPoolUnavailableError&& thread_pool_unavailable_error) && noexcept {
    return std::move(set_thread_pool_unavailable_error(std::move(thread_pool_unavailable_error)));
  }

  // Field `invalid_argument` (no 50).
  // -----

  /// No documentation.
  ///
  /// Field no: 50.
  constexpr const logs::InvalidArgument& invalid_argument() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_argument_;
  }

  /// If `invalid_argument` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 50.
  logs::InvalidArgument invalid_argument() && noexcept {
    if (!set_fields_[55]) {
      return {};
    }
    return std::move(invalid_argument_);
  }

  /// No documentation.
  ///
  /// Field no: 50.
  logs::InvalidArgument& mutable_invalid_argument() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidArgument;
    set_fields_[55] = true;
    return invalid_argument_;
  }

  /// Returns whether `invalid_argument` (no 50) is set.
  constexpr bool has_invalid_argument() const noexcept { return set_fields_[55]; }

  /// Clears `invalid_argument` (no 50).
  void clear_invalid_argument() & noexcept {
    data_ = {};
    set_fields_[55] = false;
    invalid_argument_ = {};
  }

  /// Sets `invalid_argument` (no 50) and returns `*this`.
  LogData& set_invalid_argument(logs::InvalidArgument&& invalid_argument) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidArgument;
    set_fields_[55] = true;
    invalid_argument_ = std::move(invalid_argument);
    return *this;
  }
  /// Sets `invalid_argument` (no 50) and returns `*this`.
  LogData&& set_invalid_argument(logs::InvalidArgument&& invalid_argument) && noexcept {
    return std::move(set_invalid_argument(std::move(invalid_argument)));
  }

  // Field `component_initialization_failure_fatal` (no 51).
  // -----

  /// No documentation.
  ///
  /// Field no: 51.
  constexpr const logs::ComponentInitializationFailureFatal& component_initialization_failure_fatal() const& noexcept HORUS_LIFETIME_BOUND {
    return component_initialization_failure_fatal_;
  }

  /// If `component_initialization_failure_fatal` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 51.
  logs::ComponentInitializationFailureFatal component_initialization_failure_fatal() && noexcept {
    if (!set_fields_[56]) {
      return {};
    }
    return std::move(component_initialization_failure_fatal_);
  }

  /// No documentation.
  ///
  /// Field no: 51.
  logs::ComponentInitializationFailureFatal& mutable_component_initialization_failure_fatal() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kComponentInitializationFailureFatal;
    set_fields_[56] = true;
    return component_initialization_failure_fatal_;
  }

  /// Returns whether `component_initialization_failure_fatal` (no 51) is set.
  constexpr bool has_component_initialization_failure_fatal() const noexcept { return set_fields_[56]; }

  /// Clears `component_initialization_failure_fatal` (no 51).
  void clear_component_initialization_failure_fatal() & noexcept {
    data_ = {};
    set_fields_[56] = false;
    component_initialization_failure_fatal_ = {};
  }

  /// Sets `component_initialization_failure_fatal` (no 51) and returns `*this`.
  LogData& set_component_initialization_failure_fatal(logs::ComponentInitializationFailureFatal&& component_initialization_failure_fatal) & noexcept {
    clear_data();
    data_ = DataOneof::kComponentInitializationFailureFatal;
    set_fields_[56] = true;
    component_initialization_failure_fatal_ = std::move(component_initialization_failure_fatal);
    return *this;
  }
  /// Sets `component_initialization_failure_fatal` (no 51) and returns `*this`.
  LogData&& set_component_initialization_failure_fatal(logs::ComponentInitializationFailureFatal&& component_initialization_failure_fatal) && noexcept {
    return std::move(set_component_initialization_failure_fatal(std::move(component_initialization_failure_fatal)));
  }

  // Field `unhandled_enum_case_error` (no 52).
  // -----

  /// No documentation.
  ///
  /// Field no: 52.
  constexpr const logs::UnhandledEnumCaseError& unhandled_enum_case_error() const& noexcept HORUS_LIFETIME_BOUND {
    return unhandled_enum_case_error_;
  }

  /// If `unhandled_enum_case_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 52.
  logs::UnhandledEnumCaseError unhandled_enum_case_error() && noexcept {
    if (!set_fields_[57]) {
      return {};
    }
    return std::move(unhandled_enum_case_error_);
  }

  /// No documentation.
  ///
  /// Field no: 52.
  logs::UnhandledEnumCaseError& mutable_unhandled_enum_case_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kUnhandledEnumCaseError;
    set_fields_[57] = true;
    return unhandled_enum_case_error_;
  }

  /// Returns whether `unhandled_enum_case_error` (no 52) is set.
  constexpr bool has_unhandled_enum_case_error() const noexcept { return set_fields_[57]; }

  /// Clears `unhandled_enum_case_error` (no 52).
  void clear_unhandled_enum_case_error() & noexcept {
    data_ = {};
    set_fields_[57] = false;
    unhandled_enum_case_error_ = {};
  }

  /// Sets `unhandled_enum_case_error` (no 52) and returns `*this`.
  LogData& set_unhandled_enum_case_error(logs::UnhandledEnumCaseError&& unhandled_enum_case_error) & noexcept {
    clear_data();
    data_ = DataOneof::kUnhandledEnumCaseError;
    set_fields_[57] = true;
    unhandled_enum_case_error_ = std::move(unhandled_enum_case_error);
    return *this;
  }
  /// Sets `unhandled_enum_case_error` (no 52) and returns `*this`.
  LogData&& set_unhandled_enum_case_error(logs::UnhandledEnumCaseError&& unhandled_enum_case_error) && noexcept {
    return std::move(set_unhandled_enum_case_error(std::move(unhandled_enum_case_error)));
  }

  // Field `bag_empty_error` (no 53).
  // -----

  /// No documentation.
  ///
  /// Field no: 53.
  constexpr const logs::BagEmptyError& bag_empty_error() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_empty_error_;
  }

  /// If `bag_empty_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 53.
  logs::BagEmptyError bag_empty_error() && noexcept {
    if (!set_fields_[58]) {
      return {};
    }
    return std::move(bag_empty_error_);
  }

  /// No documentation.
  ///
  /// Field no: 53.
  logs::BagEmptyError& mutable_bag_empty_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagEmptyError;
    set_fields_[58] = true;
    return bag_empty_error_;
  }

  /// Returns whether `bag_empty_error` (no 53) is set.
  constexpr bool has_bag_empty_error() const noexcept { return set_fields_[58]; }

  /// Clears `bag_empty_error` (no 53).
  void clear_bag_empty_error() & noexcept {
    data_ = {};
    set_fields_[58] = false;
    bag_empty_error_ = {};
  }

  /// Sets `bag_empty_error` (no 53) and returns `*this`.
  LogData& set_bag_empty_error(logs::BagEmptyError&& bag_empty_error) & noexcept {
    clear_data();
    data_ = DataOneof::kBagEmptyError;
    set_fields_[58] = true;
    bag_empty_error_ = std::move(bag_empty_error);
    return *this;
  }
  /// Sets `bag_empty_error` (no 53) and returns `*this`.
  LogData&& set_bag_empty_error(logs::BagEmptyError&& bag_empty_error) && noexcept {
    return std::move(set_bag_empty_error(std::move(bag_empty_error)));
  }

  // Field `discarding_data_error` (no 54).
  // -----

  /// No documentation.
  ///
  /// Field no: 54.
  constexpr const logs::DiscardingDataError& discarding_data_error() const& noexcept HORUS_LIFETIME_BOUND {
    return discarding_data_error_;
  }

  /// If `discarding_data_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 54.
  logs::DiscardingDataError discarding_data_error() && noexcept {
    if (!set_fields_[59]) {
      return {};
    }
    return std::move(discarding_data_error_);
  }

  /// No documentation.
  ///
  /// Field no: 54.
  logs::DiscardingDataError& mutable_discarding_data_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kDiscardingDataError;
    set_fields_[59] = true;
    return discarding_data_error_;
  }

  /// Returns whether `discarding_data_error` (no 54) is set.
  constexpr bool has_discarding_data_error() const noexcept { return set_fields_[59]; }

  /// Clears `discarding_data_error` (no 54).
  void clear_discarding_data_error() & noexcept {
    data_ = {};
    set_fields_[59] = false;
    discarding_data_error_ = {};
  }

  /// Sets `discarding_data_error` (no 54) and returns `*this`.
  LogData& set_discarding_data_error(logs::DiscardingDataError&& discarding_data_error) & noexcept {
    clear_data();
    data_ = DataOneof::kDiscardingDataError;
    set_fields_[59] = true;
    discarding_data_error_ = std::move(discarding_data_error);
    return *this;
  }
  /// Sets `discarding_data_error` (no 54) and returns `*this`.
  LogData&& set_discarding_data_error(logs::DiscardingDataError&& discarding_data_error) && noexcept {
    return std::move(set_discarding_data_error(std::move(discarding_data_error)));
  }

  // Field `discarding_data_warning` (no 55).
  // -----

  /// No documentation.
  ///
  /// Field no: 55.
  constexpr const logs::DiscardingDataWarning& discarding_data_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return discarding_data_warning_;
  }

  /// If `discarding_data_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 55.
  logs::DiscardingDataWarning discarding_data_warning() && noexcept {
    if (!set_fields_[60]) {
      return {};
    }
    return std::move(discarding_data_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 55.
  logs::DiscardingDataWarning& mutable_discarding_data_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kDiscardingDataWarning;
    set_fields_[60] = true;
    return discarding_data_warning_;
  }

  /// Returns whether `discarding_data_warning` (no 55) is set.
  constexpr bool has_discarding_data_warning() const noexcept { return set_fields_[60]; }

  /// Clears `discarding_data_warning` (no 55).
  void clear_discarding_data_warning() & noexcept {
    data_ = {};
    set_fields_[60] = false;
    discarding_data_warning_ = {};
  }

  /// Sets `discarding_data_warning` (no 55) and returns `*this`.
  LogData& set_discarding_data_warning(logs::DiscardingDataWarning&& discarding_data_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kDiscardingDataWarning;
    set_fields_[60] = true;
    discarding_data_warning_ = std::move(discarding_data_warning);
    return *this;
  }
  /// Sets `discarding_data_warning` (no 55) and returns `*this`.
  LogData&& set_discarding_data_warning(logs::DiscardingDataWarning&& discarding_data_warning) && noexcept {
    return std::move(set_discarding_data_warning(std::move(discarding_data_warning)));
  }

  // Field `nothing_to_process` (no 56).
  // -----

  /// No documentation.
  ///
  /// Field no: 56.
  constexpr const logs::NothingToProcess& nothing_to_process() const& noexcept HORUS_LIFETIME_BOUND {
    return nothing_to_process_;
  }

  /// If `nothing_to_process` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 56.
  logs::NothingToProcess nothing_to_process() && noexcept {
    if (!set_fields_[61]) {
      return {};
    }
    return std::move(nothing_to_process_);
  }

  /// No documentation.
  ///
  /// Field no: 56.
  logs::NothingToProcess& mutable_nothing_to_process() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kNothingToProcess;
    set_fields_[61] = true;
    return nothing_to_process_;
  }

  /// Returns whether `nothing_to_process` (no 56) is set.
  constexpr bool has_nothing_to_process() const noexcept { return set_fields_[61]; }

  /// Clears `nothing_to_process` (no 56).
  void clear_nothing_to_process() & noexcept {
    data_ = {};
    set_fields_[61] = false;
    nothing_to_process_ = {};
  }

  /// Sets `nothing_to_process` (no 56) and returns `*this`.
  LogData& set_nothing_to_process(logs::NothingToProcess&& nothing_to_process) & noexcept {
    clear_data();
    data_ = DataOneof::kNothingToProcess;
    set_fields_[61] = true;
    nothing_to_process_ = std::move(nothing_to_process);
    return *this;
  }
  /// Sets `nothing_to_process` (no 56) and returns `*this`.
  LogData&& set_nothing_to_process(logs::NothingToProcess&& nothing_to_process) && noexcept {
    return std::move(set_nothing_to_process(std::move(nothing_to_process)));
  }

  // Field `invalid_component_configuration` (no 57).
  // -----

  /// No documentation.
  ///
  /// Field no: 57.
  constexpr const logs::InvalidComponentConfiguration& invalid_component_configuration() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_component_configuration_;
  }

  /// If `invalid_component_configuration` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 57.
  logs::InvalidComponentConfiguration invalid_component_configuration() && noexcept {
    if (!set_fields_[62]) {
      return {};
    }
    return std::move(invalid_component_configuration_);
  }

  /// No documentation.
  ///
  /// Field no: 57.
  logs::InvalidComponentConfiguration& mutable_invalid_component_configuration() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidComponentConfiguration;
    set_fields_[62] = true;
    return invalid_component_configuration_;
  }

  /// Returns whether `invalid_component_configuration` (no 57) is set.
  constexpr bool has_invalid_component_configuration() const noexcept { return set_fields_[62]; }

  /// Clears `invalid_component_configuration` (no 57).
  void clear_invalid_component_configuration() & noexcept {
    data_ = {};
    set_fields_[62] = false;
    invalid_component_configuration_ = {};
  }

  /// Sets `invalid_component_configuration` (no 57) and returns `*this`.
  LogData& set_invalid_component_configuration(logs::InvalidComponentConfiguration&& invalid_component_configuration) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidComponentConfiguration;
    set_fields_[62] = true;
    invalid_component_configuration_ = std::move(invalid_component_configuration);
    return *this;
  }
  /// Sets `invalid_component_configuration` (no 57) and returns `*this`.
  LogData&& set_invalid_component_configuration(logs::InvalidComponentConfiguration&& invalid_component_configuration) && noexcept {
    return std::move(set_invalid_component_configuration(std::move(invalid_component_configuration)));
  }

  // Field `channel_receiver_not_found_warning` (no 58).
  // -----

  /// No documentation.
  ///
  /// Field no: 58.
  constexpr const logs::ChannelReceiverNotFoundWarning& channel_receiver_not_found_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return channel_receiver_not_found_warning_;
  }

  /// If `channel_receiver_not_found_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 58.
  logs::ChannelReceiverNotFoundWarning channel_receiver_not_found_warning() && noexcept {
    if (!set_fields_[63]) {
      return {};
    }
    return std::move(channel_receiver_not_found_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 58.
  logs::ChannelReceiverNotFoundWarning& mutable_channel_receiver_not_found_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kChannelReceiverNotFoundWarning;
    set_fields_[63] = true;
    return channel_receiver_not_found_warning_;
  }

  /// Returns whether `channel_receiver_not_found_warning` (no 58) is set.
  constexpr bool has_channel_receiver_not_found_warning() const noexcept { return set_fields_[63]; }

  /// Clears `channel_receiver_not_found_warning` (no 58).
  void clear_channel_receiver_not_found_warning() & noexcept {
    data_ = {};
    set_fields_[63] = false;
    channel_receiver_not_found_warning_ = {};
  }

  /// Sets `channel_receiver_not_found_warning` (no 58) and returns `*this`.
  LogData& set_channel_receiver_not_found_warning(logs::ChannelReceiverNotFoundWarning&& channel_receiver_not_found_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kChannelReceiverNotFoundWarning;
    set_fields_[63] = true;
    channel_receiver_not_found_warning_ = std::move(channel_receiver_not_found_warning);
    return *this;
  }
  /// Sets `channel_receiver_not_found_warning` (no 58) and returns `*this`.
  LogData&& set_channel_receiver_not_found_warning(logs::ChannelReceiverNotFoundWarning&& channel_receiver_not_found_warning) && noexcept {
    return std::move(set_channel_receiver_not_found_warning(std::move(channel_receiver_not_found_warning)));
  }

  // Field `model_load_failure` (no 59).
  // -----

  /// No documentation.
  ///
  /// Field no: 59.
  constexpr const logs::ModelLoadFailure& model_load_failure() const& noexcept HORUS_LIFETIME_BOUND {
    return model_load_failure_;
  }

  /// If `model_load_failure` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 59.
  logs::ModelLoadFailure model_load_failure() && noexcept {
    if (!set_fields_[64]) {
      return {};
    }
    return std::move(model_load_failure_);
  }

  /// No documentation.
  ///
  /// Field no: 59.
  logs::ModelLoadFailure& mutable_model_load_failure() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelLoadFailure;
    set_fields_[64] = true;
    return model_load_failure_;
  }

  /// Returns whether `model_load_failure` (no 59) is set.
  constexpr bool has_model_load_failure() const noexcept { return set_fields_[64]; }

  /// Clears `model_load_failure` (no 59).
  void clear_model_load_failure() & noexcept {
    data_ = {};
    set_fields_[64] = false;
    model_load_failure_ = {};
  }

  /// Sets `model_load_failure` (no 59) and returns `*this`.
  LogData& set_model_load_failure(logs::ModelLoadFailure&& model_load_failure) & noexcept {
    clear_data();
    data_ = DataOneof::kModelLoadFailure;
    set_fields_[64] = true;
    model_load_failure_ = std::move(model_load_failure);
    return *this;
  }
  /// Sets `model_load_failure` (no 59) and returns `*this`.
  LogData&& set_model_load_failure(logs::ModelLoadFailure&& model_load_failure) && noexcept {
    return std::move(set_model_load_failure(std::move(model_load_failure)));
  }

  // Field `model_execution_failure_error` (no 60).
  // -----

  /// No documentation.
  ///
  /// Field no: 60.
  constexpr const logs::ModelExecutionFailureError& model_execution_failure_error() const& noexcept HORUS_LIFETIME_BOUND {
    return model_execution_failure_error_;
  }

  /// If `model_execution_failure_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 60.
  logs::ModelExecutionFailureError model_execution_failure_error() && noexcept {
    if (!set_fields_[65]) {
      return {};
    }
    return std::move(model_execution_failure_error_);
  }

  /// No documentation.
  ///
  /// Field no: 60.
  logs::ModelExecutionFailureError& mutable_model_execution_failure_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelExecutionFailureError;
    set_fields_[65] = true;
    return model_execution_failure_error_;
  }

  /// Returns whether `model_execution_failure_error` (no 60) is set.
  constexpr bool has_model_execution_failure_error() const noexcept { return set_fields_[65]; }

  /// Clears `model_execution_failure_error` (no 60).
  void clear_model_execution_failure_error() & noexcept {
    data_ = {};
    set_fields_[65] = false;
    model_execution_failure_error_ = {};
  }

  /// Sets `model_execution_failure_error` (no 60) and returns `*this`.
  LogData& set_model_execution_failure_error(logs::ModelExecutionFailureError&& model_execution_failure_error) & noexcept {
    clear_data();
    data_ = DataOneof::kModelExecutionFailureError;
    set_fields_[65] = true;
    model_execution_failure_error_ = std::move(model_execution_failure_error);
    return *this;
  }
  /// Sets `model_execution_failure_error` (no 60) and returns `*this`.
  LogData&& set_model_execution_failure_error(logs::ModelExecutionFailureError&& model_execution_failure_error) && noexcept {
    return std::move(set_model_execution_failure_error(std::move(model_execution_failure_error)));
  }

  // Field `service_ready_info` (no 61).
  // -----

  /// No documentation.
  ///
  /// Field no: 61.
  constexpr const logs::ServiceReadyInfo& service_ready_info() const& noexcept HORUS_LIFETIME_BOUND {
    return service_ready_info_;
  }

  /// If `service_ready_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 61.
  logs::ServiceReadyInfo service_ready_info() && noexcept {
    if (!set_fields_[66]) {
      return {};
    }
    return std::move(service_ready_info_);
  }

  /// No documentation.
  ///
  /// Field no: 61.
  logs::ServiceReadyInfo& mutable_service_ready_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kServiceReadyInfo;
    set_fields_[66] = true;
    return service_ready_info_;
  }

  /// Returns whether `service_ready_info` (no 61) is set.
  constexpr bool has_service_ready_info() const noexcept { return set_fields_[66]; }

  /// Clears `service_ready_info` (no 61).
  void clear_service_ready_info() & noexcept {
    data_ = {};
    set_fields_[66] = false;
    service_ready_info_ = {};
  }

  /// Sets `service_ready_info` (no 61) and returns `*this`.
  LogData& set_service_ready_info(logs::ServiceReadyInfo&& service_ready_info) & noexcept {
    clear_data();
    data_ = DataOneof::kServiceReadyInfo;
    set_fields_[66] = true;
    service_ready_info_ = std::move(service_ready_info);
    return *this;
  }
  /// Sets `service_ready_info` (no 61) and returns `*this`.
  LogData&& set_service_ready_info(logs::ServiceReadyInfo&& service_ready_info) && noexcept {
    return std::move(set_service_ready_info(std::move(service_ready_info)));
  }

  // Field `model_preparing_info` (no 62).
  // -----

  /// No documentation.
  ///
  /// Field no: 62.
  constexpr const logs::ModelPreparingInfo& model_preparing_info() const& noexcept HORUS_LIFETIME_BOUND {
    return model_preparing_info_;
  }

  /// If `model_preparing_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 62.
  logs::ModelPreparingInfo model_preparing_info() && noexcept {
    if (!set_fields_[67]) {
      return {};
    }
    return std::move(model_preparing_info_);
  }

  /// No documentation.
  ///
  /// Field no: 62.
  logs::ModelPreparingInfo& mutable_model_preparing_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelPreparingInfo;
    set_fields_[67] = true;
    return model_preparing_info_;
  }

  /// Returns whether `model_preparing_info` (no 62) is set.
  constexpr bool has_model_preparing_info() const noexcept { return set_fields_[67]; }

  /// Clears `model_preparing_info` (no 62).
  void clear_model_preparing_info() & noexcept {
    data_ = {};
    set_fields_[67] = false;
    model_preparing_info_ = {};
  }

  /// Sets `model_preparing_info` (no 62) and returns `*this`.
  LogData& set_model_preparing_info(logs::ModelPreparingInfo&& model_preparing_info) & noexcept {
    clear_data();
    data_ = DataOneof::kModelPreparingInfo;
    set_fields_[67] = true;
    model_preparing_info_ = std::move(model_preparing_info);
    return *this;
  }
  /// Sets `model_preparing_info` (no 62) and returns `*this`.
  LogData&& set_model_preparing_info(logs::ModelPreparingInfo&& model_preparing_info) && noexcept {
    return std::move(set_model_preparing_info(std::move(model_preparing_info)));
  }

  // Field `model_initialized_info` (no 63).
  // -----

  /// No documentation.
  ///
  /// Field no: 63.
  constexpr const logs::ModelInitializedInfo& model_initialized_info() const& noexcept HORUS_LIFETIME_BOUND {
    return model_initialized_info_;
  }

  /// If `model_initialized_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 63.
  logs::ModelInitializedInfo model_initialized_info() && noexcept {
    if (!set_fields_[68]) {
      return {};
    }
    return std::move(model_initialized_info_);
  }

  /// No documentation.
  ///
  /// Field no: 63.
  logs::ModelInitializedInfo& mutable_model_initialized_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelInitializedInfo;
    set_fields_[68] = true;
    return model_initialized_info_;
  }

  /// Returns whether `model_initialized_info` (no 63) is set.
  constexpr bool has_model_initialized_info() const noexcept { return set_fields_[68]; }

  /// Clears `model_initialized_info` (no 63).
  void clear_model_initialized_info() & noexcept {
    data_ = {};
    set_fields_[68] = false;
    model_initialized_info_ = {};
  }

  /// Sets `model_initialized_info` (no 63) and returns `*this`.
  LogData& set_model_initialized_info(logs::ModelInitializedInfo&& model_initialized_info) & noexcept {
    clear_data();
    data_ = DataOneof::kModelInitializedInfo;
    set_fields_[68] = true;
    model_initialized_info_ = std::move(model_initialized_info);
    return *this;
  }
  /// Sets `model_initialized_info` (no 63) and returns `*this`.
  LogData&& set_model_initialized_info(logs::ModelInitializedInfo&& model_initialized_info) && noexcept {
    return std::move(set_model_initialized_info(std::move(model_initialized_info)));
  }

  // Field `model_initialization_failure_warning` (no 64).
  // -----

  /// No documentation.
  ///
  /// Field no: 64.
  constexpr const logs::ModelInitializationFailureWarning& model_initialization_failure_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return model_initialization_failure_warning_;
  }

  /// If `model_initialization_failure_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 64.
  logs::ModelInitializationFailureWarning model_initialization_failure_warning() && noexcept {
    if (!set_fields_[69]) {
      return {};
    }
    return std::move(model_initialization_failure_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 64.
  logs::ModelInitializationFailureWarning& mutable_model_initialization_failure_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelInitializationFailureWarning;
    set_fields_[69] = true;
    return model_initialization_failure_warning_;
  }

  /// Returns whether `model_initialization_failure_warning` (no 64) is set.
  constexpr bool has_model_initialization_failure_warning() const noexcept { return set_fields_[69]; }

  /// Clears `model_initialization_failure_warning` (no 64).
  void clear_model_initialization_failure_warning() & noexcept {
    data_ = {};
    set_fields_[69] = false;
    model_initialization_failure_warning_ = {};
  }

  /// Sets `model_initialization_failure_warning` (no 64) and returns `*this`.
  LogData& set_model_initialization_failure_warning(logs::ModelInitializationFailureWarning&& model_initialization_failure_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kModelInitializationFailureWarning;
    set_fields_[69] = true;
    model_initialization_failure_warning_ = std::move(model_initialization_failure_warning);
    return *this;
  }
  /// Sets `model_initialization_failure_warning` (no 64) and returns `*this`.
  LogData&& set_model_initialization_failure_warning(logs::ModelInitializationFailureWarning&& model_initialization_failure_warning) && noexcept {
    return std::move(set_model_initialization_failure_warning(std::move(model_initialization_failure_warning)));
  }

  // Field `ros_spinner_stopped_warning` (no 65).
  // -----

  /// No documentation.
  ///
  /// Field no: 65.
  constexpr const logs::RosSpinnerStoppedWarning& ros_spinner_stopped_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return ros_spinner_stopped_warning_;
  }

  /// If `ros_spinner_stopped_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 65.
  logs::RosSpinnerStoppedWarning ros_spinner_stopped_warning() && noexcept {
    if (!set_fields_[70]) {
      return {};
    }
    return std::move(ros_spinner_stopped_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 65.
  logs::RosSpinnerStoppedWarning& mutable_ros_spinner_stopped_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRosSpinnerStoppedWarning;
    set_fields_[70] = true;
    return ros_spinner_stopped_warning_;
  }

  /// Returns whether `ros_spinner_stopped_warning` (no 65) is set.
  constexpr bool has_ros_spinner_stopped_warning() const noexcept { return set_fields_[70]; }

  /// Clears `ros_spinner_stopped_warning` (no 65).
  void clear_ros_spinner_stopped_warning() & noexcept {
    data_ = {};
    set_fields_[70] = false;
    ros_spinner_stopped_warning_ = {};
  }

  /// Sets `ros_spinner_stopped_warning` (no 65) and returns `*this`.
  LogData& set_ros_spinner_stopped_warning(logs::RosSpinnerStoppedWarning&& ros_spinner_stopped_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRosSpinnerStoppedWarning;
    set_fields_[70] = true;
    ros_spinner_stopped_warning_ = std::move(ros_spinner_stopped_warning);
    return *this;
  }
  /// Sets `ros_spinner_stopped_warning` (no 65) and returns `*this`.
  LogData&& set_ros_spinner_stopped_warning(logs::RosSpinnerStoppedWarning&& ros_spinner_stopped_warning) && noexcept {
    return std::move(set_ros_spinner_stopped_warning(std::move(ros_spinner_stopped_warning)));
  }

  // Field `actor_system_unavailable_error` (no 66).
  // -----

  /// No documentation.
  ///
  /// Field no: 66.
  constexpr const logs::ActorSystemUnavailableError& actor_system_unavailable_error() const& noexcept HORUS_LIFETIME_BOUND {
    return actor_system_unavailable_error_;
  }

  /// If `actor_system_unavailable_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 66.
  logs::ActorSystemUnavailableError actor_system_unavailable_error() && noexcept {
    if (!set_fields_[71]) {
      return {};
    }
    return std::move(actor_system_unavailable_error_);
  }

  /// No documentation.
  ///
  /// Field no: 66.
  logs::ActorSystemUnavailableError& mutable_actor_system_unavailable_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kActorSystemUnavailableError;
    set_fields_[71] = true;
    return actor_system_unavailable_error_;
  }

  /// Returns whether `actor_system_unavailable_error` (no 66) is set.
  constexpr bool has_actor_system_unavailable_error() const noexcept { return set_fields_[71]; }

  /// Clears `actor_system_unavailable_error` (no 66).
  void clear_actor_system_unavailable_error() & noexcept {
    data_ = {};
    set_fields_[71] = false;
    actor_system_unavailable_error_ = {};
  }

  /// Sets `actor_system_unavailable_error` (no 66) and returns `*this`.
  LogData& set_actor_system_unavailable_error(logs::ActorSystemUnavailableError&& actor_system_unavailable_error) & noexcept {
    clear_data();
    data_ = DataOneof::kActorSystemUnavailableError;
    set_fields_[71] = true;
    actor_system_unavailable_error_ = std::move(actor_system_unavailable_error);
    return *this;
  }
  /// Sets `actor_system_unavailable_error` (no 66) and returns `*this`.
  LogData&& set_actor_system_unavailable_error(logs::ActorSystemUnavailableError&& actor_system_unavailable_error) && noexcept {
    return std::move(set_actor_system_unavailable_error(std::move(actor_system_unavailable_error)));
  }

  // Field `config_node_not_found_error` (no 67).
  // -----

  /// No documentation.
  ///
  /// Field no: 67.
  constexpr const logs::ConfigNodeNotFoundError& config_node_not_found_error() const& noexcept HORUS_LIFETIME_BOUND {
    return config_node_not_found_error_;
  }

  /// If `config_node_not_found_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 67.
  logs::ConfigNodeNotFoundError config_node_not_found_error() && noexcept {
    if (!set_fields_[72]) {
      return {};
    }
    return std::move(config_node_not_found_error_);
  }

  /// No documentation.
  ///
  /// Field no: 67.
  logs::ConfigNodeNotFoundError& mutable_config_node_not_found_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kConfigNodeNotFoundError;
    set_fields_[72] = true;
    return config_node_not_found_error_;
  }

  /// Returns whether `config_node_not_found_error` (no 67) is set.
  constexpr bool has_config_node_not_found_error() const noexcept { return set_fields_[72]; }

  /// Clears `config_node_not_found_error` (no 67).
  void clear_config_node_not_found_error() & noexcept {
    data_ = {};
    set_fields_[72] = false;
    config_node_not_found_error_ = {};
  }

  /// Sets `config_node_not_found_error` (no 67) and returns `*this`.
  LogData& set_config_node_not_found_error(logs::ConfigNodeNotFoundError&& config_node_not_found_error) & noexcept {
    clear_data();
    data_ = DataOneof::kConfigNodeNotFoundError;
    set_fields_[72] = true;
    config_node_not_found_error_ = std::move(config_node_not_found_error);
    return *this;
  }
  /// Sets `config_node_not_found_error` (no 67) and returns `*this`.
  LogData&& set_config_node_not_found_error(logs::ConfigNodeNotFoundError&& config_node_not_found_error) && noexcept {
    return std::move(set_config_node_not_found_error(std::move(config_node_not_found_error)));
  }

  // Field `bag_timestamp_out_of_order_error` (no 68).
  // -----

  /// No documentation.
  ///
  /// Field no: 68.
  constexpr const logs::BagTimestampOutOfOrderError& bag_timestamp_out_of_order_error() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_timestamp_out_of_order_error_;
  }

  /// If `bag_timestamp_out_of_order_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 68.
  logs::BagTimestampOutOfOrderError bag_timestamp_out_of_order_error() && noexcept {
    if (!set_fields_[73]) {
      return {};
    }
    return std::move(bag_timestamp_out_of_order_error_);
  }

  /// No documentation.
  ///
  /// Field no: 68.
  logs::BagTimestampOutOfOrderError& mutable_bag_timestamp_out_of_order_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagTimestampOutOfOrderError;
    set_fields_[73] = true;
    return bag_timestamp_out_of_order_error_;
  }

  /// Returns whether `bag_timestamp_out_of_order_error` (no 68) is set.
  constexpr bool has_bag_timestamp_out_of_order_error() const noexcept { return set_fields_[73]; }

  /// Clears `bag_timestamp_out_of_order_error` (no 68).
  void clear_bag_timestamp_out_of_order_error() & noexcept {
    data_ = {};
    set_fields_[73] = false;
    bag_timestamp_out_of_order_error_ = {};
  }

  /// Sets `bag_timestamp_out_of_order_error` (no 68) and returns `*this`.
  LogData& set_bag_timestamp_out_of_order_error(logs::BagTimestampOutOfOrderError&& bag_timestamp_out_of_order_error) & noexcept {
    clear_data();
    data_ = DataOneof::kBagTimestampOutOfOrderError;
    set_fields_[73] = true;
    bag_timestamp_out_of_order_error_ = std::move(bag_timestamp_out_of_order_error);
    return *this;
  }
  /// Sets `bag_timestamp_out_of_order_error` (no 68) and returns `*this`.
  LogData&& set_bag_timestamp_out_of_order_error(logs::BagTimestampOutOfOrderError&& bag_timestamp_out_of_order_error) && noexcept {
    return std::move(set_bag_timestamp_out_of_order_error(std::move(bag_timestamp_out_of_order_error)));
  }

  // Field `bag_replay_unexpected_timestamp_error` (no 69).
  // -----

  /// No documentation.
  ///
  /// Field no: 69.
  constexpr const logs::BagReplayUnexpectedTimestampError& bag_replay_unexpected_timestamp_error() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_replay_unexpected_timestamp_error_;
  }

  /// If `bag_replay_unexpected_timestamp_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 69.
  logs::BagReplayUnexpectedTimestampError bag_replay_unexpected_timestamp_error() && noexcept {
    if (!set_fields_[74]) {
      return {};
    }
    return std::move(bag_replay_unexpected_timestamp_error_);
  }

  /// No documentation.
  ///
  /// Field no: 69.
  logs::BagReplayUnexpectedTimestampError& mutable_bag_replay_unexpected_timestamp_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagReplayUnexpectedTimestampError;
    set_fields_[74] = true;
    return bag_replay_unexpected_timestamp_error_;
  }

  /// Returns whether `bag_replay_unexpected_timestamp_error` (no 69) is set.
  constexpr bool has_bag_replay_unexpected_timestamp_error() const noexcept { return set_fields_[74]; }

  /// Clears `bag_replay_unexpected_timestamp_error` (no 69).
  void clear_bag_replay_unexpected_timestamp_error() & noexcept {
    data_ = {};
    set_fields_[74] = false;
    bag_replay_unexpected_timestamp_error_ = {};
  }

  /// Sets `bag_replay_unexpected_timestamp_error` (no 69) and returns `*this`.
  LogData& set_bag_replay_unexpected_timestamp_error(logs::BagReplayUnexpectedTimestampError&& bag_replay_unexpected_timestamp_error) & noexcept {
    clear_data();
    data_ = DataOneof::kBagReplayUnexpectedTimestampError;
    set_fields_[74] = true;
    bag_replay_unexpected_timestamp_error_ = std::move(bag_replay_unexpected_timestamp_error);
    return *this;
  }
  /// Sets `bag_replay_unexpected_timestamp_error` (no 69) and returns `*this`.
  LogData&& set_bag_replay_unexpected_timestamp_error(logs::BagReplayUnexpectedTimestampError&& bag_replay_unexpected_timestamp_error) && noexcept {
    return std::move(set_bag_replay_unexpected_timestamp_error(std::move(bag_replay_unexpected_timestamp_error)));
  }

  // Field `websocket_closed_info` (no 70).
  // -----

  /// No documentation.
  ///
  /// Field no: 70.
  constexpr const logs::WebsocketClosedInfo& websocket_closed_info() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_closed_info_;
  }

  /// If `websocket_closed_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 70.
  logs::WebsocketClosedInfo websocket_closed_info() && noexcept {
    if (!set_fields_[75]) {
      return {};
    }
    return std::move(websocket_closed_info_);
  }

  /// No documentation.
  ///
  /// Field no: 70.
  logs::WebsocketClosedInfo& mutable_websocket_closed_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketClosedInfo;
    set_fields_[75] = true;
    return websocket_closed_info_;
  }

  /// Returns whether `websocket_closed_info` (no 70) is set.
  constexpr bool has_websocket_closed_info() const noexcept { return set_fields_[75]; }

  /// Clears `websocket_closed_info` (no 70).
  void clear_websocket_closed_info() & noexcept {
    data_ = {};
    set_fields_[75] = false;
    websocket_closed_info_ = {};
  }

  /// Sets `websocket_closed_info` (no 70) and returns `*this`.
  LogData& set_websocket_closed_info(logs::WebsocketClosedInfo&& websocket_closed_info) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketClosedInfo;
    set_fields_[75] = true;
    websocket_closed_info_ = std::move(websocket_closed_info);
    return *this;
  }
  /// Sets `websocket_closed_info` (no 70) and returns `*this`.
  LogData&& set_websocket_closed_info(logs::WebsocketClosedInfo&& websocket_closed_info) && noexcept {
    return std::move(set_websocket_closed_info(std::move(websocket_closed_info)));
  }

  // Field `websocket_opened_info` (no 71).
  // -----

  /// No documentation.
  ///
  /// Field no: 71.
  constexpr const logs::WebsocketOpenedInfo& websocket_opened_info() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_opened_info_;
  }

  /// If `websocket_opened_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 71.
  logs::WebsocketOpenedInfo websocket_opened_info() && noexcept {
    if (!set_fields_[76]) {
      return {};
    }
    return std::move(websocket_opened_info_);
  }

  /// No documentation.
  ///
  /// Field no: 71.
  logs::WebsocketOpenedInfo& mutable_websocket_opened_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketOpenedInfo;
    set_fields_[76] = true;
    return websocket_opened_info_;
  }

  /// Returns whether `websocket_opened_info` (no 71) is set.
  constexpr bool has_websocket_opened_info() const noexcept { return set_fields_[76]; }

  /// Clears `websocket_opened_info` (no 71).
  void clear_websocket_opened_info() & noexcept {
    data_ = {};
    set_fields_[76] = false;
    websocket_opened_info_ = {};
  }

  /// Sets `websocket_opened_info` (no 71) and returns `*this`.
  LogData& set_websocket_opened_info(logs::WebsocketOpenedInfo&& websocket_opened_info) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketOpenedInfo;
    set_fields_[76] = true;
    websocket_opened_info_ = std::move(websocket_opened_info);
    return *this;
  }
  /// Sets `websocket_opened_info` (no 71) and returns `*this`.
  LogData&& set_websocket_opened_info(logs::WebsocketOpenedInfo&& websocket_opened_info) && noexcept {
    return std::move(set_websocket_opened_info(std::move(websocket_opened_info)));
  }

  // Field `subscriber_disconnected_info` (no 72).
  // -----

  /// No documentation.
  ///
  /// Field no: 72.
  constexpr const logs::SubscriberDisconnectedInfo& subscriber_disconnected_info() const& noexcept HORUS_LIFETIME_BOUND {
    return subscriber_disconnected_info_;
  }

  /// If `subscriber_disconnected_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 72.
  logs::SubscriberDisconnectedInfo subscriber_disconnected_info() && noexcept {
    if (!set_fields_[77]) {
      return {};
    }
    return std::move(subscriber_disconnected_info_);
  }

  /// No documentation.
  ///
  /// Field no: 72.
  logs::SubscriberDisconnectedInfo& mutable_subscriber_disconnected_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kSubscriberDisconnectedInfo;
    set_fields_[77] = true;
    return subscriber_disconnected_info_;
  }

  /// Returns whether `subscriber_disconnected_info` (no 72) is set.
  constexpr bool has_subscriber_disconnected_info() const noexcept { return set_fields_[77]; }

  /// Clears `subscriber_disconnected_info` (no 72).
  void clear_subscriber_disconnected_info() & noexcept {
    data_ = {};
    set_fields_[77] = false;
    subscriber_disconnected_info_ = {};
  }

  /// Sets `subscriber_disconnected_info` (no 72) and returns `*this`.
  LogData& set_subscriber_disconnected_info(logs::SubscriberDisconnectedInfo&& subscriber_disconnected_info) & noexcept {
    clear_data();
    data_ = DataOneof::kSubscriberDisconnectedInfo;
    set_fields_[77] = true;
    subscriber_disconnected_info_ = std::move(subscriber_disconnected_info);
    return *this;
  }
  /// Sets `subscriber_disconnected_info` (no 72) and returns `*this`.
  LogData&& set_subscriber_disconnected_info(logs::SubscriberDisconnectedInfo&& subscriber_disconnected_info) && noexcept {
    return std::move(set_subscriber_disconnected_info(std::move(subscriber_disconnected_info)));
  }

  // Field `thread_pool_slowing_down_warning` (no 73).
  // -----

  /// No documentation.
  ///
  /// Field no: 73.
  constexpr const logs::ThreadPoolSlowingDownWarning& thread_pool_slowing_down_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return thread_pool_slowing_down_warning_;
  }

  /// If `thread_pool_slowing_down_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 73.
  logs::ThreadPoolSlowingDownWarning thread_pool_slowing_down_warning() && noexcept {
    if (!set_fields_[78]) {
      return {};
    }
    return std::move(thread_pool_slowing_down_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 73.
  logs::ThreadPoolSlowingDownWarning& mutable_thread_pool_slowing_down_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kThreadPoolSlowingDownWarning;
    set_fields_[78] = true;
    return thread_pool_slowing_down_warning_;
  }

  /// Returns whether `thread_pool_slowing_down_warning` (no 73) is set.
  constexpr bool has_thread_pool_slowing_down_warning() const noexcept { return set_fields_[78]; }

  /// Clears `thread_pool_slowing_down_warning` (no 73).
  void clear_thread_pool_slowing_down_warning() & noexcept {
    data_ = {};
    set_fields_[78] = false;
    thread_pool_slowing_down_warning_ = {};
  }

  /// Sets `thread_pool_slowing_down_warning` (no 73) and returns `*this`.
  LogData& set_thread_pool_slowing_down_warning(logs::ThreadPoolSlowingDownWarning&& thread_pool_slowing_down_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kThreadPoolSlowingDownWarning;
    set_fields_[78] = true;
    thread_pool_slowing_down_warning_ = std::move(thread_pool_slowing_down_warning);
    return *this;
  }
  /// Sets `thread_pool_slowing_down_warning` (no 73) and returns `*this`.
  LogData&& set_thread_pool_slowing_down_warning(logs::ThreadPoolSlowingDownWarning&& thread_pool_slowing_down_warning) && noexcept {
    return std::move(set_thread_pool_slowing_down_warning(std::move(thread_pool_slowing_down_warning)));
  }

  // Field `thread_pool_not_responding_warning` (no 74).
  // -----

  /// No documentation.
  ///
  /// Field no: 74.
  constexpr const logs::ThreadPoolNotRespondingWarning& thread_pool_not_responding_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return thread_pool_not_responding_warning_;
  }

  /// If `thread_pool_not_responding_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 74.
  logs::ThreadPoolNotRespondingWarning thread_pool_not_responding_warning() && noexcept {
    if (!set_fields_[79]) {
      return {};
    }
    return std::move(thread_pool_not_responding_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 74.
  logs::ThreadPoolNotRespondingWarning& mutable_thread_pool_not_responding_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kThreadPoolNotRespondingWarning;
    set_fields_[79] = true;
    return thread_pool_not_responding_warning_;
  }

  /// Returns whether `thread_pool_not_responding_warning` (no 74) is set.
  constexpr bool has_thread_pool_not_responding_warning() const noexcept { return set_fields_[79]; }

  /// Clears `thread_pool_not_responding_warning` (no 74).
  void clear_thread_pool_not_responding_warning() & noexcept {
    data_ = {};
    set_fields_[79] = false;
    thread_pool_not_responding_warning_ = {};
  }

  /// Sets `thread_pool_not_responding_warning` (no 74) and returns `*this`.
  LogData& set_thread_pool_not_responding_warning(logs::ThreadPoolNotRespondingWarning&& thread_pool_not_responding_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kThreadPoolNotRespondingWarning;
    set_fields_[79] = true;
    thread_pool_not_responding_warning_ = std::move(thread_pool_not_responding_warning);
    return *this;
  }
  /// Sets `thread_pool_not_responding_warning` (no 74) and returns `*this`.
  LogData&& set_thread_pool_not_responding_warning(logs::ThreadPoolNotRespondingWarning&& thread_pool_not_responding_warning) && noexcept {
    return std::move(set_thread_pool_not_responding_warning(std::move(thread_pool_not_responding_warning)));
  }

  // Field `thread_pool_broken_promise_warning` (no 75).
  // -----

  /// No documentation.
  ///
  /// Field no: 75.
  constexpr const logs::ThreadPoolBrokenPromiseWarning& thread_pool_broken_promise_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return thread_pool_broken_promise_warning_;
  }

  /// If `thread_pool_broken_promise_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 75.
  logs::ThreadPoolBrokenPromiseWarning thread_pool_broken_promise_warning() && noexcept {
    if (!set_fields_[80]) {
      return {};
    }
    return std::move(thread_pool_broken_promise_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 75.
  logs::ThreadPoolBrokenPromiseWarning& mutable_thread_pool_broken_promise_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kThreadPoolBrokenPromiseWarning;
    set_fields_[80] = true;
    return thread_pool_broken_promise_warning_;
  }

  /// Returns whether `thread_pool_broken_promise_warning` (no 75) is set.
  constexpr bool has_thread_pool_broken_promise_warning() const noexcept { return set_fields_[80]; }

  /// Clears `thread_pool_broken_promise_warning` (no 75).
  void clear_thread_pool_broken_promise_warning() & noexcept {
    data_ = {};
    set_fields_[80] = false;
    thread_pool_broken_promise_warning_ = {};
  }

  /// Sets `thread_pool_broken_promise_warning` (no 75) and returns `*this`.
  LogData& set_thread_pool_broken_promise_warning(logs::ThreadPoolBrokenPromiseWarning&& thread_pool_broken_promise_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kThreadPoolBrokenPromiseWarning;
    set_fields_[80] = true;
    thread_pool_broken_promise_warning_ = std::move(thread_pool_broken_promise_warning);
    return *this;
  }
  /// Sets `thread_pool_broken_promise_warning` (no 75) and returns `*this`.
  LogData&& set_thread_pool_broken_promise_warning(logs::ThreadPoolBrokenPromiseWarning&& thread_pool_broken_promise_warning) && noexcept {
    return std::move(set_thread_pool_broken_promise_warning(std::move(thread_pool_broken_promise_warning)));
  }

  // Field `box_fitting_points_below_base_warning` (no 76).
  // -----

  /// No documentation.
  ///
  /// Field no: 76.
  constexpr const logs::BoxFittingPointsBelowBaseWarning& box_fitting_points_below_base_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return box_fitting_points_below_base_warning_;
  }

  /// If `box_fitting_points_below_base_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 76.
  logs::BoxFittingPointsBelowBaseWarning box_fitting_points_below_base_warning() && noexcept {
    if (!set_fields_[81]) {
      return {};
    }
    return std::move(box_fitting_points_below_base_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 76.
  logs::BoxFittingPointsBelowBaseWarning& mutable_box_fitting_points_below_base_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBoxFittingPointsBelowBaseWarning;
    set_fields_[81] = true;
    return box_fitting_points_below_base_warning_;
  }

  /// Returns whether `box_fitting_points_below_base_warning` (no 76) is set.
  constexpr bool has_box_fitting_points_below_base_warning() const noexcept { return set_fields_[81]; }

  /// Clears `box_fitting_points_below_base_warning` (no 76).
  void clear_box_fitting_points_below_base_warning() & noexcept {
    data_ = {};
    set_fields_[81] = false;
    box_fitting_points_below_base_warning_ = {};
  }

  /// Sets `box_fitting_points_below_base_warning` (no 76) and returns `*this`.
  LogData& set_box_fitting_points_below_base_warning(logs::BoxFittingPointsBelowBaseWarning&& box_fitting_points_below_base_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kBoxFittingPointsBelowBaseWarning;
    set_fields_[81] = true;
    box_fitting_points_below_base_warning_ = std::move(box_fitting_points_below_base_warning);
    return *this;
  }
  /// Sets `box_fitting_points_below_base_warning` (no 76) and returns `*this`.
  LogData&& set_box_fitting_points_below_base_warning(logs::BoxFittingPointsBelowBaseWarning&& box_fitting_points_below_base_warning) && noexcept {
    return std::move(set_box_fitting_points_below_base_warning(std::move(box_fitting_points_below_base_warning)));
  }

  // Field `failed_to_remove_stale_points_warning` (no 77).
  // -----

  /// No documentation.
  ///
  /// Field no: 77.
  constexpr const logs::FailedToRemoveStalePointsWarning& failed_to_remove_stale_points_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_remove_stale_points_warning_;
  }

  /// If `failed_to_remove_stale_points_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 77.
  logs::FailedToRemoveStalePointsWarning failed_to_remove_stale_points_warning() && noexcept {
    if (!set_fields_[82]) {
      return {};
    }
    return std::move(failed_to_remove_stale_points_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 77.
  logs::FailedToRemoveStalePointsWarning& mutable_failed_to_remove_stale_points_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToRemoveStalePointsWarning;
    set_fields_[82] = true;
    return failed_to_remove_stale_points_warning_;
  }

  /// Returns whether `failed_to_remove_stale_points_warning` (no 77) is set.
  constexpr bool has_failed_to_remove_stale_points_warning() const noexcept { return set_fields_[82]; }

  /// Clears `failed_to_remove_stale_points_warning` (no 77).
  void clear_failed_to_remove_stale_points_warning() & noexcept {
    data_ = {};
    set_fields_[82] = false;
    failed_to_remove_stale_points_warning_ = {};
  }

  /// Sets `failed_to_remove_stale_points_warning` (no 77) and returns `*this`.
  LogData& set_failed_to_remove_stale_points_warning(logs::FailedToRemoveStalePointsWarning&& failed_to_remove_stale_points_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToRemoveStalePointsWarning;
    set_fields_[82] = true;
    failed_to_remove_stale_points_warning_ = std::move(failed_to_remove_stale_points_warning);
    return *this;
  }
  /// Sets `failed_to_remove_stale_points_warning` (no 77) and returns `*this`.
  LogData&& set_failed_to_remove_stale_points_warning(logs::FailedToRemoveStalePointsWarning&& failed_to_remove_stale_points_warning) && noexcept {
    return std::move(set_failed_to_remove_stale_points_warning(std::move(failed_to_remove_stale_points_warning)));
  }

  // Field `irregular_broadcasting_period_warning` (no 78).
  // -----

  /// No documentation.
  ///
  /// Field no: 78.
  constexpr const logs::IrregularBroadcastingPeriodWarning& irregular_broadcasting_period_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return irregular_broadcasting_period_warning_;
  }

  /// If `irregular_broadcasting_period_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 78.
  logs::IrregularBroadcastingPeriodWarning irregular_broadcasting_period_warning() && noexcept {
    if (!set_fields_[83]) {
      return {};
    }
    return std::move(irregular_broadcasting_period_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 78.
  logs::IrregularBroadcastingPeriodWarning& mutable_irregular_broadcasting_period_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kIrregularBroadcastingPeriodWarning;
    set_fields_[83] = true;
    return irregular_broadcasting_period_warning_;
  }

  /// Returns whether `irregular_broadcasting_period_warning` (no 78) is set.
  constexpr bool has_irregular_broadcasting_period_warning() const noexcept { return set_fields_[83]; }

  /// Clears `irregular_broadcasting_period_warning` (no 78).
  void clear_irregular_broadcasting_period_warning() & noexcept {
    data_ = {};
    set_fields_[83] = false;
    irregular_broadcasting_period_warning_ = {};
  }

  /// Sets `irregular_broadcasting_period_warning` (no 78) and returns `*this`.
  LogData& set_irregular_broadcasting_period_warning(logs::IrregularBroadcastingPeriodWarning&& irregular_broadcasting_period_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kIrregularBroadcastingPeriodWarning;
    set_fields_[83] = true;
    irregular_broadcasting_period_warning_ = std::move(irregular_broadcasting_period_warning);
    return *this;
  }
  /// Sets `irregular_broadcasting_period_warning` (no 78) and returns `*this`.
  LogData&& set_irregular_broadcasting_period_warning(logs::IrregularBroadcastingPeriodWarning&& irregular_broadcasting_period_warning) && noexcept {
    return std::move(set_irregular_broadcasting_period_warning(std::move(irregular_broadcasting_period_warning)));
  }

  // Field `clusterer_points_out_of_range_warning` (no 79).
  // -----

  /// No documentation.
  ///
  /// Field no: 79.
  constexpr const logs::ClustererPointsOutOfRangeWarning& clusterer_points_out_of_range_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return clusterer_points_out_of_range_warning_;
  }

  /// If `clusterer_points_out_of_range_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 79.
  logs::ClustererPointsOutOfRangeWarning clusterer_points_out_of_range_warning() && noexcept {
    if (!set_fields_[84]) {
      return {};
    }
    return std::move(clusterer_points_out_of_range_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 79.
  logs::ClustererPointsOutOfRangeWarning& mutable_clusterer_points_out_of_range_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kClustererPointsOutOfRangeWarning;
    set_fields_[84] = true;
    return clusterer_points_out_of_range_warning_;
  }

  /// Returns whether `clusterer_points_out_of_range_warning` (no 79) is set.
  constexpr bool has_clusterer_points_out_of_range_warning() const noexcept { return set_fields_[84]; }

  /// Clears `clusterer_points_out_of_range_warning` (no 79).
  void clear_clusterer_points_out_of_range_warning() & noexcept {
    data_ = {};
    set_fields_[84] = false;
    clusterer_points_out_of_range_warning_ = {};
  }

  /// Sets `clusterer_points_out_of_range_warning` (no 79) and returns `*this`.
  LogData& set_clusterer_points_out_of_range_warning(logs::ClustererPointsOutOfRangeWarning&& clusterer_points_out_of_range_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kClustererPointsOutOfRangeWarning;
    set_fields_[84] = true;
    clusterer_points_out_of_range_warning_ = std::move(clusterer_points_out_of_range_warning);
    return *this;
  }
  /// Sets `clusterer_points_out_of_range_warning` (no 79) and returns `*this`.
  LogData&& set_clusterer_points_out_of_range_warning(logs::ClustererPointsOutOfRangeWarning&& clusterer_points_out_of_range_warning) && noexcept {
    return std::move(set_clusterer_points_out_of_range_warning(std::move(clusterer_points_out_of_range_warning)));
  }

  // Field `internal_error` (no 80).
  // -----

  /// No documentation.
  ///
  /// Field no: 80.
  constexpr const logs::InternalError& internal_error() const& noexcept HORUS_LIFETIME_BOUND {
    return internal_error_;
  }

  /// If `internal_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 80.
  logs::InternalError internal_error() && noexcept {
    if (!set_fields_[85]) {
      return {};
    }
    return std::move(internal_error_);
  }

  /// No documentation.
  ///
  /// Field no: 80.
  logs::InternalError& mutable_internal_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInternalError;
    set_fields_[85] = true;
    return internal_error_;
  }

  /// Returns whether `internal_error` (no 80) is set.
  constexpr bool has_internal_error() const noexcept { return set_fields_[85]; }

  /// Clears `internal_error` (no 80).
  void clear_internal_error() & noexcept {
    data_ = {};
    set_fields_[85] = false;
    internal_error_ = {};
  }

  /// Sets `internal_error` (no 80) and returns `*this`.
  LogData& set_internal_error(logs::InternalError&& internal_error) & noexcept {
    clear_data();
    data_ = DataOneof::kInternalError;
    set_fields_[85] = true;
    internal_error_ = std::move(internal_error);
    return *this;
  }
  /// Sets `internal_error` (no 80) and returns `*this`.
  LogData&& set_internal_error(logs::InternalError&& internal_error) && noexcept {
    return std::move(set_internal_error(std::move(internal_error)));
  }

  // Field `internal_fatal` (no 81).
  // -----

  /// No documentation.
  ///
  /// Field no: 81.
  constexpr const logs::InternalFatal& internal_fatal() const& noexcept HORUS_LIFETIME_BOUND {
    return internal_fatal_;
  }

  /// If `internal_fatal` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 81.
  logs::InternalFatal internal_fatal() && noexcept {
    if (!set_fields_[86]) {
      return {};
    }
    return std::move(internal_fatal_);
  }

  /// No documentation.
  ///
  /// Field no: 81.
  logs::InternalFatal& mutable_internal_fatal() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInternalFatal;
    set_fields_[86] = true;
    return internal_fatal_;
  }

  /// Returns whether `internal_fatal` (no 81) is set.
  constexpr bool has_internal_fatal() const noexcept { return set_fields_[86]; }

  /// Clears `internal_fatal` (no 81).
  void clear_internal_fatal() & noexcept {
    data_ = {};
    set_fields_[86] = false;
    internal_fatal_ = {};
  }

  /// Sets `internal_fatal` (no 81) and returns `*this`.
  LogData& set_internal_fatal(logs::InternalFatal&& internal_fatal) & noexcept {
    clear_data();
    data_ = DataOneof::kInternalFatal;
    set_fields_[86] = true;
    internal_fatal_ = std::move(internal_fatal);
    return *this;
  }
  /// Sets `internal_fatal` (no 81) and returns `*this`.
  LogData&& set_internal_fatal(logs::InternalFatal&& internal_fatal) && noexcept {
    return std::move(set_internal_fatal(std::move(internal_fatal)));
  }

  // Field `service_starting_info` (no 82).
  // -----

  /// No documentation.
  ///
  /// Field no: 82.
  constexpr const logs::ServiceStartingInfo& service_starting_info() const& noexcept HORUS_LIFETIME_BOUND {
    return service_starting_info_;
  }

  /// If `service_starting_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 82.
  logs::ServiceStartingInfo service_starting_info() && noexcept {
    if (!set_fields_[87]) {
      return {};
    }
    return std::move(service_starting_info_);
  }

  /// No documentation.
  ///
  /// Field no: 82.
  logs::ServiceStartingInfo& mutable_service_starting_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kServiceStartingInfo;
    set_fields_[87] = true;
    return service_starting_info_;
  }

  /// Returns whether `service_starting_info` (no 82) is set.
  constexpr bool has_service_starting_info() const noexcept { return set_fields_[87]; }

  /// Clears `service_starting_info` (no 82).
  void clear_service_starting_info() & noexcept {
    data_ = {};
    set_fields_[87] = false;
    service_starting_info_ = {};
  }

  /// Sets `service_starting_info` (no 82) and returns `*this`.
  LogData& set_service_starting_info(logs::ServiceStartingInfo&& service_starting_info) & noexcept {
    clear_data();
    data_ = DataOneof::kServiceStartingInfo;
    set_fields_[87] = true;
    service_starting_info_ = std::move(service_starting_info);
    return *this;
  }
  /// Sets `service_starting_info` (no 82) and returns `*this`.
  LogData&& set_service_starting_info(logs::ServiceStartingInfo&& service_starting_info) && noexcept {
    return std::move(set_service_starting_info(std::move(service_starting_info)));
  }

  // Field `config_node_not_found_fatal` (no 83).
  // -----

  /// No documentation.
  ///
  /// Field no: 83.
  constexpr const logs::ConfigNodeNotFoundFatal& config_node_not_found_fatal() const& noexcept HORUS_LIFETIME_BOUND {
    return config_node_not_found_fatal_;
  }

  /// If `config_node_not_found_fatal` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 83.
  logs::ConfigNodeNotFoundFatal config_node_not_found_fatal() && noexcept {
    if (!set_fields_[88]) {
      return {};
    }
    return std::move(config_node_not_found_fatal_);
  }

  /// No documentation.
  ///
  /// Field no: 83.
  logs::ConfigNodeNotFoundFatal& mutable_config_node_not_found_fatal() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kConfigNodeNotFoundFatal;
    set_fields_[88] = true;
    return config_node_not_found_fatal_;
  }

  /// Returns whether `config_node_not_found_fatal` (no 83) is set.
  constexpr bool has_config_node_not_found_fatal() const noexcept { return set_fields_[88]; }

  /// Clears `config_node_not_found_fatal` (no 83).
  void clear_config_node_not_found_fatal() & noexcept {
    data_ = {};
    set_fields_[88] = false;
    config_node_not_found_fatal_ = {};
  }

  /// Sets `config_node_not_found_fatal` (no 83) and returns `*this`.
  LogData& set_config_node_not_found_fatal(logs::ConfigNodeNotFoundFatal&& config_node_not_found_fatal) & noexcept {
    clear_data();
    data_ = DataOneof::kConfigNodeNotFoundFatal;
    set_fields_[88] = true;
    config_node_not_found_fatal_ = std::move(config_node_not_found_fatal);
    return *this;
  }
  /// Sets `config_node_not_found_fatal` (no 83) and returns `*this`.
  LogData&& set_config_node_not_found_fatal(logs::ConfigNodeNotFoundFatal&& config_node_not_found_fatal) && noexcept {
    return std::move(set_config_node_not_found_fatal(std::move(config_node_not_found_fatal)));
  }

  // Field `service_setup_error` (no 84).
  // -----

  /// No documentation.
  ///
  /// Field no: 84.
  constexpr const logs::ServiceSetupError& service_setup_error() const& noexcept HORUS_LIFETIME_BOUND {
    return service_setup_error_;
  }

  /// If `service_setup_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 84.
  logs::ServiceSetupError service_setup_error() && noexcept {
    if (!set_fields_[89]) {
      return {};
    }
    return std::move(service_setup_error_);
  }

  /// No documentation.
  ///
  /// Field no: 84.
  logs::ServiceSetupError& mutable_service_setup_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kServiceSetupError;
    set_fields_[89] = true;
    return service_setup_error_;
  }

  /// Returns whether `service_setup_error` (no 84) is set.
  constexpr bool has_service_setup_error() const noexcept { return set_fields_[89]; }

  /// Clears `service_setup_error` (no 84).
  void clear_service_setup_error() & noexcept {
    data_ = {};
    set_fields_[89] = false;
    service_setup_error_ = {};
  }

  /// Sets `service_setup_error` (no 84) and returns `*this`.
  LogData& set_service_setup_error(logs::ServiceSetupError&& service_setup_error) & noexcept {
    clear_data();
    data_ = DataOneof::kServiceSetupError;
    set_fields_[89] = true;
    service_setup_error_ = std::move(service_setup_error);
    return *this;
  }
  /// Sets `service_setup_error` (no 84) and returns `*this`.
  LogData&& set_service_setup_error(logs::ServiceSetupError&& service_setup_error) && noexcept {
    return std::move(set_service_setup_error(std::move(service_setup_error)));
  }

  // Field `filesystem_error` (no 85).
  // -----

  /// No documentation.
  ///
  /// Field no: 85.
  constexpr const logs::FilesystemError& filesystem_error() const& noexcept HORUS_LIFETIME_BOUND {
    return filesystem_error_;
  }

  /// If `filesystem_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 85.
  logs::FilesystemError filesystem_error() && noexcept {
    if (!set_fields_[90]) {
      return {};
    }
    return std::move(filesystem_error_);
  }

  /// No documentation.
  ///
  /// Field no: 85.
  logs::FilesystemError& mutable_filesystem_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFilesystemError;
    set_fields_[90] = true;
    return filesystem_error_;
  }

  /// Returns whether `filesystem_error` (no 85) is set.
  constexpr bool has_filesystem_error() const noexcept { return set_fields_[90]; }

  /// Clears `filesystem_error` (no 85).
  void clear_filesystem_error() & noexcept {
    data_ = {};
    set_fields_[90] = false;
    filesystem_error_ = {};
  }

  /// Sets `filesystem_error` (no 85) and returns `*this`.
  LogData& set_filesystem_error(logs::FilesystemError&& filesystem_error) & noexcept {
    clear_data();
    data_ = DataOneof::kFilesystemError;
    set_fields_[90] = true;
    filesystem_error_ = std::move(filesystem_error);
    return *this;
  }
  /// Sets `filesystem_error` (no 85) and returns `*this`.
  LogData&& set_filesystem_error(logs::FilesystemError&& filesystem_error) && noexcept {
    return std::move(set_filesystem_error(std::move(filesystem_error)));
  }

  // Field `invalid_preset_warning` (no 86).
  // -----

  /// No documentation.
  ///
  /// Field no: 86.
  constexpr const logs::InvalidPresetWarning& invalid_preset_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_preset_warning_;
  }

  /// If `invalid_preset_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 86.
  logs::InvalidPresetWarning invalid_preset_warning() && noexcept {
    if (!set_fields_[91]) {
      return {};
    }
    return std::move(invalid_preset_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 86.
  logs::InvalidPresetWarning& mutable_invalid_preset_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidPresetWarning;
    set_fields_[91] = true;
    return invalid_preset_warning_;
  }

  /// Returns whether `invalid_preset_warning` (no 86) is set.
  constexpr bool has_invalid_preset_warning() const noexcept { return set_fields_[91]; }

  /// Clears `invalid_preset_warning` (no 86).
  void clear_invalid_preset_warning() & noexcept {
    data_ = {};
    set_fields_[91] = false;
    invalid_preset_warning_ = {};
  }

  /// Sets `invalid_preset_warning` (no 86) and returns `*this`.
  LogData& set_invalid_preset_warning(logs::InvalidPresetWarning&& invalid_preset_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidPresetWarning;
    set_fields_[91] = true;
    invalid_preset_warning_ = std::move(invalid_preset_warning);
    return *this;
  }
  /// Sets `invalid_preset_warning` (no 86) and returns `*this`.
  LogData&& set_invalid_preset_warning(logs::InvalidPresetWarning&& invalid_preset_warning) && noexcept {
    return std::move(set_invalid_preset_warning(std::move(invalid_preset_warning)));
  }

  // Field `websocket_failed_clear_pending_error` (no 87).
  // -----

  /// No documentation.
  ///
  /// Field no: 87.
  constexpr const logs::WebsocketFailedClearPendingError& websocket_failed_clear_pending_error() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_failed_clear_pending_error_;
  }

  /// If `websocket_failed_clear_pending_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 87.
  logs::WebsocketFailedClearPendingError websocket_failed_clear_pending_error() && noexcept {
    if (!set_fields_[92]) {
      return {};
    }
    return std::move(websocket_failed_clear_pending_error_);
  }

  /// No documentation.
  ///
  /// Field no: 87.
  logs::WebsocketFailedClearPendingError& mutable_websocket_failed_clear_pending_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketFailedClearPendingError;
    set_fields_[92] = true;
    return websocket_failed_clear_pending_error_;
  }

  /// Returns whether `websocket_failed_clear_pending_error` (no 87) is set.
  constexpr bool has_websocket_failed_clear_pending_error() const noexcept { return set_fields_[92]; }

  /// Clears `websocket_failed_clear_pending_error` (no 87).
  void clear_websocket_failed_clear_pending_error() & noexcept {
    data_ = {};
    set_fields_[92] = false;
    websocket_failed_clear_pending_error_ = {};
  }

  /// Sets `websocket_failed_clear_pending_error` (no 87) and returns `*this`.
  LogData& set_websocket_failed_clear_pending_error(logs::WebsocketFailedClearPendingError&& websocket_failed_clear_pending_error) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketFailedClearPendingError;
    set_fields_[92] = true;
    websocket_failed_clear_pending_error_ = std::move(websocket_failed_clear_pending_error);
    return *this;
  }
  /// Sets `websocket_failed_clear_pending_error` (no 87) and returns `*this`.
  LogData&& set_websocket_failed_clear_pending_error(logs::WebsocketFailedClearPendingError&& websocket_failed_clear_pending_error) && noexcept {
    return std::move(set_websocket_failed_clear_pending_error(std::move(websocket_failed_clear_pending_error)));
  }

  // Field `websocket_failed_to_stop_error` (no 88).
  // -----

  /// No documentation.
  ///
  /// Field no: 88.
  constexpr const logs::WebsocketFailedToStopError& websocket_failed_to_stop_error() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_failed_to_stop_error_;
  }

  /// If `websocket_failed_to_stop_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 88.
  logs::WebsocketFailedToStopError websocket_failed_to_stop_error() && noexcept {
    if (!set_fields_[93]) {
      return {};
    }
    return std::move(websocket_failed_to_stop_error_);
  }

  /// No documentation.
  ///
  /// Field no: 88.
  logs::WebsocketFailedToStopError& mutable_websocket_failed_to_stop_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketFailedToStopError;
    set_fields_[93] = true;
    return websocket_failed_to_stop_error_;
  }

  /// Returns whether `websocket_failed_to_stop_error` (no 88) is set.
  constexpr bool has_websocket_failed_to_stop_error() const noexcept { return set_fields_[93]; }

  /// Clears `websocket_failed_to_stop_error` (no 88).
  void clear_websocket_failed_to_stop_error() & noexcept {
    data_ = {};
    set_fields_[93] = false;
    websocket_failed_to_stop_error_ = {};
  }

  /// Sets `websocket_failed_to_stop_error` (no 88) and returns `*this`.
  LogData& set_websocket_failed_to_stop_error(logs::WebsocketFailedToStopError&& websocket_failed_to_stop_error) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketFailedToStopError;
    set_fields_[93] = true;
    websocket_failed_to_stop_error_ = std::move(websocket_failed_to_stop_error);
    return *this;
  }
  /// Sets `websocket_failed_to_stop_error` (no 88) and returns `*this`.
  LogData&& set_websocket_failed_to_stop_error(logs::WebsocketFailedToStopError&& websocket_failed_to_stop_error) && noexcept {
    return std::move(set_websocket_failed_to_stop_error(std::move(websocket_failed_to_stop_error)));
  }

  // Field `websocket_failed_to_create_error` (no 89).
  // -----

  /// No documentation.
  ///
  /// Field no: 89.
  constexpr const logs::WebsocketFailedToCreateError& websocket_failed_to_create_error() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_failed_to_create_error_;
  }

  /// If `websocket_failed_to_create_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 89.
  logs::WebsocketFailedToCreateError websocket_failed_to_create_error() && noexcept {
    if (!set_fields_[94]) {
      return {};
    }
    return std::move(websocket_failed_to_create_error_);
  }

  /// No documentation.
  ///
  /// Field no: 89.
  logs::WebsocketFailedToCreateError& mutable_websocket_failed_to_create_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketFailedToCreateError;
    set_fields_[94] = true;
    return websocket_failed_to_create_error_;
  }

  /// Returns whether `websocket_failed_to_create_error` (no 89) is set.
  constexpr bool has_websocket_failed_to_create_error() const noexcept { return set_fields_[94]; }

  /// Clears `websocket_failed_to_create_error` (no 89).
  void clear_websocket_failed_to_create_error() & noexcept {
    data_ = {};
    set_fields_[94] = false;
    websocket_failed_to_create_error_ = {};
  }

  /// Sets `websocket_failed_to_create_error` (no 89) and returns `*this`.
  LogData& set_websocket_failed_to_create_error(logs::WebsocketFailedToCreateError&& websocket_failed_to_create_error) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketFailedToCreateError;
    set_fields_[94] = true;
    websocket_failed_to_create_error_ = std::move(websocket_failed_to_create_error);
    return *this;
  }
  /// Sets `websocket_failed_to_create_error` (no 89) and returns `*this`.
  LogData&& set_websocket_failed_to_create_error(logs::WebsocketFailedToCreateError&& websocket_failed_to_create_error) && noexcept {
    return std::move(set_websocket_failed_to_create_error(std::move(websocket_failed_to_create_error)));
  }

  // Field `unexpected_rpc_error` (no 90).
  // -----

  /// No documentation.
  ///
  /// Field no: 90.
  constexpr const logs::UnexpectedRpcError& unexpected_rpc_error() const& noexcept HORUS_LIFETIME_BOUND {
    return unexpected_rpc_error_;
  }

  /// If `unexpected_rpc_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 90.
  logs::UnexpectedRpcError unexpected_rpc_error() && noexcept {
    if (!set_fields_[95]) {
      return {};
    }
    return std::move(unexpected_rpc_error_);
  }

  /// No documentation.
  ///
  /// Field no: 90.
  logs::UnexpectedRpcError& mutable_unexpected_rpc_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kUnexpectedRpcError;
    set_fields_[95] = true;
    return unexpected_rpc_error_;
  }

  /// Returns whether `unexpected_rpc_error` (no 90) is set.
  constexpr bool has_unexpected_rpc_error() const noexcept { return set_fields_[95]; }

  /// Clears `unexpected_rpc_error` (no 90).
  void clear_unexpected_rpc_error() & noexcept {
    data_ = {};
    set_fields_[95] = false;
    unexpected_rpc_error_ = {};
  }

  /// Sets `unexpected_rpc_error` (no 90) and returns `*this`.
  LogData& set_unexpected_rpc_error(logs::UnexpectedRpcError&& unexpected_rpc_error) & noexcept {
    clear_data();
    data_ = DataOneof::kUnexpectedRpcError;
    set_fields_[95] = true;
    unexpected_rpc_error_ = std::move(unexpected_rpc_error);
    return *this;
  }
  /// Sets `unexpected_rpc_error` (no 90) and returns `*this`.
  LogData&& set_unexpected_rpc_error(logs::UnexpectedRpcError&& unexpected_rpc_error) && noexcept {
    return std::move(set_unexpected_rpc_error(std::move(unexpected_rpc_error)));
  }

  // Field `license_poll_failed` (no 91).
  // -----

  /// No documentation.
  ///
  /// Field no: 91.
  constexpr const logs::LicensePollFailed& license_poll_failed() const& noexcept HORUS_LIFETIME_BOUND {
    return license_poll_failed_;
  }

  /// If `license_poll_failed` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 91.
  logs::LicensePollFailed license_poll_failed() && noexcept {
    if (!set_fields_[96]) {
      return {};
    }
    return std::move(license_poll_failed_);
  }

  /// No documentation.
  ///
  /// Field no: 91.
  logs::LicensePollFailed& mutable_license_poll_failed() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicensePollFailed;
    set_fields_[96] = true;
    return license_poll_failed_;
  }

  /// Returns whether `license_poll_failed` (no 91) is set.
  constexpr bool has_license_poll_failed() const noexcept { return set_fields_[96]; }

  /// Clears `license_poll_failed` (no 91).
  void clear_license_poll_failed() & noexcept {
    data_ = {};
    set_fields_[96] = false;
    license_poll_failed_ = {};
  }

  /// Sets `license_poll_failed` (no 91) and returns `*this`.
  LogData& set_license_poll_failed(logs::LicensePollFailed&& license_poll_failed) & noexcept {
    clear_data();
    data_ = DataOneof::kLicensePollFailed;
    set_fields_[96] = true;
    license_poll_failed_ = std::move(license_poll_failed);
    return *this;
  }
  /// Sets `license_poll_failed` (no 91) and returns `*this`.
  LogData&& set_license_poll_failed(logs::LicensePollFailed&& license_poll_failed) && noexcept {
    return std::move(set_license_poll_failed(std::move(license_poll_failed)));
  }

  // Field `license_expired_warning` (no 92).
  // -----

  /// No documentation.
  ///
  /// Field no: 92.
  constexpr const logs::LicenseExpiredWarning& license_expired_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return license_expired_warning_;
  }

  /// If `license_expired_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 92.
  logs::LicenseExpiredWarning license_expired_warning() && noexcept {
    if (!set_fields_[97]) {
      return {};
    }
    return std::move(license_expired_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 92.
  logs::LicenseExpiredWarning& mutable_license_expired_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseExpiredWarning;
    set_fields_[97] = true;
    return license_expired_warning_;
  }

  /// Returns whether `license_expired_warning` (no 92) is set.
  constexpr bool has_license_expired_warning() const noexcept { return set_fields_[97]; }

  /// Clears `license_expired_warning` (no 92).
  void clear_license_expired_warning() & noexcept {
    data_ = {};
    set_fields_[97] = false;
    license_expired_warning_ = {};
  }

  /// Sets `license_expired_warning` (no 92) and returns `*this`.
  LogData& set_license_expired_warning(logs::LicenseExpiredWarning&& license_expired_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseExpiredWarning;
    set_fields_[97] = true;
    license_expired_warning_ = std::move(license_expired_warning);
    return *this;
  }
  /// Sets `license_expired_warning` (no 92) and returns `*this`.
  LogData&& set_license_expired_warning(logs::LicenseExpiredWarning&& license_expired_warning) && noexcept {
    return std::move(set_license_expired_warning(std::move(license_expired_warning)));
  }

  // Field `license_usage_exceeded_warning` (no 93).
  // -----

  /// No documentation.
  ///
  /// Field no: 93.
  constexpr const logs::LicenseUsageExceededWarning& license_usage_exceeded_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return license_usage_exceeded_warning_;
  }

  /// If `license_usage_exceeded_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 93.
  logs::LicenseUsageExceededWarning license_usage_exceeded_warning() && noexcept {
    if (!set_fields_[98]) {
      return {};
    }
    return std::move(license_usage_exceeded_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 93.
  logs::LicenseUsageExceededWarning& mutable_license_usage_exceeded_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseUsageExceededWarning;
    set_fields_[98] = true;
    return license_usage_exceeded_warning_;
  }

  /// Returns whether `license_usage_exceeded_warning` (no 93) is set.
  constexpr bool has_license_usage_exceeded_warning() const noexcept { return set_fields_[98]; }

  /// Clears `license_usage_exceeded_warning` (no 93).
  void clear_license_usage_exceeded_warning() & noexcept {
    data_ = {};
    set_fields_[98] = false;
    license_usage_exceeded_warning_ = {};
  }

  /// Sets `license_usage_exceeded_warning` (no 93) and returns `*this`.
  LogData& set_license_usage_exceeded_warning(logs::LicenseUsageExceededWarning&& license_usage_exceeded_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseUsageExceededWarning;
    set_fields_[98] = true;
    license_usage_exceeded_warning_ = std::move(license_usage_exceeded_warning);
    return *this;
  }
  /// Sets `license_usage_exceeded_warning` (no 93) and returns `*this`.
  LogData&& set_license_usage_exceeded_warning(logs::LicenseUsageExceededWarning&& license_usage_exceeded_warning) && noexcept {
    return std::move(set_license_usage_exceeded_warning(std::move(license_usage_exceeded_warning)));
  }

  // Field `static_thread_pool_slow_task_warning` (no 94).
  // -----

  /// No documentation.
  ///
  /// Field no: 94.
  constexpr const logs::StaticThreadPoolSlowTaskWarning& static_thread_pool_slow_task_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return static_thread_pool_slow_task_warning_;
  }

  /// If `static_thread_pool_slow_task_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 94.
  logs::StaticThreadPoolSlowTaskWarning static_thread_pool_slow_task_warning() && noexcept {
    if (!set_fields_[99]) {
      return {};
    }
    return std::move(static_thread_pool_slow_task_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 94.
  logs::StaticThreadPoolSlowTaskWarning& mutable_static_thread_pool_slow_task_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kStaticThreadPoolSlowTaskWarning;
    set_fields_[99] = true;
    return static_thread_pool_slow_task_warning_;
  }

  /// Returns whether `static_thread_pool_slow_task_warning` (no 94) is set.
  constexpr bool has_static_thread_pool_slow_task_warning() const noexcept { return set_fields_[99]; }

  /// Clears `static_thread_pool_slow_task_warning` (no 94).
  void clear_static_thread_pool_slow_task_warning() & noexcept {
    data_ = {};
    set_fields_[99] = false;
    static_thread_pool_slow_task_warning_ = {};
  }

  /// Sets `static_thread_pool_slow_task_warning` (no 94) and returns `*this`.
  LogData& set_static_thread_pool_slow_task_warning(logs::StaticThreadPoolSlowTaskWarning&& static_thread_pool_slow_task_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kStaticThreadPoolSlowTaskWarning;
    set_fields_[99] = true;
    static_thread_pool_slow_task_warning_ = std::move(static_thread_pool_slow_task_warning);
    return *this;
  }
  /// Sets `static_thread_pool_slow_task_warning` (no 94) and returns `*this`.
  LogData&& set_static_thread_pool_slow_task_warning(logs::StaticThreadPoolSlowTaskWarning&& static_thread_pool_slow_task_warning) && noexcept {
    return std::move(set_static_thread_pool_slow_task_warning(std::move(static_thread_pool_slow_task_warning)));
  }

  // Field `rpc_unsupported_service_warning` (no 95).
  // -----

  /// No documentation.
  ///
  /// Field no: 95.
  constexpr const logs::RpcUnsupportedServiceWarning& rpc_unsupported_service_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_unsupported_service_warning_;
  }

  /// If `rpc_unsupported_service_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 95.
  logs::RpcUnsupportedServiceWarning rpc_unsupported_service_warning() && noexcept {
    if (!set_fields_[100]) {
      return {};
    }
    return std::move(rpc_unsupported_service_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 95.
  logs::RpcUnsupportedServiceWarning& mutable_rpc_unsupported_service_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcUnsupportedServiceWarning;
    set_fields_[100] = true;
    return rpc_unsupported_service_warning_;
  }

  /// Returns whether `rpc_unsupported_service_warning` (no 95) is set.
  constexpr bool has_rpc_unsupported_service_warning() const noexcept { return set_fields_[100]; }

  /// Clears `rpc_unsupported_service_warning` (no 95).
  void clear_rpc_unsupported_service_warning() & noexcept {
    data_ = {};
    set_fields_[100] = false;
    rpc_unsupported_service_warning_ = {};
  }

  /// Sets `rpc_unsupported_service_warning` (no 95) and returns `*this`.
  LogData& set_rpc_unsupported_service_warning(logs::RpcUnsupportedServiceWarning&& rpc_unsupported_service_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcUnsupportedServiceWarning;
    set_fields_[100] = true;
    rpc_unsupported_service_warning_ = std::move(rpc_unsupported_service_warning);
    return *this;
  }
  /// Sets `rpc_unsupported_service_warning` (no 95) and returns `*this`.
  LogData&& set_rpc_unsupported_service_warning(logs::RpcUnsupportedServiceWarning&& rpc_unsupported_service_warning) && noexcept {
    return std::move(set_rpc_unsupported_service_warning(std::move(rpc_unsupported_service_warning)));
  }

  // Field `websocket_handler_problem` (no 96).
  // -----

  /// No documentation.
  ///
  /// Field no: 96.
  constexpr const logs::WebsocketHandlerProblem& websocket_handler_problem() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_handler_problem_;
  }

  /// If `websocket_handler_problem` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 96.
  logs::WebsocketHandlerProblem websocket_handler_problem() && noexcept {
    if (!set_fields_[101]) {
      return {};
    }
    return std::move(websocket_handler_problem_);
  }

  /// No documentation.
  ///
  /// Field no: 96.
  logs::WebsocketHandlerProblem& mutable_websocket_handler_problem() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketHandlerProblem;
    set_fields_[101] = true;
    return websocket_handler_problem_;
  }

  /// Returns whether `websocket_handler_problem` (no 96) is set.
  constexpr bool has_websocket_handler_problem() const noexcept { return set_fields_[101]; }

  /// Clears `websocket_handler_problem` (no 96).
  void clear_websocket_handler_problem() & noexcept {
    data_ = {};
    set_fields_[101] = false;
    websocket_handler_problem_ = {};
  }

  /// Sets `websocket_handler_problem` (no 96) and returns `*this`.
  LogData& set_websocket_handler_problem(logs::WebsocketHandlerProblem&& websocket_handler_problem) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketHandlerProblem;
    set_fields_[101] = true;
    websocket_handler_problem_ = std::move(websocket_handler_problem);
    return *this;
  }
  /// Sets `websocket_handler_problem` (no 96) and returns `*this`.
  LogData&& set_websocket_handler_problem(logs::WebsocketHandlerProblem&& websocket_handler_problem) && noexcept {
    return std::move(set_websocket_handler_problem(std::move(websocket_handler_problem)));
  }

  // Field `websocket_deserialize_error` (no 97).
  // -----

  /// No documentation.
  ///
  /// Field no: 97.
  constexpr const logs::WebsocketDeserializeError& websocket_deserialize_error() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_deserialize_error_;
  }

  /// If `websocket_deserialize_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 97.
  logs::WebsocketDeserializeError websocket_deserialize_error() && noexcept {
    if (!set_fields_[102]) {
      return {};
    }
    return std::move(websocket_deserialize_error_);
  }

  /// No documentation.
  ///
  /// Field no: 97.
  logs::WebsocketDeserializeError& mutable_websocket_deserialize_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketDeserializeError;
    set_fields_[102] = true;
    return websocket_deserialize_error_;
  }

  /// Returns whether `websocket_deserialize_error` (no 97) is set.
  constexpr bool has_websocket_deserialize_error() const noexcept { return set_fields_[102]; }

  /// Clears `websocket_deserialize_error` (no 97).
  void clear_websocket_deserialize_error() & noexcept {
    data_ = {};
    set_fields_[102] = false;
    websocket_deserialize_error_ = {};
  }

  /// Sets `websocket_deserialize_error` (no 97) and returns `*this`.
  LogData& set_websocket_deserialize_error(logs::WebsocketDeserializeError&& websocket_deserialize_error) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketDeserializeError;
    set_fields_[102] = true;
    websocket_deserialize_error_ = std::move(websocket_deserialize_error);
    return *this;
  }
  /// Sets `websocket_deserialize_error` (no 97) and returns `*this`.
  LogData&& set_websocket_deserialize_error(logs::WebsocketDeserializeError&& websocket_deserialize_error) && noexcept {
    return std::move(set_websocket_deserialize_error(std::move(websocket_deserialize_error)));
  }

  // Field `websocket_expired_rpc_endpoint_error` (no 98).
  // -----

  /// No documentation.
  ///
  /// Field no: 98.
  constexpr const logs::WebsocketExpiredRpcEndpointError& websocket_expired_rpc_endpoint_error() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_expired_rpc_endpoint_error_;
  }

  /// If `websocket_expired_rpc_endpoint_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 98.
  logs::WebsocketExpiredRpcEndpointError websocket_expired_rpc_endpoint_error() && noexcept {
    if (!set_fields_[103]) {
      return {};
    }
    return std::move(websocket_expired_rpc_endpoint_error_);
  }

  /// No documentation.
  ///
  /// Field no: 98.
  logs::WebsocketExpiredRpcEndpointError& mutable_websocket_expired_rpc_endpoint_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketExpiredRpcEndpointError;
    set_fields_[103] = true;
    return websocket_expired_rpc_endpoint_error_;
  }

  /// Returns whether `websocket_expired_rpc_endpoint_error` (no 98) is set.
  constexpr bool has_websocket_expired_rpc_endpoint_error() const noexcept { return set_fields_[103]; }

  /// Clears `websocket_expired_rpc_endpoint_error` (no 98).
  void clear_websocket_expired_rpc_endpoint_error() & noexcept {
    data_ = {};
    set_fields_[103] = false;
    websocket_expired_rpc_endpoint_error_ = {};
  }

  /// Sets `websocket_expired_rpc_endpoint_error` (no 98) and returns `*this`.
  LogData& set_websocket_expired_rpc_endpoint_error(logs::WebsocketExpiredRpcEndpointError&& websocket_expired_rpc_endpoint_error) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketExpiredRpcEndpointError;
    set_fields_[103] = true;
    websocket_expired_rpc_endpoint_error_ = std::move(websocket_expired_rpc_endpoint_error);
    return *this;
  }
  /// Sets `websocket_expired_rpc_endpoint_error` (no 98) and returns `*this`.
  LogData&& set_websocket_expired_rpc_endpoint_error(logs::WebsocketExpiredRpcEndpointError&& websocket_expired_rpc_endpoint_error) && noexcept {
    return std::move(set_websocket_expired_rpc_endpoint_error(std::move(websocket_expired_rpc_endpoint_error)));
  }

  // Field `websocket_queue_overloaded_warning` (no 99).
  // -----

  /// No documentation.
  ///
  /// Field no: 99.
  constexpr const logs::WebsocketQueueOverloadedWarning& websocket_queue_overloaded_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return websocket_queue_overloaded_warning_;
  }

  /// If `websocket_queue_overloaded_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 99.
  logs::WebsocketQueueOverloadedWarning websocket_queue_overloaded_warning() && noexcept {
    if (!set_fields_[104]) {
      return {};
    }
    return std::move(websocket_queue_overloaded_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 99.
  logs::WebsocketQueueOverloadedWarning& mutable_websocket_queue_overloaded_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kWebsocketQueueOverloadedWarning;
    set_fields_[104] = true;
    return websocket_queue_overloaded_warning_;
  }

  /// Returns whether `websocket_queue_overloaded_warning` (no 99) is set.
  constexpr bool has_websocket_queue_overloaded_warning() const noexcept { return set_fields_[104]; }

  /// Clears `websocket_queue_overloaded_warning` (no 99).
  void clear_websocket_queue_overloaded_warning() & noexcept {
    data_ = {};
    set_fields_[104] = false;
    websocket_queue_overloaded_warning_ = {};
  }

  /// Sets `websocket_queue_overloaded_warning` (no 99) and returns `*this`.
  LogData& set_websocket_queue_overloaded_warning(logs::WebsocketQueueOverloadedWarning&& websocket_queue_overloaded_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kWebsocketQueueOverloadedWarning;
    set_fields_[104] = true;
    websocket_queue_overloaded_warning_ = std::move(websocket_queue_overloaded_warning);
    return *this;
  }
  /// Sets `websocket_queue_overloaded_warning` (no 99) and returns `*this`.
  LogData&& set_websocket_queue_overloaded_warning(logs::WebsocketQueueOverloadedWarning&& websocket_queue_overloaded_warning) && noexcept {
    return std::move(set_websocket_queue_overloaded_warning(std::move(websocket_queue_overloaded_warning)));
  }

  // Field `rpc_failed_to_notify_warning` (no 100).
  // -----

  /// No documentation.
  ///
  /// Field no: 100.
  constexpr const logs::RpcFailedToNotifyWarning& rpc_failed_to_notify_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_failed_to_notify_warning_;
  }

  /// If `rpc_failed_to_notify_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 100.
  logs::RpcFailedToNotifyWarning rpc_failed_to_notify_warning() && noexcept {
    if (!set_fields_[105]) {
      return {};
    }
    return std::move(rpc_failed_to_notify_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 100.
  logs::RpcFailedToNotifyWarning& mutable_rpc_failed_to_notify_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcFailedToNotifyWarning;
    set_fields_[105] = true;
    return rpc_failed_to_notify_warning_;
  }

  /// Returns whether `rpc_failed_to_notify_warning` (no 100) is set.
  constexpr bool has_rpc_failed_to_notify_warning() const noexcept { return set_fields_[105]; }

  /// Clears `rpc_failed_to_notify_warning` (no 100).
  void clear_rpc_failed_to_notify_warning() & noexcept {
    data_ = {};
    set_fields_[105] = false;
    rpc_failed_to_notify_warning_ = {};
  }

  /// Sets `rpc_failed_to_notify_warning` (no 100) and returns `*this`.
  LogData& set_rpc_failed_to_notify_warning(logs::RpcFailedToNotifyWarning&& rpc_failed_to_notify_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcFailedToNotifyWarning;
    set_fields_[105] = true;
    rpc_failed_to_notify_warning_ = std::move(rpc_failed_to_notify_warning);
    return *this;
  }
  /// Sets `rpc_failed_to_notify_warning` (no 100) and returns `*this`.
  LogData&& set_rpc_failed_to_notify_warning(logs::RpcFailedToNotifyWarning&& rpc_failed_to_notify_warning) && noexcept {
    return std::move(set_rpc_failed_to_notify_warning(std::move(rpc_failed_to_notify_warning)));
  }

  // Field `config_subscription_failed_warning` (no 101).
  // -----

  /// No documentation.
  ///
  /// Field no: 101.
  constexpr const logs::ConfigSubscriptionFailedWarning& config_subscription_failed_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return config_subscription_failed_warning_;
  }

  /// If `config_subscription_failed_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 101.
  logs::ConfigSubscriptionFailedWarning config_subscription_failed_warning() && noexcept {
    if (!set_fields_[106]) {
      return {};
    }
    return std::move(config_subscription_failed_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 101.
  logs::ConfigSubscriptionFailedWarning& mutable_config_subscription_failed_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kConfigSubscriptionFailedWarning;
    set_fields_[106] = true;
    return config_subscription_failed_warning_;
  }

  /// Returns whether `config_subscription_failed_warning` (no 101) is set.
  constexpr bool has_config_subscription_failed_warning() const noexcept { return set_fields_[106]; }

  /// Clears `config_subscription_failed_warning` (no 101).
  void clear_config_subscription_failed_warning() & noexcept {
    data_ = {};
    set_fields_[106] = false;
    config_subscription_failed_warning_ = {};
  }

  /// Sets `config_subscription_failed_warning` (no 101) and returns `*this`.
  LogData& set_config_subscription_failed_warning(logs::ConfigSubscriptionFailedWarning&& config_subscription_failed_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kConfigSubscriptionFailedWarning;
    set_fields_[106] = true;
    config_subscription_failed_warning_ = std::move(config_subscription_failed_warning);
    return *this;
  }
  /// Sets `config_subscription_failed_warning` (no 101) and returns `*this`.
  LogData&& set_config_subscription_failed_warning(logs::ConfigSubscriptionFailedWarning&& config_subscription_failed_warning) && noexcept {
    return std::move(set_config_subscription_failed_warning(std::move(config_subscription_failed_warning)));
  }

  // Field `thread_pool_clamped_workers_warning` (no 102).
  // -----

  /// No documentation.
  ///
  /// Field no: 102.
  constexpr const logs::ThreadPoolClampedWorkersWarning& thread_pool_clamped_workers_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return thread_pool_clamped_workers_warning_;
  }

  /// If `thread_pool_clamped_workers_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 102.
  logs::ThreadPoolClampedWorkersWarning thread_pool_clamped_workers_warning() && noexcept {
    if (!set_fields_[107]) {
      return {};
    }
    return std::move(thread_pool_clamped_workers_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 102.
  logs::ThreadPoolClampedWorkersWarning& mutable_thread_pool_clamped_workers_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kThreadPoolClampedWorkersWarning;
    set_fields_[107] = true;
    return thread_pool_clamped_workers_warning_;
  }

  /// Returns whether `thread_pool_clamped_workers_warning` (no 102) is set.
  constexpr bool has_thread_pool_clamped_workers_warning() const noexcept { return set_fields_[107]; }

  /// Clears `thread_pool_clamped_workers_warning` (no 102).
  void clear_thread_pool_clamped_workers_warning() & noexcept {
    data_ = {};
    set_fields_[107] = false;
    thread_pool_clamped_workers_warning_ = {};
  }

  /// Sets `thread_pool_clamped_workers_warning` (no 102) and returns `*this`.
  LogData& set_thread_pool_clamped_workers_warning(logs::ThreadPoolClampedWorkersWarning&& thread_pool_clamped_workers_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kThreadPoolClampedWorkersWarning;
    set_fields_[107] = true;
    thread_pool_clamped_workers_warning_ = std::move(thread_pool_clamped_workers_warning);
    return *this;
  }
  /// Sets `thread_pool_clamped_workers_warning` (no 102) and returns `*this`.
  LogData&& set_thread_pool_clamped_workers_warning(logs::ThreadPoolClampedWorkersWarning&& thread_pool_clamped_workers_warning) && noexcept {
    return std::move(set_thread_pool_clamped_workers_warning(std::move(thread_pool_clamped_workers_warning)));
  }

  // Field `stopping_horus_bag_recorder_already_stopped` (no 103).
  // -----

  /// No documentation.
  ///
  /// Field no: 103.
  constexpr const logs::StoppingHorusBagRecorderAlreadyStopped& stopping_horus_bag_recorder_already_stopped() const& noexcept HORUS_LIFETIME_BOUND {
    return stopping_horus_bag_recorder_already_stopped_;
  }

  /// If `stopping_horus_bag_recorder_already_stopped` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 103.
  logs::StoppingHorusBagRecorderAlreadyStopped stopping_horus_bag_recorder_already_stopped() && noexcept {
    if (!set_fields_[108]) {
      return {};
    }
    return std::move(stopping_horus_bag_recorder_already_stopped_);
  }

  /// No documentation.
  ///
  /// Field no: 103.
  logs::StoppingHorusBagRecorderAlreadyStopped& mutable_stopping_horus_bag_recorder_already_stopped() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kStoppingHorusBagRecorderAlreadyStopped;
    set_fields_[108] = true;
    return stopping_horus_bag_recorder_already_stopped_;
  }

  /// Returns whether `stopping_horus_bag_recorder_already_stopped` (no 103) is set.
  constexpr bool has_stopping_horus_bag_recorder_already_stopped() const noexcept { return set_fields_[108]; }

  /// Clears `stopping_horus_bag_recorder_already_stopped` (no 103).
  void clear_stopping_horus_bag_recorder_already_stopped() & noexcept {
    data_ = {};
    set_fields_[108] = false;
    stopping_horus_bag_recorder_already_stopped_ = {};
  }

  /// Sets `stopping_horus_bag_recorder_already_stopped` (no 103) and returns `*this`.
  LogData& set_stopping_horus_bag_recorder_already_stopped(logs::StoppingHorusBagRecorderAlreadyStopped&& stopping_horus_bag_recorder_already_stopped) & noexcept {
    clear_data();
    data_ = DataOneof::kStoppingHorusBagRecorderAlreadyStopped;
    set_fields_[108] = true;
    stopping_horus_bag_recorder_already_stopped_ = std::move(stopping_horus_bag_recorder_already_stopped);
    return *this;
  }
  /// Sets `stopping_horus_bag_recorder_already_stopped` (no 103) and returns `*this`.
  LogData&& set_stopping_horus_bag_recorder_already_stopped(logs::StoppingHorusBagRecorderAlreadyStopped&& stopping_horus_bag_recorder_already_stopped) && noexcept {
    return std::move(set_stopping_horus_bag_recorder_already_stopped(std::move(stopping_horus_bag_recorder_already_stopped)));
  }

  // Field `recorder_config_update_while_running` (no 104).
  // -----

  /// No documentation.
  ///
  /// Field no: 104.
  constexpr const logs::RecorderConfigUpdateWhileRunning& recorder_config_update_while_running() const& noexcept HORUS_LIFETIME_BOUND {
    return recorder_config_update_while_running_;
  }

  /// If `recorder_config_update_while_running` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 104.
  logs::RecorderConfigUpdateWhileRunning recorder_config_update_while_running() && noexcept {
    if (!set_fields_[109]) {
      return {};
    }
    return std::move(recorder_config_update_while_running_);
  }

  /// No documentation.
  ///
  /// Field no: 104.
  logs::RecorderConfigUpdateWhileRunning& mutable_recorder_config_update_while_running() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRecorderConfigUpdateWhileRunning;
    set_fields_[109] = true;
    return recorder_config_update_while_running_;
  }

  /// Returns whether `recorder_config_update_while_running` (no 104) is set.
  constexpr bool has_recorder_config_update_while_running() const noexcept { return set_fields_[109]; }

  /// Clears `recorder_config_update_while_running` (no 104).
  void clear_recorder_config_update_while_running() & noexcept {
    data_ = {};
    set_fields_[109] = false;
    recorder_config_update_while_running_ = {};
  }

  /// Sets `recorder_config_update_while_running` (no 104) and returns `*this`.
  LogData& set_recorder_config_update_while_running(logs::RecorderConfigUpdateWhileRunning&& recorder_config_update_while_running) & noexcept {
    clear_data();
    data_ = DataOneof::kRecorderConfigUpdateWhileRunning;
    set_fields_[109] = true;
    recorder_config_update_while_running_ = std::move(recorder_config_update_while_running);
    return *this;
  }
  /// Sets `recorder_config_update_while_running` (no 104) and returns `*this`.
  LogData&& set_recorder_config_update_while_running(logs::RecorderConfigUpdateWhileRunning&& recorder_config_update_while_running) && noexcept {
    return std::move(set_recorder_config_update_while_running(std::move(recorder_config_update_while_running)));
  }

  // Field `clamping_data_warning` (no 105).
  // -----

  /// No documentation.
  ///
  /// Field no: 105.
  constexpr const logs::ClampingDataWarning& clamping_data_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return clamping_data_warning_;
  }

  /// If `clamping_data_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 105.
  logs::ClampingDataWarning clamping_data_warning() && noexcept {
    if (!set_fields_[110]) {
      return {};
    }
    return std::move(clamping_data_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 105.
  logs::ClampingDataWarning& mutable_clamping_data_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kClampingDataWarning;
    set_fields_[110] = true;
    return clamping_data_warning_;
  }

  /// Returns whether `clamping_data_warning` (no 105) is set.
  constexpr bool has_clamping_data_warning() const noexcept { return set_fields_[110]; }

  /// Clears `clamping_data_warning` (no 105).
  void clear_clamping_data_warning() & noexcept {
    data_ = {};
    set_fields_[110] = false;
    clamping_data_warning_ = {};
  }

  /// Sets `clamping_data_warning` (no 105) and returns `*this`.
  LogData& set_clamping_data_warning(logs::ClampingDataWarning&& clamping_data_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kClampingDataWarning;
    set_fields_[110] = true;
    clamping_data_warning_ = std::move(clamping_data_warning);
    return *this;
  }
  /// Sets `clamping_data_warning` (no 105) and returns `*this`.
  LogData&& set_clamping_data_warning(logs::ClampingDataWarning&& clamping_data_warning) && noexcept {
    return std::move(set_clamping_data_warning(std::move(clamping_data_warning)));
  }

  // Field `lidar_incompatible_values` (no 106).
  // -----

  /// No documentation.
  ///
  /// Field no: 106.
  constexpr const logs::LidarIncompatibleValues& lidar_incompatible_values() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_incompatible_values_;
  }

  /// If `lidar_incompatible_values` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 106.
  logs::LidarIncompatibleValues lidar_incompatible_values() && noexcept {
    if (!set_fields_[111]) {
      return {};
    }
    return std::move(lidar_incompatible_values_);
  }

  /// No documentation.
  ///
  /// Field no: 106.
  logs::LidarIncompatibleValues& mutable_lidar_incompatible_values() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarIncompatibleValues;
    set_fields_[111] = true;
    return lidar_incompatible_values_;
  }

  /// Returns whether `lidar_incompatible_values` (no 106) is set.
  constexpr bool has_lidar_incompatible_values() const noexcept { return set_fields_[111]; }

  /// Clears `lidar_incompatible_values` (no 106).
  void clear_lidar_incompatible_values() & noexcept {
    data_ = {};
    set_fields_[111] = false;
    lidar_incompatible_values_ = {};
  }

  /// Sets `lidar_incompatible_values` (no 106) and returns `*this`.
  LogData& set_lidar_incompatible_values(logs::LidarIncompatibleValues&& lidar_incompatible_values) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarIncompatibleValues;
    set_fields_[111] = true;
    lidar_incompatible_values_ = std::move(lidar_incompatible_values);
    return *this;
  }
  /// Sets `lidar_incompatible_values` (no 106) and returns `*this`.
  LogData&& set_lidar_incompatible_values(logs::LidarIncompatibleValues&& lidar_incompatible_values) && noexcept {
    return std::move(set_lidar_incompatible_values(std::move(lidar_incompatible_values)));
  }

  // Field `cannot_determine_container_id_error` (no 107).
  // -----

  /// No documentation.
  ///
  /// Field no: 107.
  constexpr const logs::CannotDetermineContainerIdError& cannot_determine_container_id_error() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_determine_container_id_error_;
  }

  /// If `cannot_determine_container_id_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 107.
  logs::CannotDetermineContainerIdError cannot_determine_container_id_error() && noexcept {
    if (!set_fields_[112]) {
      return {};
    }
    return std::move(cannot_determine_container_id_error_);
  }

  /// No documentation.
  ///
  /// Field no: 107.
  logs::CannotDetermineContainerIdError& mutable_cannot_determine_container_id_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotDetermineContainerIdError;
    set_fields_[112] = true;
    return cannot_determine_container_id_error_;
  }

  /// Returns whether `cannot_determine_container_id_error` (no 107) is set.
  constexpr bool has_cannot_determine_container_id_error() const noexcept { return set_fields_[112]; }

  /// Clears `cannot_determine_container_id_error` (no 107).
  void clear_cannot_determine_container_id_error() & noexcept {
    data_ = {};
    set_fields_[112] = false;
    cannot_determine_container_id_error_ = {};
  }

  /// Sets `cannot_determine_container_id_error` (no 107) and returns `*this`.
  LogData& set_cannot_determine_container_id_error(logs::CannotDetermineContainerIdError&& cannot_determine_container_id_error) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotDetermineContainerIdError;
    set_fields_[112] = true;
    cannot_determine_container_id_error_ = std::move(cannot_determine_container_id_error);
    return *this;
  }
  /// Sets `cannot_determine_container_id_error` (no 107) and returns `*this`.
  LogData&& set_cannot_determine_container_id_error(logs::CannotDetermineContainerIdError&& cannot_determine_container_id_error) && noexcept {
    return std::move(set_cannot_determine_container_id_error(std::move(cannot_determine_container_id_error)));
  }

  // Field `started_lidar_driver` (no 108).
  // -----

  /// No documentation.
  ///
  /// Field no: 108.
  constexpr const logs::StartedLidarDriver& started_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return started_lidar_driver_;
  }

  /// If `started_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 108.
  logs::StartedLidarDriver started_lidar_driver() && noexcept {
    if (!set_fields_[113]) {
      return {};
    }
    return std::move(started_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 108.
  logs::StartedLidarDriver& mutable_started_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kStartedLidarDriver;
    set_fields_[113] = true;
    return started_lidar_driver_;
  }

  /// Returns whether `started_lidar_driver` (no 108) is set.
  constexpr bool has_started_lidar_driver() const noexcept { return set_fields_[113]; }

  /// Clears `started_lidar_driver` (no 108).
  void clear_started_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[113] = false;
    started_lidar_driver_ = {};
  }

  /// Sets `started_lidar_driver` (no 108) and returns `*this`.
  LogData& set_started_lidar_driver(logs::StartedLidarDriver&& started_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kStartedLidarDriver;
    set_fields_[113] = true;
    started_lidar_driver_ = std::move(started_lidar_driver);
    return *this;
  }
  /// Sets `started_lidar_driver` (no 108) and returns `*this`.
  LogData&& set_started_lidar_driver(logs::StartedLidarDriver&& started_lidar_driver) && noexcept {
    return std::move(set_started_lidar_driver(std::move(started_lidar_driver)));
  }

  // Field `cannot_start_lidar_driver` (no 109).
  // -----

  /// No documentation.
  ///
  /// Field no: 109.
  constexpr const logs::CannotStartLidarDriver& cannot_start_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_start_lidar_driver_;
  }

  /// If `cannot_start_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 109.
  logs::CannotStartLidarDriver cannot_start_lidar_driver() && noexcept {
    if (!set_fields_[114]) {
      return {};
    }
    return std::move(cannot_start_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 109.
  logs::CannotStartLidarDriver& mutable_cannot_start_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotStartLidarDriver;
    set_fields_[114] = true;
    return cannot_start_lidar_driver_;
  }

  /// Returns whether `cannot_start_lidar_driver` (no 109) is set.
  constexpr bool has_cannot_start_lidar_driver() const noexcept { return set_fields_[114]; }

  /// Clears `cannot_start_lidar_driver` (no 109).
  void clear_cannot_start_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[114] = false;
    cannot_start_lidar_driver_ = {};
  }

  /// Sets `cannot_start_lidar_driver` (no 109) and returns `*this`.
  LogData& set_cannot_start_lidar_driver(logs::CannotStartLidarDriver&& cannot_start_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotStartLidarDriver;
    set_fields_[114] = true;
    cannot_start_lidar_driver_ = std::move(cannot_start_lidar_driver);
    return *this;
  }
  /// Sets `cannot_start_lidar_driver` (no 109) and returns `*this`.
  LogData&& set_cannot_start_lidar_driver(logs::CannotStartLidarDriver&& cannot_start_lidar_driver) && noexcept {
    return std::move(set_cannot_start_lidar_driver(std::move(cannot_start_lidar_driver)));
  }

  // Field `stopped_lidar_driver` (no 110).
  // -----

  /// No documentation.
  ///
  /// Field no: 110.
  constexpr const logs::StoppedLidarDriver& stopped_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return stopped_lidar_driver_;
  }

  /// If `stopped_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 110.
  logs::StoppedLidarDriver stopped_lidar_driver() && noexcept {
    if (!set_fields_[115]) {
      return {};
    }
    return std::move(stopped_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 110.
  logs::StoppedLidarDriver& mutable_stopped_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kStoppedLidarDriver;
    set_fields_[115] = true;
    return stopped_lidar_driver_;
  }

  /// Returns whether `stopped_lidar_driver` (no 110) is set.
  constexpr bool has_stopped_lidar_driver() const noexcept { return set_fields_[115]; }

  /// Clears `stopped_lidar_driver` (no 110).
  void clear_stopped_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[115] = false;
    stopped_lidar_driver_ = {};
  }

  /// Sets `stopped_lidar_driver` (no 110) and returns `*this`.
  LogData& set_stopped_lidar_driver(logs::StoppedLidarDriver&& stopped_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kStoppedLidarDriver;
    set_fields_[115] = true;
    stopped_lidar_driver_ = std::move(stopped_lidar_driver);
    return *this;
  }
  /// Sets `stopped_lidar_driver` (no 110) and returns `*this`.
  LogData&& set_stopped_lidar_driver(logs::StoppedLidarDriver&& stopped_lidar_driver) && noexcept {
    return std::move(set_stopped_lidar_driver(std::move(stopped_lidar_driver)));
  }

  // Field `cannot_stop_lidar_driver` (no 111).
  // -----

  /// No documentation.
  ///
  /// Field no: 111.
  constexpr const logs::CannotStopLidarDriver& cannot_stop_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_stop_lidar_driver_;
  }

  /// If `cannot_stop_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 111.
  logs::CannotStopLidarDriver cannot_stop_lidar_driver() && noexcept {
    if (!set_fields_[116]) {
      return {};
    }
    return std::move(cannot_stop_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 111.
  logs::CannotStopLidarDriver& mutable_cannot_stop_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotStopLidarDriver;
    set_fields_[116] = true;
    return cannot_stop_lidar_driver_;
  }

  /// Returns whether `cannot_stop_lidar_driver` (no 111) is set.
  constexpr bool has_cannot_stop_lidar_driver() const noexcept { return set_fields_[116]; }

  /// Clears `cannot_stop_lidar_driver` (no 111).
  void clear_cannot_stop_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[116] = false;
    cannot_stop_lidar_driver_ = {};
  }

  /// Sets `cannot_stop_lidar_driver` (no 111) and returns `*this`.
  LogData& set_cannot_stop_lidar_driver(logs::CannotStopLidarDriver&& cannot_stop_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotStopLidarDriver;
    set_fields_[116] = true;
    cannot_stop_lidar_driver_ = std::move(cannot_stop_lidar_driver);
    return *this;
  }
  /// Sets `cannot_stop_lidar_driver` (no 111) and returns `*this`.
  LogData&& set_cannot_stop_lidar_driver(logs::CannotStopLidarDriver&& cannot_stop_lidar_driver) && noexcept {
    return std::move(set_cannot_stop_lidar_driver(std::move(cannot_stop_lidar_driver)));
  }

  // Field `restarted_lidar_driver` (no 112).
  // -----

  /// No documentation.
  ///
  /// Field no: 112.
  constexpr const logs::RestartedLidarDriver& restarted_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return restarted_lidar_driver_;
  }

  /// If `restarted_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 112.
  logs::RestartedLidarDriver restarted_lidar_driver() && noexcept {
    if (!set_fields_[117]) {
      return {};
    }
    return std::move(restarted_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 112.
  logs::RestartedLidarDriver& mutable_restarted_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRestartedLidarDriver;
    set_fields_[117] = true;
    return restarted_lidar_driver_;
  }

  /// Returns whether `restarted_lidar_driver` (no 112) is set.
  constexpr bool has_restarted_lidar_driver() const noexcept { return set_fields_[117]; }

  /// Clears `restarted_lidar_driver` (no 112).
  void clear_restarted_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[117] = false;
    restarted_lidar_driver_ = {};
  }

  /// Sets `restarted_lidar_driver` (no 112) and returns `*this`.
  LogData& set_restarted_lidar_driver(logs::RestartedLidarDriver&& restarted_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kRestartedLidarDriver;
    set_fields_[117] = true;
    restarted_lidar_driver_ = std::move(restarted_lidar_driver);
    return *this;
  }
  /// Sets `restarted_lidar_driver` (no 112) and returns `*this`.
  LogData&& set_restarted_lidar_driver(logs::RestartedLidarDriver&& restarted_lidar_driver) && noexcept {
    return std::move(set_restarted_lidar_driver(std::move(restarted_lidar_driver)));
  }

  // Field `cannot_restart_lidar_driver` (no 113).
  // -----

  /// No documentation.
  ///
  /// Field no: 113.
  constexpr const logs::CannotRestartLidarDriver& cannot_restart_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_restart_lidar_driver_;
  }

  /// If `cannot_restart_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 113.
  logs::CannotRestartLidarDriver cannot_restart_lidar_driver() && noexcept {
    if (!set_fields_[118]) {
      return {};
    }
    return std::move(cannot_restart_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 113.
  logs::CannotRestartLidarDriver& mutable_cannot_restart_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotRestartLidarDriver;
    set_fields_[118] = true;
    return cannot_restart_lidar_driver_;
  }

  /// Returns whether `cannot_restart_lidar_driver` (no 113) is set.
  constexpr bool has_cannot_restart_lidar_driver() const noexcept { return set_fields_[118]; }

  /// Clears `cannot_restart_lidar_driver` (no 113).
  void clear_cannot_restart_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[118] = false;
    cannot_restart_lidar_driver_ = {};
  }

  /// Sets `cannot_restart_lidar_driver` (no 113) and returns `*this`.
  LogData& set_cannot_restart_lidar_driver(logs::CannotRestartLidarDriver&& cannot_restart_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotRestartLidarDriver;
    set_fields_[118] = true;
    cannot_restart_lidar_driver_ = std::move(cannot_restart_lidar_driver);
    return *this;
  }
  /// Sets `cannot_restart_lidar_driver` (no 113) and returns `*this`.
  LogData&& set_cannot_restart_lidar_driver(logs::CannotRestartLidarDriver&& cannot_restart_lidar_driver) && noexcept {
    return std::move(set_cannot_restart_lidar_driver(std::move(cannot_restart_lidar_driver)));
  }

  // Field `removed_unused_lidar_driver` (no 114).
  // -----

  /// No documentation.
  ///
  /// Field no: 114.
  constexpr const logs::RemovedUnusedLidarDriver& removed_unused_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return removed_unused_lidar_driver_;
  }

  /// If `removed_unused_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 114.
  logs::RemovedUnusedLidarDriver removed_unused_lidar_driver() && noexcept {
    if (!set_fields_[119]) {
      return {};
    }
    return std::move(removed_unused_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 114.
  logs::RemovedUnusedLidarDriver& mutable_removed_unused_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRemovedUnusedLidarDriver;
    set_fields_[119] = true;
    return removed_unused_lidar_driver_;
  }

  /// Returns whether `removed_unused_lidar_driver` (no 114) is set.
  constexpr bool has_removed_unused_lidar_driver() const noexcept { return set_fields_[119]; }

  /// Clears `removed_unused_lidar_driver` (no 114).
  void clear_removed_unused_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[119] = false;
    removed_unused_lidar_driver_ = {};
  }

  /// Sets `removed_unused_lidar_driver` (no 114) and returns `*this`.
  LogData& set_removed_unused_lidar_driver(logs::RemovedUnusedLidarDriver&& removed_unused_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kRemovedUnusedLidarDriver;
    set_fields_[119] = true;
    removed_unused_lidar_driver_ = std::move(removed_unused_lidar_driver);
    return *this;
  }
  /// Sets `removed_unused_lidar_driver` (no 114) and returns `*this`.
  LogData&& set_removed_unused_lidar_driver(logs::RemovedUnusedLidarDriver&& removed_unused_lidar_driver) && noexcept {
    return std::move(set_removed_unused_lidar_driver(std::move(removed_unused_lidar_driver)));
  }

  // Field `cannot_remove_unused_lidar_driver` (no 115).
  // -----

  /// No documentation.
  ///
  /// Field no: 115.
  constexpr const logs::CannotRemoveUnusedLidarDriver& cannot_remove_unused_lidar_driver() const& noexcept HORUS_LIFETIME_BOUND {
    return cannot_remove_unused_lidar_driver_;
  }

  /// If `cannot_remove_unused_lidar_driver` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 115.
  logs::CannotRemoveUnusedLidarDriver cannot_remove_unused_lidar_driver() && noexcept {
    if (!set_fields_[120]) {
      return {};
    }
    return std::move(cannot_remove_unused_lidar_driver_);
  }

  /// No documentation.
  ///
  /// Field no: 115.
  logs::CannotRemoveUnusedLidarDriver& mutable_cannot_remove_unused_lidar_driver() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCannotRemoveUnusedLidarDriver;
    set_fields_[120] = true;
    return cannot_remove_unused_lidar_driver_;
  }

  /// Returns whether `cannot_remove_unused_lidar_driver` (no 115) is set.
  constexpr bool has_cannot_remove_unused_lidar_driver() const noexcept { return set_fields_[120]; }

  /// Clears `cannot_remove_unused_lidar_driver` (no 115).
  void clear_cannot_remove_unused_lidar_driver() & noexcept {
    data_ = {};
    set_fields_[120] = false;
    cannot_remove_unused_lidar_driver_ = {};
  }

  /// Sets `cannot_remove_unused_lidar_driver` (no 115) and returns `*this`.
  LogData& set_cannot_remove_unused_lidar_driver(logs::CannotRemoveUnusedLidarDriver&& cannot_remove_unused_lidar_driver) & noexcept {
    clear_data();
    data_ = DataOneof::kCannotRemoveUnusedLidarDriver;
    set_fields_[120] = true;
    cannot_remove_unused_lidar_driver_ = std::move(cannot_remove_unused_lidar_driver);
    return *this;
  }
  /// Sets `cannot_remove_unused_lidar_driver` (no 115) and returns `*this`.
  LogData&& set_cannot_remove_unused_lidar_driver(logs::CannotRemoveUnusedLidarDriver&& cannot_remove_unused_lidar_driver) && noexcept {
    return std::move(set_cannot_remove_unused_lidar_driver(std::move(cannot_remove_unused_lidar_driver)));
  }

  // Field `lidar_driver_gc_failure` (no 116).
  // -----

  /// No documentation.
  ///
  /// Field no: 116.
  constexpr const logs::LidarDriverGcFailure& lidar_driver_gc_failure() const& noexcept HORUS_LIFETIME_BOUND {
    return lidar_driver_gc_failure_;
  }

  /// If `lidar_driver_gc_failure` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 116.
  logs::LidarDriverGcFailure lidar_driver_gc_failure() && noexcept {
    if (!set_fields_[121]) {
      return {};
    }
    return std::move(lidar_driver_gc_failure_);
  }

  /// No documentation.
  ///
  /// Field no: 116.
  logs::LidarDriverGcFailure& mutable_lidar_driver_gc_failure() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLidarDriverGcFailure;
    set_fields_[121] = true;
    return lidar_driver_gc_failure_;
  }

  /// Returns whether `lidar_driver_gc_failure` (no 116) is set.
  constexpr bool has_lidar_driver_gc_failure() const noexcept { return set_fields_[121]; }

  /// Clears `lidar_driver_gc_failure` (no 116).
  void clear_lidar_driver_gc_failure() & noexcept {
    data_ = {};
    set_fields_[121] = false;
    lidar_driver_gc_failure_ = {};
  }

  /// Sets `lidar_driver_gc_failure` (no 116) and returns `*this`.
  LogData& set_lidar_driver_gc_failure(logs::LidarDriverGcFailure&& lidar_driver_gc_failure) & noexcept {
    clear_data();
    data_ = DataOneof::kLidarDriverGcFailure;
    set_fields_[121] = true;
    lidar_driver_gc_failure_ = std::move(lidar_driver_gc_failure);
    return *this;
  }
  /// Sets `lidar_driver_gc_failure` (no 116) and returns `*this`.
  LogData&& set_lidar_driver_gc_failure(logs::LidarDriverGcFailure&& lidar_driver_gc_failure) && noexcept {
    return std::move(set_lidar_driver_gc_failure(std::move(lidar_driver_gc_failure)));
  }

  // Field `id_space_exhausted` (no 117).
  // -----

  /// No documentation.
  ///
  /// Field no: 117.
  constexpr const logs::IdSpaceExhausted& id_space_exhausted() const& noexcept HORUS_LIFETIME_BOUND {
    return id_space_exhausted_;
  }

  /// If `id_space_exhausted` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 117.
  logs::IdSpaceExhausted id_space_exhausted() && noexcept {
    if (!set_fields_[122]) {
      return {};
    }
    return std::move(id_space_exhausted_);
  }

  /// No documentation.
  ///
  /// Field no: 117.
  logs::IdSpaceExhausted& mutable_id_space_exhausted() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kIdSpaceExhausted;
    set_fields_[122] = true;
    return id_space_exhausted_;
  }

  /// Returns whether `id_space_exhausted` (no 117) is set.
  constexpr bool has_id_space_exhausted() const noexcept { return set_fields_[122]; }

  /// Clears `id_space_exhausted` (no 117).
  void clear_id_space_exhausted() & noexcept {
    data_ = {};
    set_fields_[122] = false;
    id_space_exhausted_ = {};
  }

  /// Sets `id_space_exhausted` (no 117) and returns `*this`.
  LogData& set_id_space_exhausted(logs::IdSpaceExhausted&& id_space_exhausted) & noexcept {
    clear_data();
    data_ = DataOneof::kIdSpaceExhausted;
    set_fields_[122] = true;
    id_space_exhausted_ = std::move(id_space_exhausted);
    return *this;
  }
  /// Sets `id_space_exhausted` (no 117) and returns `*this`.
  LogData&& set_id_space_exhausted(logs::IdSpaceExhausted&& id_space_exhausted) && noexcept {
    return std::move(set_id_space_exhausted(std::move(id_space_exhausted)));
  }

  // Field `preprocessing_to_point_aggregator_points_skipped` (no 118).
  // -----

  /// No documentation.
  ///
  /// Field no: 118.
  constexpr const logs::PreprocessingToPointAggregatorPointsSkipped& preprocessing_to_point_aggregator_points_skipped() const& noexcept HORUS_LIFETIME_BOUND {
    return preprocessing_to_point_aggregator_points_skipped_;
  }

  /// If `preprocessing_to_point_aggregator_points_skipped` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 118.
  logs::PreprocessingToPointAggregatorPointsSkipped preprocessing_to_point_aggregator_points_skipped() && noexcept {
    if (!set_fields_[123]) {
      return {};
    }
    return std::move(preprocessing_to_point_aggregator_points_skipped_);
  }

  /// No documentation.
  ///
  /// Field no: 118.
  logs::PreprocessingToPointAggregatorPointsSkipped& mutable_preprocessing_to_point_aggregator_points_skipped() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kPreprocessingToPointAggregatorPointsSkipped;
    set_fields_[123] = true;
    return preprocessing_to_point_aggregator_points_skipped_;
  }

  /// Returns whether `preprocessing_to_point_aggregator_points_skipped` (no 118) is set.
  constexpr bool has_preprocessing_to_point_aggregator_points_skipped() const noexcept { return set_fields_[123]; }

  /// Clears `preprocessing_to_point_aggregator_points_skipped` (no 118).
  void clear_preprocessing_to_point_aggregator_points_skipped() & noexcept {
    data_ = {};
    set_fields_[123] = false;
    preprocessing_to_point_aggregator_points_skipped_ = {};
  }

  /// Sets `preprocessing_to_point_aggregator_points_skipped` (no 118) and returns `*this`.
  LogData& set_preprocessing_to_point_aggregator_points_skipped(logs::PreprocessingToPointAggregatorPointsSkipped&& preprocessing_to_point_aggregator_points_skipped) & noexcept {
    clear_data();
    data_ = DataOneof::kPreprocessingToPointAggregatorPointsSkipped;
    set_fields_[123] = true;
    preprocessing_to_point_aggregator_points_skipped_ = std::move(preprocessing_to_point_aggregator_points_skipped);
    return *this;
  }
  /// Sets `preprocessing_to_point_aggregator_points_skipped` (no 118) and returns `*this`.
  LogData&& set_preprocessing_to_point_aggregator_points_skipped(logs::PreprocessingToPointAggregatorPointsSkipped&& preprocessing_to_point_aggregator_points_skipped) && noexcept {
    return std::move(set_preprocessing_to_point_aggregator_points_skipped(std::move(preprocessing_to_point_aggregator_points_skipped)));
  }

  // Field `min_msg_interval_less_than_threshold` (no 119).
  // -----

  /// No documentation.
  ///
  /// Field no: 119.
  constexpr const logs::MinMsgIntervalLessThanThreshold& min_msg_interval_less_than_threshold() const& noexcept HORUS_LIFETIME_BOUND {
    return min_msg_interval_less_than_threshold_;
  }

  /// If `min_msg_interval_less_than_threshold` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 119.
  logs::MinMsgIntervalLessThanThreshold min_msg_interval_less_than_threshold() && noexcept {
    if (!set_fields_[124]) {
      return {};
    }
    return std::move(min_msg_interval_less_than_threshold_);
  }

  /// No documentation.
  ///
  /// Field no: 119.
  logs::MinMsgIntervalLessThanThreshold& mutable_min_msg_interval_less_than_threshold() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kMinMsgIntervalLessThanThreshold;
    set_fields_[124] = true;
    return min_msg_interval_less_than_threshold_;
  }

  /// Returns whether `min_msg_interval_less_than_threshold` (no 119) is set.
  constexpr bool has_min_msg_interval_less_than_threshold() const noexcept { return set_fields_[124]; }

  /// Clears `min_msg_interval_less_than_threshold` (no 119).
  void clear_min_msg_interval_less_than_threshold() & noexcept {
    data_ = {};
    set_fields_[124] = false;
    min_msg_interval_less_than_threshold_ = {};
  }

  /// Sets `min_msg_interval_less_than_threshold` (no 119) and returns `*this`.
  LogData& set_min_msg_interval_less_than_threshold(logs::MinMsgIntervalLessThanThreshold&& min_msg_interval_less_than_threshold) & noexcept {
    clear_data();
    data_ = DataOneof::kMinMsgIntervalLessThanThreshold;
    set_fields_[124] = true;
    min_msg_interval_less_than_threshold_ = std::move(min_msg_interval_less_than_threshold);
    return *this;
  }
  /// Sets `min_msg_interval_less_than_threshold` (no 119) and returns `*this`.
  LogData&& set_min_msg_interval_less_than_threshold(logs::MinMsgIntervalLessThanThreshold&& min_msg_interval_less_than_threshold) && noexcept {
    return std::move(set_min_msg_interval_less_than_threshold(std::move(min_msg_interval_less_than_threshold)));
  }

  // Field `failed_to_cleanup_ros_warning` (no 120).
  // -----

  /// No documentation.
  ///
  /// Field no: 120.
  constexpr const logs::FailedToCleanupRosWarning& failed_to_cleanup_ros_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_cleanup_ros_warning_;
  }

  /// If `failed_to_cleanup_ros_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 120.
  logs::FailedToCleanupRosWarning failed_to_cleanup_ros_warning() && noexcept {
    if (!set_fields_[125]) {
      return {};
    }
    return std::move(failed_to_cleanup_ros_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 120.
  logs::FailedToCleanupRosWarning& mutable_failed_to_cleanup_ros_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToCleanupRosWarning;
    set_fields_[125] = true;
    return failed_to_cleanup_ros_warning_;
  }

  /// Returns whether `failed_to_cleanup_ros_warning` (no 120) is set.
  constexpr bool has_failed_to_cleanup_ros_warning() const noexcept { return set_fields_[125]; }

  /// Clears `failed_to_cleanup_ros_warning` (no 120).
  void clear_failed_to_cleanup_ros_warning() & noexcept {
    data_ = {};
    set_fields_[125] = false;
    failed_to_cleanup_ros_warning_ = {};
  }

  /// Sets `failed_to_cleanup_ros_warning` (no 120) and returns `*this`.
  LogData& set_failed_to_cleanup_ros_warning(logs::FailedToCleanupRosWarning&& failed_to_cleanup_ros_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToCleanupRosWarning;
    set_fields_[125] = true;
    failed_to_cleanup_ros_warning_ = std::move(failed_to_cleanup_ros_warning);
    return *this;
  }
  /// Sets `failed_to_cleanup_ros_warning` (no 120) and returns `*this`.
  LogData&& set_failed_to_cleanup_ros_warning(logs::FailedToCleanupRosWarning&& failed_to_cleanup_ros_warning) && noexcept {
    return std::move(set_failed_to_cleanup_ros_warning(std::move(failed_to_cleanup_ros_warning)));
  }

  // Field `rpc_disconnected_warning` (no 121).
  // -----

  /// No documentation.
  ///
  /// Field no: 121.
  constexpr const logs::RpcDisconnectedWarning& rpc_disconnected_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_disconnected_warning_;
  }

  /// If `rpc_disconnected_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 121.
  logs::RpcDisconnectedWarning rpc_disconnected_warning() && noexcept {
    if (!set_fields_[126]) {
      return {};
    }
    return std::move(rpc_disconnected_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 121.
  logs::RpcDisconnectedWarning& mutable_rpc_disconnected_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcDisconnectedWarning;
    set_fields_[126] = true;
    return rpc_disconnected_warning_;
  }

  /// Returns whether `rpc_disconnected_warning` (no 121) is set.
  constexpr bool has_rpc_disconnected_warning() const noexcept { return set_fields_[126]; }

  /// Clears `rpc_disconnected_warning` (no 121).
  void clear_rpc_disconnected_warning() & noexcept {
    data_ = {};
    set_fields_[126] = false;
    rpc_disconnected_warning_ = {};
  }

  /// Sets `rpc_disconnected_warning` (no 121) and returns `*this`.
  LogData& set_rpc_disconnected_warning(logs::RpcDisconnectedWarning&& rpc_disconnected_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcDisconnectedWarning;
    set_fields_[126] = true;
    rpc_disconnected_warning_ = std::move(rpc_disconnected_warning);
    return *this;
  }
  /// Sets `rpc_disconnected_warning` (no 121) and returns `*this`.
  LogData&& set_rpc_disconnected_warning(logs::RpcDisconnectedWarning&& rpc_disconnected_warning) && noexcept {
    return std::move(set_rpc_disconnected_warning(std::move(rpc_disconnected_warning)));
  }

  // Field `rpc_unhandled_error` (no 122).
  // -----

  /// No documentation.
  ///
  /// Field no: 122.
  constexpr const logs::RpcUnhandledError& rpc_unhandled_error() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_unhandled_error_;
  }

  /// If `rpc_unhandled_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 122.
  logs::RpcUnhandledError rpc_unhandled_error() && noexcept {
    if (!set_fields_[127]) {
      return {};
    }
    return std::move(rpc_unhandled_error_);
  }

  /// No documentation.
  ///
  /// Field no: 122.
  logs::RpcUnhandledError& mutable_rpc_unhandled_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcUnhandledError;
    set_fields_[127] = true;
    return rpc_unhandled_error_;
  }

  /// Returns whether `rpc_unhandled_error` (no 122) is set.
  constexpr bool has_rpc_unhandled_error() const noexcept { return set_fields_[127]; }

  /// Clears `rpc_unhandled_error` (no 122).
  void clear_rpc_unhandled_error() & noexcept {
    data_ = {};
    set_fields_[127] = false;
    rpc_unhandled_error_ = {};
  }

  /// Sets `rpc_unhandled_error` (no 122) and returns `*this`.
  LogData& set_rpc_unhandled_error(logs::RpcUnhandledError&& rpc_unhandled_error) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcUnhandledError;
    set_fields_[127] = true;
    rpc_unhandled_error_ = std::move(rpc_unhandled_error);
    return *this;
  }
  /// Sets `rpc_unhandled_error` (no 122) and returns `*this`.
  LogData&& set_rpc_unhandled_error(logs::RpcUnhandledError&& rpc_unhandled_error) && noexcept {
    return std::move(set_rpc_unhandled_error(std::move(rpc_unhandled_error)));
  }

  // Field `time_diff_out_of_range_warning` (no 123).
  // -----

  /// No documentation.
  ///
  /// Field no: 123.
  constexpr const logs::TimeDiffOutOfRangeWarning& time_diff_out_of_range_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return time_diff_out_of_range_warning_;
  }

  /// If `time_diff_out_of_range_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 123.
  logs::TimeDiffOutOfRangeWarning time_diff_out_of_range_warning() && noexcept {
    if (!set_fields_[128]) {
      return {};
    }
    return std::move(time_diff_out_of_range_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 123.
  logs::TimeDiffOutOfRangeWarning& mutable_time_diff_out_of_range_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kTimeDiffOutOfRangeWarning;
    set_fields_[128] = true;
    return time_diff_out_of_range_warning_;
  }

  /// Returns whether `time_diff_out_of_range_warning` (no 123) is set.
  constexpr bool has_time_diff_out_of_range_warning() const noexcept { return set_fields_[128]; }

  /// Clears `time_diff_out_of_range_warning` (no 123).
  void clear_time_diff_out_of_range_warning() & noexcept {
    data_ = {};
    set_fields_[128] = false;
    time_diff_out_of_range_warning_ = {};
  }

  /// Sets `time_diff_out_of_range_warning` (no 123) and returns `*this`.
  LogData& set_time_diff_out_of_range_warning(logs::TimeDiffOutOfRangeWarning&& time_diff_out_of_range_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kTimeDiffOutOfRangeWarning;
    set_fields_[128] = true;
    time_diff_out_of_range_warning_ = std::move(time_diff_out_of_range_warning);
    return *this;
  }
  /// Sets `time_diff_out_of_range_warning` (no 123) and returns `*this`.
  LogData&& set_time_diff_out_of_range_warning(logs::TimeDiffOutOfRangeWarning&& time_diff_out_of_range_warning) && noexcept {
    return std::move(set_time_diff_out_of_range_warning(std::move(time_diff_out_of_range_warning)));
  }

  // Field `tensorrt_log` (no 124).
  // -----

  /// No documentation.
  ///
  /// Field no: 124.
  constexpr const logs::TensorrtLog& tensorrt_log() const& noexcept HORUS_LIFETIME_BOUND {
    return tensorrt_log_;
  }

  /// If `tensorrt_log` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 124.
  logs::TensorrtLog tensorrt_log() && noexcept {
    if (!set_fields_[129]) {
      return {};
    }
    return std::move(tensorrt_log_);
  }

  /// No documentation.
  ///
  /// Field no: 124.
  logs::TensorrtLog& mutable_tensorrt_log() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kTensorrtLog;
    set_fields_[129] = true;
    return tensorrt_log_;
  }

  /// Returns whether `tensorrt_log` (no 124) is set.
  constexpr bool has_tensorrt_log() const noexcept { return set_fields_[129]; }

  /// Clears `tensorrt_log` (no 124).
  void clear_tensorrt_log() & noexcept {
    data_ = {};
    set_fields_[129] = false;
    tensorrt_log_ = {};
  }

  /// Sets `tensorrt_log` (no 124) and returns `*this`.
  LogData& set_tensorrt_log(logs::TensorrtLog&& tensorrt_log) & noexcept {
    clear_data();
    data_ = DataOneof::kTensorrtLog;
    set_fields_[129] = true;
    tensorrt_log_ = std::move(tensorrt_log);
    return *this;
  }
  /// Sets `tensorrt_log` (no 124) and returns `*this`.
  LogData&& set_tensorrt_log(logs::TensorrtLog&& tensorrt_log) && noexcept {
    return std::move(set_tensorrt_log(std::move(tensorrt_log)));
  }

  // Field `building_tensorrt_engine_info` (no 125).
  // -----

  /// No documentation.
  ///
  /// Field no: 125.
  constexpr const logs::BuildingTensorrtEngineInfo& building_tensorrt_engine_info() const& noexcept HORUS_LIFETIME_BOUND {
    return building_tensorrt_engine_info_;
  }

  /// If `building_tensorrt_engine_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 125.
  logs::BuildingTensorrtEngineInfo building_tensorrt_engine_info() && noexcept {
    if (!set_fields_[130]) {
      return {};
    }
    return std::move(building_tensorrt_engine_info_);
  }

  /// No documentation.
  ///
  /// Field no: 125.
  logs::BuildingTensorrtEngineInfo& mutable_building_tensorrt_engine_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBuildingTensorrtEngineInfo;
    set_fields_[130] = true;
    return building_tensorrt_engine_info_;
  }

  /// Returns whether `building_tensorrt_engine_info` (no 125) is set.
  constexpr bool has_building_tensorrt_engine_info() const noexcept { return set_fields_[130]; }

  /// Clears `building_tensorrt_engine_info` (no 125).
  void clear_building_tensorrt_engine_info() & noexcept {
    data_ = {};
    set_fields_[130] = false;
    building_tensorrt_engine_info_ = {};
  }

  /// Sets `building_tensorrt_engine_info` (no 125) and returns `*this`.
  LogData& set_building_tensorrt_engine_info(logs::BuildingTensorrtEngineInfo&& building_tensorrt_engine_info) & noexcept {
    clear_data();
    data_ = DataOneof::kBuildingTensorrtEngineInfo;
    set_fields_[130] = true;
    building_tensorrt_engine_info_ = std::move(building_tensorrt_engine_info);
    return *this;
  }
  /// Sets `building_tensorrt_engine_info` (no 125) and returns `*this`.
  LogData&& set_building_tensorrt_engine_info(logs::BuildingTensorrtEngineInfo&& building_tensorrt_engine_info) && noexcept {
    return std::move(set_building_tensorrt_engine_info(std::move(building_tensorrt_engine_info)));
  }

  // Field `loading_tensorrt_engine_info` (no 126).
  // -----

  /// No documentation.
  ///
  /// Field no: 126.
  constexpr const logs::LoadingTensorrtEngineInfo& loading_tensorrt_engine_info() const& noexcept HORUS_LIFETIME_BOUND {
    return loading_tensorrt_engine_info_;
  }

  /// If `loading_tensorrt_engine_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 126.
  logs::LoadingTensorrtEngineInfo loading_tensorrt_engine_info() && noexcept {
    if (!set_fields_[131]) {
      return {};
    }
    return std::move(loading_tensorrt_engine_info_);
  }

  /// No documentation.
  ///
  /// Field no: 126.
  logs::LoadingTensorrtEngineInfo& mutable_loading_tensorrt_engine_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLoadingTensorrtEngineInfo;
    set_fields_[131] = true;
    return loading_tensorrt_engine_info_;
  }

  /// Returns whether `loading_tensorrt_engine_info` (no 126) is set.
  constexpr bool has_loading_tensorrt_engine_info() const noexcept { return set_fields_[131]; }

  /// Clears `loading_tensorrt_engine_info` (no 126).
  void clear_loading_tensorrt_engine_info() & noexcept {
    data_ = {};
    set_fields_[131] = false;
    loading_tensorrt_engine_info_ = {};
  }

  /// Sets `loading_tensorrt_engine_info` (no 126) and returns `*this`.
  LogData& set_loading_tensorrt_engine_info(logs::LoadingTensorrtEngineInfo&& loading_tensorrt_engine_info) & noexcept {
    clear_data();
    data_ = DataOneof::kLoadingTensorrtEngineInfo;
    set_fields_[131] = true;
    loading_tensorrt_engine_info_ = std::move(loading_tensorrt_engine_info);
    return *this;
  }
  /// Sets `loading_tensorrt_engine_info` (no 126) and returns `*this`.
  LogData&& set_loading_tensorrt_engine_info(logs::LoadingTensorrtEngineInfo&& loading_tensorrt_engine_info) && noexcept {
    return std::move(set_loading_tensorrt_engine_info(std::move(loading_tensorrt_engine_info)));
  }

  // Field `calibration_map_not_found` (no 127).
  // -----

  /// No documentation.
  ///
  /// Field no: 127.
  constexpr const logs::CalibrationMapNotFound& calibration_map_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_map_not_found_;
  }

  /// If `calibration_map_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 127.
  logs::CalibrationMapNotFound calibration_map_not_found() && noexcept {
    if (!set_fields_[132]) {
      return {};
    }
    return std::move(calibration_map_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 127.
  logs::CalibrationMapNotFound& mutable_calibration_map_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationMapNotFound;
    set_fields_[132] = true;
    return calibration_map_not_found_;
  }

  /// Returns whether `calibration_map_not_found` (no 127) is set.
  constexpr bool has_calibration_map_not_found() const noexcept { return set_fields_[132]; }

  /// Clears `calibration_map_not_found` (no 127).
  void clear_calibration_map_not_found() & noexcept {
    data_ = {};
    set_fields_[132] = false;
    calibration_map_not_found_ = {};
  }

  /// Sets `calibration_map_not_found` (no 127) and returns `*this`.
  LogData& set_calibration_map_not_found(logs::CalibrationMapNotFound&& calibration_map_not_found) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationMapNotFound;
    set_fields_[132] = true;
    calibration_map_not_found_ = std::move(calibration_map_not_found);
    return *this;
  }
  /// Sets `calibration_map_not_found` (no 127) and returns `*this`.
  LogData&& set_calibration_map_not_found(logs::CalibrationMapNotFound&& calibration_map_not_found) && noexcept {
    return std::move(set_calibration_map_not_found(std::move(calibration_map_not_found)));
  }

  // Field `calibration_map_not_valid` (no 128).
  // -----

  /// No documentation.
  ///
  /// Field no: 128.
  constexpr const logs::CalibrationMapNotValid& calibration_map_not_valid() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_map_not_valid_;
  }

  /// If `calibration_map_not_valid` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 128.
  logs::CalibrationMapNotValid calibration_map_not_valid() && noexcept {
    if (!set_fields_[133]) {
      return {};
    }
    return std::move(calibration_map_not_valid_);
  }

  /// No documentation.
  ///
  /// Field no: 128.
  logs::CalibrationMapNotValid& mutable_calibration_map_not_valid() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationMapNotValid;
    set_fields_[133] = true;
    return calibration_map_not_valid_;
  }

  /// Returns whether `calibration_map_not_valid` (no 128) is set.
  constexpr bool has_calibration_map_not_valid() const noexcept { return set_fields_[133]; }

  /// Clears `calibration_map_not_valid` (no 128).
  void clear_calibration_map_not_valid() & noexcept {
    data_ = {};
    set_fields_[133] = false;
    calibration_map_not_valid_ = {};
  }

  /// Sets `calibration_map_not_valid` (no 128) and returns `*this`.
  LogData& set_calibration_map_not_valid(logs::CalibrationMapNotValid&& calibration_map_not_valid) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationMapNotValid;
    set_fields_[133] = true;
    calibration_map_not_valid_ = std::move(calibration_map_not_valid);
    return *this;
  }
  /// Sets `calibration_map_not_valid` (no 128) and returns `*this`.
  LogData&& set_calibration_map_not_valid(logs::CalibrationMapNotValid&& calibration_map_not_valid) && noexcept {
    return std::move(set_calibration_map_not_valid(std::move(calibration_map_not_valid)));
  }

  // Field `calibration_map_path_already_exists` (no 129).
  // -----

  /// No documentation.
  ///
  /// Field no: 129.
  constexpr const logs::CalibrationMapPathAlreadyExists& calibration_map_path_already_exists() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_map_path_already_exists_;
  }

  /// If `calibration_map_path_already_exists` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 129.
  logs::CalibrationMapPathAlreadyExists calibration_map_path_already_exists() && noexcept {
    if (!set_fields_[134]) {
      return {};
    }
    return std::move(calibration_map_path_already_exists_);
  }

  /// No documentation.
  ///
  /// Field no: 129.
  logs::CalibrationMapPathAlreadyExists& mutable_calibration_map_path_already_exists() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationMapPathAlreadyExists;
    set_fields_[134] = true;
    return calibration_map_path_already_exists_;
  }

  /// Returns whether `calibration_map_path_already_exists` (no 129) is set.
  constexpr bool has_calibration_map_path_already_exists() const noexcept { return set_fields_[134]; }

  /// Clears `calibration_map_path_already_exists` (no 129).
  void clear_calibration_map_path_already_exists() & noexcept {
    data_ = {};
    set_fields_[134] = false;
    calibration_map_path_already_exists_ = {};
  }

  /// Sets `calibration_map_path_already_exists` (no 129) and returns `*this`.
  LogData& set_calibration_map_path_already_exists(logs::CalibrationMapPathAlreadyExists&& calibration_map_path_already_exists) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationMapPathAlreadyExists;
    set_fields_[134] = true;
    calibration_map_path_already_exists_ = std::move(calibration_map_path_already_exists);
    return *this;
  }
  /// Sets `calibration_map_path_already_exists` (no 129) and returns `*this`.
  LogData&& set_calibration_map_path_already_exists(logs::CalibrationMapPathAlreadyExists&& calibration_map_path_already_exists) && noexcept {
    return std::move(set_calibration_map_path_already_exists(std::move(calibration_map_path_already_exists)));
  }

  // Field `failed_to_save_calibration_map` (no 130).
  // -----

  /// No documentation.
  ///
  /// Field no: 130.
  constexpr const logs::FailedToSaveCalibrationMap& failed_to_save_calibration_map() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_save_calibration_map_;
  }

  /// If `failed_to_save_calibration_map` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 130.
  logs::FailedToSaveCalibrationMap failed_to_save_calibration_map() && noexcept {
    if (!set_fields_[135]) {
      return {};
    }
    return std::move(failed_to_save_calibration_map_);
  }

  /// No documentation.
  ///
  /// Field no: 130.
  logs::FailedToSaveCalibrationMap& mutable_failed_to_save_calibration_map() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToSaveCalibrationMap;
    set_fields_[135] = true;
    return failed_to_save_calibration_map_;
  }

  /// Returns whether `failed_to_save_calibration_map` (no 130) is set.
  constexpr bool has_failed_to_save_calibration_map() const noexcept { return set_fields_[135]; }

  /// Clears `failed_to_save_calibration_map` (no 130).
  void clear_failed_to_save_calibration_map() & noexcept {
    data_ = {};
    set_fields_[135] = false;
    failed_to_save_calibration_map_ = {};
  }

  /// Sets `failed_to_save_calibration_map` (no 130) and returns `*this`.
  LogData& set_failed_to_save_calibration_map(logs::FailedToSaveCalibrationMap&& failed_to_save_calibration_map) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToSaveCalibrationMap;
    set_fields_[135] = true;
    failed_to_save_calibration_map_ = std::move(failed_to_save_calibration_map);
    return *this;
  }
  /// Sets `failed_to_save_calibration_map` (no 130) and returns `*this`.
  LogData&& set_failed_to_save_calibration_map(logs::FailedToSaveCalibrationMap&& failed_to_save_calibration_map) && noexcept {
    return std::move(set_failed_to_save_calibration_map(std::move(failed_to_save_calibration_map)));
  }

  // Field `failed_to_remove_calibration_map` (no 131).
  // -----

  /// No documentation.
  ///
  /// Field no: 131.
  constexpr const logs::FailedToRemoveCalibrationMap& failed_to_remove_calibration_map() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_remove_calibration_map_;
  }

  /// If `failed_to_remove_calibration_map` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 131.
  logs::FailedToRemoveCalibrationMap failed_to_remove_calibration_map() && noexcept {
    if (!set_fields_[136]) {
      return {};
    }
    return std::move(failed_to_remove_calibration_map_);
  }

  /// No documentation.
  ///
  /// Field no: 131.
  logs::FailedToRemoveCalibrationMap& mutable_failed_to_remove_calibration_map() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToRemoveCalibrationMap;
    set_fields_[136] = true;
    return failed_to_remove_calibration_map_;
  }

  /// Returns whether `failed_to_remove_calibration_map` (no 131) is set.
  constexpr bool has_failed_to_remove_calibration_map() const noexcept { return set_fields_[136]; }

  /// Clears `failed_to_remove_calibration_map` (no 131).
  void clear_failed_to_remove_calibration_map() & noexcept {
    data_ = {};
    set_fields_[136] = false;
    failed_to_remove_calibration_map_ = {};
  }

  /// Sets `failed_to_remove_calibration_map` (no 131) and returns `*this`.
  LogData& set_failed_to_remove_calibration_map(logs::FailedToRemoveCalibrationMap&& failed_to_remove_calibration_map) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToRemoveCalibrationMap;
    set_fields_[136] = true;
    failed_to_remove_calibration_map_ = std::move(failed_to_remove_calibration_map);
    return *this;
  }
  /// Sets `failed_to_remove_calibration_map` (no 131) and returns `*this`.
  LogData&& set_failed_to_remove_calibration_map(logs::FailedToRemoveCalibrationMap&& failed_to_remove_calibration_map) && noexcept {
    return std::move(set_failed_to_remove_calibration_map(std::move(failed_to_remove_calibration_map)));
  }

  // Field `failed_to_iterate_in_directory` (no 132).
  // -----

  /// No documentation.
  ///
  /// Field no: 132.
  constexpr const logs::FailedToIterateInDirectory& failed_to_iterate_in_directory() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_iterate_in_directory_;
  }

  /// If `failed_to_iterate_in_directory` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 132.
  logs::FailedToIterateInDirectory failed_to_iterate_in_directory() && noexcept {
    if (!set_fields_[137]) {
      return {};
    }
    return std::move(failed_to_iterate_in_directory_);
  }

  /// No documentation.
  ///
  /// Field no: 132.
  logs::FailedToIterateInDirectory& mutable_failed_to_iterate_in_directory() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToIterateInDirectory;
    set_fields_[137] = true;
    return failed_to_iterate_in_directory_;
  }

  /// Returns whether `failed_to_iterate_in_directory` (no 132) is set.
  constexpr bool has_failed_to_iterate_in_directory() const noexcept { return set_fields_[137]; }

  /// Clears `failed_to_iterate_in_directory` (no 132).
  void clear_failed_to_iterate_in_directory() & noexcept {
    data_ = {};
    set_fields_[137] = false;
    failed_to_iterate_in_directory_ = {};
  }

  /// Sets `failed_to_iterate_in_directory` (no 132) and returns `*this`.
  LogData& set_failed_to_iterate_in_directory(logs::FailedToIterateInDirectory&& failed_to_iterate_in_directory) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToIterateInDirectory;
    set_fields_[137] = true;
    failed_to_iterate_in_directory_ = std::move(failed_to_iterate_in_directory);
    return *this;
  }
  /// Sets `failed_to_iterate_in_directory` (no 132) and returns `*this`.
  LogData&& set_failed_to_iterate_in_directory(logs::FailedToIterateInDirectory&& failed_to_iterate_in_directory) && noexcept {
    return std::move(set_failed_to_iterate_in_directory(std::move(failed_to_iterate_in_directory)));
  }

  // Field `map_based_calibration_without_map_loading` (no 133).
  // -----

  /// No documentation.
  ///
  /// Field no: 133.
  constexpr const logs::MapBasedCalibrationWithoutMapLoading& map_based_calibration_without_map_loading() const& noexcept HORUS_LIFETIME_BOUND {
    return map_based_calibration_without_map_loading_;
  }

  /// If `map_based_calibration_without_map_loading` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 133.
  logs::MapBasedCalibrationWithoutMapLoading map_based_calibration_without_map_loading() && noexcept {
    if (!set_fields_[138]) {
      return {};
    }
    return std::move(map_based_calibration_without_map_loading_);
  }

  /// No documentation.
  ///
  /// Field no: 133.
  logs::MapBasedCalibrationWithoutMapLoading& mutable_map_based_calibration_without_map_loading() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kMapBasedCalibrationWithoutMapLoading;
    set_fields_[138] = true;
    return map_based_calibration_without_map_loading_;
  }

  /// Returns whether `map_based_calibration_without_map_loading` (no 133) is set.
  constexpr bool has_map_based_calibration_without_map_loading() const noexcept { return set_fields_[138]; }

  /// Clears `map_based_calibration_without_map_loading` (no 133).
  void clear_map_based_calibration_without_map_loading() & noexcept {
    data_ = {};
    set_fields_[138] = false;
    map_based_calibration_without_map_loading_ = {};
  }

  /// Sets `map_based_calibration_without_map_loading` (no 133) and returns `*this`.
  LogData& set_map_based_calibration_without_map_loading(logs::MapBasedCalibrationWithoutMapLoading&& map_based_calibration_without_map_loading) & noexcept {
    clear_data();
    data_ = DataOneof::kMapBasedCalibrationWithoutMapLoading;
    set_fields_[138] = true;
    map_based_calibration_without_map_loading_ = std::move(map_based_calibration_without_map_loading);
    return *this;
  }
  /// Sets `map_based_calibration_without_map_loading` (no 133) and returns `*this`.
  LogData&& set_map_based_calibration_without_map_loading(logs::MapBasedCalibrationWithoutMapLoading&& map_based_calibration_without_map_loading) && noexcept {
    return std::move(set_map_based_calibration_without_map_loading(std::move(map_based_calibration_without_map_loading)));
  }

  // Field `map_based_calibration_already_running` (no 134).
  // -----

  /// No documentation.
  ///
  /// Field no: 134.
  constexpr const logs::MapBasedCalibrationAlreadyRunning& map_based_calibration_already_running() const& noexcept HORUS_LIFETIME_BOUND {
    return map_based_calibration_already_running_;
  }

  /// If `map_based_calibration_already_running` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 134.
  logs::MapBasedCalibrationAlreadyRunning map_based_calibration_already_running() && noexcept {
    if (!set_fields_[139]) {
      return {};
    }
    return std::move(map_based_calibration_already_running_);
  }

  /// No documentation.
  ///
  /// Field no: 134.
  logs::MapBasedCalibrationAlreadyRunning& mutable_map_based_calibration_already_running() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kMapBasedCalibrationAlreadyRunning;
    set_fields_[139] = true;
    return map_based_calibration_already_running_;
  }

  /// Returns whether `map_based_calibration_already_running` (no 134) is set.
  constexpr bool has_map_based_calibration_already_running() const noexcept { return set_fields_[139]; }

  /// Clears `map_based_calibration_already_running` (no 134).
  void clear_map_based_calibration_already_running() & noexcept {
    data_ = {};
    set_fields_[139] = false;
    map_based_calibration_already_running_ = {};
  }

  /// Sets `map_based_calibration_already_running` (no 134) and returns `*this`.
  LogData& set_map_based_calibration_already_running(logs::MapBasedCalibrationAlreadyRunning&& map_based_calibration_already_running) & noexcept {
    clear_data();
    data_ = DataOneof::kMapBasedCalibrationAlreadyRunning;
    set_fields_[139] = true;
    map_based_calibration_already_running_ = std::move(map_based_calibration_already_running);
    return *this;
  }
  /// Sets `map_based_calibration_already_running` (no 134) and returns `*this`.
  LogData&& set_map_based_calibration_already_running(logs::MapBasedCalibrationAlreadyRunning&& map_based_calibration_already_running) && noexcept {
    return std::move(set_map_based_calibration_already_running(std::move(map_based_calibration_already_running)));
  }

  // Field `cancel_map_based_calibration_not_running` (no 135).
  // -----

  /// No documentation.
  ///
  /// Field no: 135.
  constexpr const logs::CancelMapBasedCalibrationNotRunning& cancel_map_based_calibration_not_running() const& noexcept HORUS_LIFETIME_BOUND {
    return cancel_map_based_calibration_not_running_;
  }

  /// If `cancel_map_based_calibration_not_running` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 135.
  logs::CancelMapBasedCalibrationNotRunning cancel_map_based_calibration_not_running() && noexcept {
    if (!set_fields_[140]) {
      return {};
    }
    return std::move(cancel_map_based_calibration_not_running_);
  }

  /// No documentation.
  ///
  /// Field no: 135.
  logs::CancelMapBasedCalibrationNotRunning& mutable_cancel_map_based_calibration_not_running() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCancelMapBasedCalibrationNotRunning;
    set_fields_[140] = true;
    return cancel_map_based_calibration_not_running_;
  }

  /// Returns whether `cancel_map_based_calibration_not_running` (no 135) is set.
  constexpr bool has_cancel_map_based_calibration_not_running() const noexcept { return set_fields_[140]; }

  /// Clears `cancel_map_based_calibration_not_running` (no 135).
  void clear_cancel_map_based_calibration_not_running() & noexcept {
    data_ = {};
    set_fields_[140] = false;
    cancel_map_based_calibration_not_running_ = {};
  }

  /// Sets `cancel_map_based_calibration_not_running` (no 135) and returns `*this`.
  LogData& set_cancel_map_based_calibration_not_running(logs::CancelMapBasedCalibrationNotRunning&& cancel_map_based_calibration_not_running) & noexcept {
    clear_data();
    data_ = DataOneof::kCancelMapBasedCalibrationNotRunning;
    set_fields_[140] = true;
    cancel_map_based_calibration_not_running_ = std::move(cancel_map_based_calibration_not_running);
    return *this;
  }
  /// Sets `cancel_map_based_calibration_not_running` (no 135) and returns `*this`.
  LogData&& set_cancel_map_based_calibration_not_running(logs::CancelMapBasedCalibrationNotRunning&& cancel_map_based_calibration_not_running) && noexcept {
    return std::move(set_cancel_map_based_calibration_not_running(std::move(cancel_map_based_calibration_not_running)));
  }

  // Field `bag_stream_not_found` (no 136).
  // -----

  /// No documentation.
  ///
  /// Field no: 136.
  constexpr const logs::BagStreamNotFound& bag_stream_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_stream_not_found_;
  }

  /// If `bag_stream_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 136.
  logs::BagStreamNotFound bag_stream_not_found() && noexcept {
    if (!set_fields_[141]) {
      return {};
    }
    return std::move(bag_stream_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 136.
  logs::BagStreamNotFound& mutable_bag_stream_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagStreamNotFound;
    set_fields_[141] = true;
    return bag_stream_not_found_;
  }

  /// Returns whether `bag_stream_not_found` (no 136) is set.
  constexpr bool has_bag_stream_not_found() const noexcept { return set_fields_[141]; }

  /// Clears `bag_stream_not_found` (no 136).
  void clear_bag_stream_not_found() & noexcept {
    data_ = {};
    set_fields_[141] = false;
    bag_stream_not_found_ = {};
  }

  /// Sets `bag_stream_not_found` (no 136) and returns `*this`.
  LogData& set_bag_stream_not_found(logs::BagStreamNotFound&& bag_stream_not_found) & noexcept {
    clear_data();
    data_ = DataOneof::kBagStreamNotFound;
    set_fields_[141] = true;
    bag_stream_not_found_ = std::move(bag_stream_not_found);
    return *this;
  }
  /// Sets `bag_stream_not_found` (no 136) and returns `*this`.
  LogData&& set_bag_stream_not_found(logs::BagStreamNotFound&& bag_stream_not_found) && noexcept {
    return std::move(set_bag_stream_not_found(std::move(bag_stream_not_found)));
  }

  // Field `evaluation_bag_started_info` (no 137).
  // -----

  /// No documentation.
  ///
  /// Field no: 137.
  constexpr const logs::EvaluationBagStartedInfo& evaluation_bag_started_info() const& noexcept HORUS_LIFETIME_BOUND {
    return evaluation_bag_started_info_;
  }

  /// If `evaluation_bag_started_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 137.
  logs::EvaluationBagStartedInfo evaluation_bag_started_info() && noexcept {
    if (!set_fields_[142]) {
      return {};
    }
    return std::move(evaluation_bag_started_info_);
  }

  /// No documentation.
  ///
  /// Field no: 137.
  logs::EvaluationBagStartedInfo& mutable_evaluation_bag_started_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kEvaluationBagStartedInfo;
    set_fields_[142] = true;
    return evaluation_bag_started_info_;
  }

  /// Returns whether `evaluation_bag_started_info` (no 137) is set.
  constexpr bool has_evaluation_bag_started_info() const noexcept { return set_fields_[142]; }

  /// Clears `evaluation_bag_started_info` (no 137).
  void clear_evaluation_bag_started_info() & noexcept {
    data_ = {};
    set_fields_[142] = false;
    evaluation_bag_started_info_ = {};
  }

  /// Sets `evaluation_bag_started_info` (no 137) and returns `*this`.
  LogData& set_evaluation_bag_started_info(logs::EvaluationBagStartedInfo&& evaluation_bag_started_info) & noexcept {
    clear_data();
    data_ = DataOneof::kEvaluationBagStartedInfo;
    set_fields_[142] = true;
    evaluation_bag_started_info_ = std::move(evaluation_bag_started_info);
    return *this;
  }
  /// Sets `evaluation_bag_started_info` (no 137) and returns `*this`.
  LogData&& set_evaluation_bag_started_info(logs::EvaluationBagStartedInfo&& evaluation_bag_started_info) && noexcept {
    return std::move(set_evaluation_bag_started_info(std::move(evaluation_bag_started_info)));
  }

  // Field `evaluation_bag_finished_info` (no 138).
  // -----

  /// No documentation.
  ///
  /// Field no: 138.
  constexpr const logs::EvaluationBagFinishedInfo& evaluation_bag_finished_info() const& noexcept HORUS_LIFETIME_BOUND {
    return evaluation_bag_finished_info_;
  }

  /// If `evaluation_bag_finished_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 138.
  logs::EvaluationBagFinishedInfo evaluation_bag_finished_info() && noexcept {
    if (!set_fields_[143]) {
      return {};
    }
    return std::move(evaluation_bag_finished_info_);
  }

  /// No documentation.
  ///
  /// Field no: 138.
  logs::EvaluationBagFinishedInfo& mutable_evaluation_bag_finished_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kEvaluationBagFinishedInfo;
    set_fields_[143] = true;
    return evaluation_bag_finished_info_;
  }

  /// Returns whether `evaluation_bag_finished_info` (no 138) is set.
  constexpr bool has_evaluation_bag_finished_info() const noexcept { return set_fields_[143]; }

  /// Clears `evaluation_bag_finished_info` (no 138).
  void clear_evaluation_bag_finished_info() & noexcept {
    data_ = {};
    set_fields_[143] = false;
    evaluation_bag_finished_info_ = {};
  }

  /// Sets `evaluation_bag_finished_info` (no 138) and returns `*this`.
  LogData& set_evaluation_bag_finished_info(logs::EvaluationBagFinishedInfo&& evaluation_bag_finished_info) & noexcept {
    clear_data();
    data_ = DataOneof::kEvaluationBagFinishedInfo;
    set_fields_[143] = true;
    evaluation_bag_finished_info_ = std::move(evaluation_bag_finished_info);
    return *this;
  }
  /// Sets `evaluation_bag_finished_info` (no 138) and returns `*this`.
  LogData&& set_evaluation_bag_finished_info(logs::EvaluationBagFinishedInfo&& evaluation_bag_finished_info) && noexcept {
    return std::move(set_evaluation_bag_finished_info(std::move(evaluation_bag_finished_info)));
  }

  // Field `bag_not_found` (no 139).
  // -----

  /// No documentation.
  ///
  /// Field no: 139.
  constexpr const logs::BagNotFound& bag_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_not_found_;
  }

  /// If `bag_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 139.
  logs::BagNotFound bag_not_found() && noexcept {
    if (!set_fields_[144]) {
      return {};
    }
    return std::move(bag_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 139.
  logs::BagNotFound& mutable_bag_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagNotFound;
    set_fields_[144] = true;
    return bag_not_found_;
  }

  /// Returns whether `bag_not_found` (no 139) is set.
  constexpr bool has_bag_not_found() const noexcept { return set_fields_[144]; }

  /// Clears `bag_not_found` (no 139).
  void clear_bag_not_found() & noexcept {
    data_ = {};
    set_fields_[144] = false;
    bag_not_found_ = {};
  }

  /// Sets `bag_not_found` (no 139) and returns `*this`.
  LogData& set_bag_not_found(logs::BagNotFound&& bag_not_found) & noexcept {
    clear_data();
    data_ = DataOneof::kBagNotFound;
    set_fields_[144] = true;
    bag_not_found_ = std::move(bag_not_found);
    return *this;
  }
  /// Sets `bag_not_found` (no 139) and returns `*this`.
  LogData&& set_bag_not_found(logs::BagNotFound&& bag_not_found) && noexcept {
    return std::move(set_bag_not_found(std::move(bag_not_found)));
  }

  // Field `building_pipeline_info` (no 140).
  // -----

  /// No documentation.
  ///
  /// Field no: 140.
  constexpr const logs::BuildingPipelineInfo& building_pipeline_info() const& noexcept HORUS_LIFETIME_BOUND {
    return building_pipeline_info_;
  }

  /// If `building_pipeline_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 140.
  logs::BuildingPipelineInfo building_pipeline_info() && noexcept {
    if (!set_fields_[145]) {
      return {};
    }
    return std::move(building_pipeline_info_);
  }

  /// No documentation.
  ///
  /// Field no: 140.
  logs::BuildingPipelineInfo& mutable_building_pipeline_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBuildingPipelineInfo;
    set_fields_[145] = true;
    return building_pipeline_info_;
  }

  /// Returns whether `building_pipeline_info` (no 140) is set.
  constexpr bool has_building_pipeline_info() const noexcept { return set_fields_[145]; }

  /// Clears `building_pipeline_info` (no 140).
  void clear_building_pipeline_info() & noexcept {
    data_ = {};
    set_fields_[145] = false;
    building_pipeline_info_ = {};
  }

  /// Sets `building_pipeline_info` (no 140) and returns `*this`.
  LogData& set_building_pipeline_info(logs::BuildingPipelineInfo&& building_pipeline_info) & noexcept {
    clear_data();
    data_ = DataOneof::kBuildingPipelineInfo;
    set_fields_[145] = true;
    building_pipeline_info_ = std::move(building_pipeline_info);
    return *this;
  }
  /// Sets `building_pipeline_info` (no 140) and returns `*this`.
  LogData&& set_building_pipeline_info(logs::BuildingPipelineInfo&& building_pipeline_info) && noexcept {
    return std::move(set_building_pipeline_info(std::move(building_pipeline_info)));
  }

  // Field `bag_is_not_evaluation` (no 141).
  // -----

  /// No documentation.
  ///
  /// Field no: 141.
  constexpr const logs::BagIsNotEvaluation& bag_is_not_evaluation() const& noexcept HORUS_LIFETIME_BOUND {
    return bag_is_not_evaluation_;
  }

  /// If `bag_is_not_evaluation` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 141.
  logs::BagIsNotEvaluation bag_is_not_evaluation() && noexcept {
    if (!set_fields_[146]) {
      return {};
    }
    return std::move(bag_is_not_evaluation_);
  }

  /// No documentation.
  ///
  /// Field no: 141.
  logs::BagIsNotEvaluation& mutable_bag_is_not_evaluation() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kBagIsNotEvaluation;
    set_fields_[146] = true;
    return bag_is_not_evaluation_;
  }

  /// Returns whether `bag_is_not_evaluation` (no 141) is set.
  constexpr bool has_bag_is_not_evaluation() const noexcept { return set_fields_[146]; }

  /// Clears `bag_is_not_evaluation` (no 141).
  void clear_bag_is_not_evaluation() & noexcept {
    data_ = {};
    set_fields_[146] = false;
    bag_is_not_evaluation_ = {};
  }

  /// Sets `bag_is_not_evaluation` (no 141) and returns `*this`.
  LogData& set_bag_is_not_evaluation(logs::BagIsNotEvaluation&& bag_is_not_evaluation) & noexcept {
    clear_data();
    data_ = DataOneof::kBagIsNotEvaluation;
    set_fields_[146] = true;
    bag_is_not_evaluation_ = std::move(bag_is_not_evaluation);
    return *this;
  }
  /// Sets `bag_is_not_evaluation` (no 141) and returns `*this`.
  LogData&& set_bag_is_not_evaluation(logs::BagIsNotEvaluation&& bag_is_not_evaluation) && noexcept {
    return std::move(set_bag_is_not_evaluation(std::move(bag_is_not_evaluation)));
  }

  // Field `horus_bag_running` (no 142).
  // -----

  /// No documentation.
  ///
  /// Field no: 142.
  constexpr const logs::HorusBagRunning& horus_bag_running() const& noexcept HORUS_LIFETIME_BOUND {
    return horus_bag_running_;
  }

  /// If `horus_bag_running` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 142.
  logs::HorusBagRunning horus_bag_running() && noexcept {
    if (!set_fields_[147]) {
      return {};
    }
    return std::move(horus_bag_running_);
  }

  /// No documentation.
  ///
  /// Field no: 142.
  logs::HorusBagRunning& mutable_horus_bag_running() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kHorusBagRunning;
    set_fields_[147] = true;
    return horus_bag_running_;
  }

  /// Returns whether `horus_bag_running` (no 142) is set.
  constexpr bool has_horus_bag_running() const noexcept { return set_fields_[147]; }

  /// Clears `horus_bag_running` (no 142).
  void clear_horus_bag_running() & noexcept {
    data_ = {};
    set_fields_[147] = false;
    horus_bag_running_ = {};
  }

  /// Sets `horus_bag_running` (no 142) and returns `*this`.
  LogData& set_horus_bag_running(logs::HorusBagRunning&& horus_bag_running) & noexcept {
    clear_data();
    data_ = DataOneof::kHorusBagRunning;
    set_fields_[147] = true;
    horus_bag_running_ = std::move(horus_bag_running);
    return *this;
  }
  /// Sets `horus_bag_running` (no 142) and returns `*this`.
  LogData&& set_horus_bag_running(logs::HorusBagRunning&& horus_bag_running) && noexcept {
    return std::move(set_horus_bag_running(std::move(horus_bag_running)));
  }

  // Field `auto_ground_calibration_warning` (no 143).
  // -----

  /// No documentation.
  ///
  /// Field no: 143.
  constexpr const logs::AutoGroundCalibrationWarning& auto_ground_calibration_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return auto_ground_calibration_warning_;
  }

  /// If `auto_ground_calibration_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 143.
  logs::AutoGroundCalibrationWarning auto_ground_calibration_warning() && noexcept {
    if (!set_fields_[148]) {
      return {};
    }
    return std::move(auto_ground_calibration_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 143.
  logs::AutoGroundCalibrationWarning& mutable_auto_ground_calibration_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kAutoGroundCalibrationWarning;
    set_fields_[148] = true;
    return auto_ground_calibration_warning_;
  }

  /// Returns whether `auto_ground_calibration_warning` (no 143) is set.
  constexpr bool has_auto_ground_calibration_warning() const noexcept { return set_fields_[148]; }

  /// Clears `auto_ground_calibration_warning` (no 143).
  void clear_auto_ground_calibration_warning() & noexcept {
    data_ = {};
    set_fields_[148] = false;
    auto_ground_calibration_warning_ = {};
  }

  /// Sets `auto_ground_calibration_warning` (no 143) and returns `*this`.
  LogData& set_auto_ground_calibration_warning(logs::AutoGroundCalibrationWarning&& auto_ground_calibration_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kAutoGroundCalibrationWarning;
    set_fields_[148] = true;
    auto_ground_calibration_warning_ = std::move(auto_ground_calibration_warning);
    return *this;
  }
  /// Sets `auto_ground_calibration_warning` (no 143) and returns `*this`.
  LogData&& set_auto_ground_calibration_warning(logs::AutoGroundCalibrationWarning&& auto_ground_calibration_warning) && noexcept {
    return std::move(set_auto_ground_calibration_warning(std::move(auto_ground_calibration_warning)));
  }

  // Field `auto_ground_calibration_error` (no 144).
  // -----

  /// No documentation.
  ///
  /// Field no: 144.
  constexpr const logs::AutoGroundCalibrationError& auto_ground_calibration_error() const& noexcept HORUS_LIFETIME_BOUND {
    return auto_ground_calibration_error_;
  }

  /// If `auto_ground_calibration_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 144.
  logs::AutoGroundCalibrationError auto_ground_calibration_error() && noexcept {
    if (!set_fields_[149]) {
      return {};
    }
    return std::move(auto_ground_calibration_error_);
  }

  /// No documentation.
  ///
  /// Field no: 144.
  logs::AutoGroundCalibrationError& mutable_auto_ground_calibration_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kAutoGroundCalibrationError;
    set_fields_[149] = true;
    return auto_ground_calibration_error_;
  }

  /// Returns whether `auto_ground_calibration_error` (no 144) is set.
  constexpr bool has_auto_ground_calibration_error() const noexcept { return set_fields_[149]; }

  /// Clears `auto_ground_calibration_error` (no 144).
  void clear_auto_ground_calibration_error() & noexcept {
    data_ = {};
    set_fields_[149] = false;
    auto_ground_calibration_error_ = {};
  }

  /// Sets `auto_ground_calibration_error` (no 144) and returns `*this`.
  LogData& set_auto_ground_calibration_error(logs::AutoGroundCalibrationError&& auto_ground_calibration_error) & noexcept {
    clear_data();
    data_ = DataOneof::kAutoGroundCalibrationError;
    set_fields_[149] = true;
    auto_ground_calibration_error_ = std::move(auto_ground_calibration_error);
    return *this;
  }
  /// Sets `auto_ground_calibration_error` (no 144) and returns `*this`.
  LogData&& set_auto_ground_calibration_error(logs::AutoGroundCalibrationError&& auto_ground_calibration_error) && noexcept {
    return std::move(set_auto_ground_calibration_error(std::move(auto_ground_calibration_error)));
  }

  // Field `object_detector_not_loaded_warning` (no 151).
  // -----

  /// No documentation.
  ///
  /// Field no: 151.
  constexpr const logs::ObjectDetectorNotLoadedWarning& object_detector_not_loaded_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return object_detector_not_loaded_warning_;
  }

  /// If `object_detector_not_loaded_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 151.
  logs::ObjectDetectorNotLoadedWarning object_detector_not_loaded_warning() && noexcept {
    if (!set_fields_[150]) {
      return {};
    }
    return std::move(object_detector_not_loaded_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 151.
  logs::ObjectDetectorNotLoadedWarning& mutable_object_detector_not_loaded_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kObjectDetectorNotLoadedWarning;
    set_fields_[150] = true;
    return object_detector_not_loaded_warning_;
  }

  /// Returns whether `object_detector_not_loaded_warning` (no 151) is set.
  constexpr bool has_object_detector_not_loaded_warning() const noexcept { return set_fields_[150]; }

  /// Clears `object_detector_not_loaded_warning` (no 151).
  void clear_object_detector_not_loaded_warning() & noexcept {
    data_ = {};
    set_fields_[150] = false;
    object_detector_not_loaded_warning_ = {};
  }

  /// Sets `object_detector_not_loaded_warning` (no 151) and returns `*this`.
  LogData& set_object_detector_not_loaded_warning(logs::ObjectDetectorNotLoadedWarning&& object_detector_not_loaded_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kObjectDetectorNotLoadedWarning;
    set_fields_[150] = true;
    object_detector_not_loaded_warning_ = std::move(object_detector_not_loaded_warning);
    return *this;
  }
  /// Sets `object_detector_not_loaded_warning` (no 151) and returns `*this`.
  LogData&& set_object_detector_not_loaded_warning(logs::ObjectDetectorNotLoadedWarning&& object_detector_not_loaded_warning) && noexcept {
    return std::move(set_object_detector_not_loaded_warning(std::move(object_detector_not_loaded_warning)));
  }

  // Field `calibration_is_running_error` (no 152).
  // -----

  /// No documentation.
  ///
  /// Field no: 152.
  constexpr const logs::CalibrationIsRunningError& calibration_is_running_error() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_is_running_error_;
  }

  /// If `calibration_is_running_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 152.
  logs::CalibrationIsRunningError calibration_is_running_error() && noexcept {
    if (!set_fields_[151]) {
      return {};
    }
    return std::move(calibration_is_running_error_);
  }

  /// No documentation.
  ///
  /// Field no: 152.
  logs::CalibrationIsRunningError& mutable_calibration_is_running_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationIsRunningError;
    set_fields_[151] = true;
    return calibration_is_running_error_;
  }

  /// Returns whether `calibration_is_running_error` (no 152) is set.
  constexpr bool has_calibration_is_running_error() const noexcept { return set_fields_[151]; }

  /// Clears `calibration_is_running_error` (no 152).
  void clear_calibration_is_running_error() & noexcept {
    data_ = {};
    set_fields_[151] = false;
    calibration_is_running_error_ = {};
  }

  /// Sets `calibration_is_running_error` (no 152) and returns `*this`.
  LogData& set_calibration_is_running_error(logs::CalibrationIsRunningError&& calibration_is_running_error) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationIsRunningError;
    set_fields_[151] = true;
    calibration_is_running_error_ = std::move(calibration_is_running_error);
    return *this;
  }
  /// Sets `calibration_is_running_error` (no 152) and returns `*this`.
  LogData&& set_calibration_is_running_error(logs::CalibrationIsRunningError&& calibration_is_running_error) && noexcept {
    return std::move(set_calibration_is_running_error(std::move(calibration_is_running_error)));
  }

  // Field `model_init_in_progress_info` (no 153).
  // -----

  /// No documentation.
  ///
  /// Field no: 153.
  constexpr const logs::ModelInitInProgressInfo& model_init_in_progress_info() const& noexcept HORUS_LIFETIME_BOUND {
    return model_init_in_progress_info_;
  }

  /// If `model_init_in_progress_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 153.
  logs::ModelInitInProgressInfo model_init_in_progress_info() && noexcept {
    if (!set_fields_[152]) {
      return {};
    }
    return std::move(model_init_in_progress_info_);
  }

  /// No documentation.
  ///
  /// Field no: 153.
  logs::ModelInitInProgressInfo& mutable_model_init_in_progress_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kModelInitInProgressInfo;
    set_fields_[152] = true;
    return model_init_in_progress_info_;
  }

  /// Returns whether `model_init_in_progress_info` (no 153) is set.
  constexpr bool has_model_init_in_progress_info() const noexcept { return set_fields_[152]; }

  /// Clears `model_init_in_progress_info` (no 153).
  void clear_model_init_in_progress_info() & noexcept {
    data_ = {};
    set_fields_[152] = false;
    model_init_in_progress_info_ = {};
  }

  /// Sets `model_init_in_progress_info` (no 153) and returns `*this`.
  LogData& set_model_init_in_progress_info(logs::ModelInitInProgressInfo&& model_init_in_progress_info) & noexcept {
    clear_data();
    data_ = DataOneof::kModelInitInProgressInfo;
    set_fields_[152] = true;
    model_init_in_progress_info_ = std::move(model_init_in_progress_info);
    return *this;
  }
  /// Sets `model_init_in_progress_info` (no 153) and returns `*this`.
  LogData&& set_model_init_in_progress_info(logs::ModelInitInProgressInfo&& model_init_in_progress_info) && noexcept {
    return std::move(set_model_init_in_progress_info(std::move(model_init_in_progress_info)));
  }

  // Field `rpc_timeout_with_resolution_warning` (no 154).
  // -----

  /// No documentation.
  ///
  /// Field no: 154.
  constexpr const logs::RpcTimeoutWithResolutionWarning& rpc_timeout_with_resolution_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return rpc_timeout_with_resolution_warning_;
  }

  /// If `rpc_timeout_with_resolution_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 154.
  logs::RpcTimeoutWithResolutionWarning rpc_timeout_with_resolution_warning() && noexcept {
    if (!set_fields_[153]) {
      return {};
    }
    return std::move(rpc_timeout_with_resolution_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 154.
  logs::RpcTimeoutWithResolutionWarning& mutable_rpc_timeout_with_resolution_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kRpcTimeoutWithResolutionWarning;
    set_fields_[153] = true;
    return rpc_timeout_with_resolution_warning_;
  }

  /// Returns whether `rpc_timeout_with_resolution_warning` (no 154) is set.
  constexpr bool has_rpc_timeout_with_resolution_warning() const noexcept { return set_fields_[153]; }

  /// Clears `rpc_timeout_with_resolution_warning` (no 154).
  void clear_rpc_timeout_with_resolution_warning() & noexcept {
    data_ = {};
    set_fields_[153] = false;
    rpc_timeout_with_resolution_warning_ = {};
  }

  /// Sets `rpc_timeout_with_resolution_warning` (no 154) and returns `*this`.
  LogData& set_rpc_timeout_with_resolution_warning(logs::RpcTimeoutWithResolutionWarning&& rpc_timeout_with_resolution_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kRpcTimeoutWithResolutionWarning;
    set_fields_[153] = true;
    rpc_timeout_with_resolution_warning_ = std::move(rpc_timeout_with_resolution_warning);
    return *this;
  }
  /// Sets `rpc_timeout_with_resolution_warning` (no 154) and returns `*this`.
  LogData&& set_rpc_timeout_with_resolution_warning(logs::RpcTimeoutWithResolutionWarning&& rpc_timeout_with_resolution_warning) && noexcept {
    return std::move(set_rpc_timeout_with_resolution_warning(std::move(rpc_timeout_with_resolution_warning)));
  }

  // Field `calibration_was_cancelled_info` (no 155).
  // -----

  /// No documentation.
  ///
  /// Field no: 155.
  constexpr const logs::CalibrationWasCancelledInfo& calibration_was_cancelled_info() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_was_cancelled_info_;
  }

  /// If `calibration_was_cancelled_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 155.
  logs::CalibrationWasCancelledInfo calibration_was_cancelled_info() && noexcept {
    if (!set_fields_[154]) {
      return {};
    }
    return std::move(calibration_was_cancelled_info_);
  }

  /// No documentation.
  ///
  /// Field no: 155.
  logs::CalibrationWasCancelledInfo& mutable_calibration_was_cancelled_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationWasCancelledInfo;
    set_fields_[154] = true;
    return calibration_was_cancelled_info_;
  }

  /// Returns whether `calibration_was_cancelled_info` (no 155) is set.
  constexpr bool has_calibration_was_cancelled_info() const noexcept { return set_fields_[154]; }

  /// Clears `calibration_was_cancelled_info` (no 155).
  void clear_calibration_was_cancelled_info() & noexcept {
    data_ = {};
    set_fields_[154] = false;
    calibration_was_cancelled_info_ = {};
  }

  /// Sets `calibration_was_cancelled_info` (no 155) and returns `*this`.
  LogData& set_calibration_was_cancelled_info(logs::CalibrationWasCancelledInfo&& calibration_was_cancelled_info) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationWasCancelledInfo;
    set_fields_[154] = true;
    calibration_was_cancelled_info_ = std::move(calibration_was_cancelled_info);
    return *this;
  }
  /// Sets `calibration_was_cancelled_info` (no 155) and returns `*this`.
  LogData&& set_calibration_was_cancelled_info(logs::CalibrationWasCancelledInfo&& calibration_was_cancelled_info) && noexcept {
    return std::move(set_calibration_was_cancelled_info(std::move(calibration_was_cancelled_info)));
  }

  // Field `calibration_map_recording_failed_to_start` (no 156).
  // -----

  /// No documentation.
  ///
  /// Field no: 156.
  constexpr const logs::CalibrationMapRecordingFailedToStart& calibration_map_recording_failed_to_start() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_map_recording_failed_to_start_;
  }

  /// If `calibration_map_recording_failed_to_start` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 156.
  logs::CalibrationMapRecordingFailedToStart calibration_map_recording_failed_to_start() && noexcept {
    if (!set_fields_[155]) {
      return {};
    }
    return std::move(calibration_map_recording_failed_to_start_);
  }

  /// No documentation.
  ///
  /// Field no: 156.
  logs::CalibrationMapRecordingFailedToStart& mutable_calibration_map_recording_failed_to_start() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationMapRecordingFailedToStart;
    set_fields_[155] = true;
    return calibration_map_recording_failed_to_start_;
  }

  /// Returns whether `calibration_map_recording_failed_to_start` (no 156) is set.
  constexpr bool has_calibration_map_recording_failed_to_start() const noexcept { return set_fields_[155]; }

  /// Clears `calibration_map_recording_failed_to_start` (no 156).
  void clear_calibration_map_recording_failed_to_start() & noexcept {
    data_ = {};
    set_fields_[155] = false;
    calibration_map_recording_failed_to_start_ = {};
  }

  /// Sets `calibration_map_recording_failed_to_start` (no 156) and returns `*this`.
  LogData& set_calibration_map_recording_failed_to_start(logs::CalibrationMapRecordingFailedToStart&& calibration_map_recording_failed_to_start) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationMapRecordingFailedToStart;
    set_fields_[155] = true;
    calibration_map_recording_failed_to_start_ = std::move(calibration_map_recording_failed_to_start);
    return *this;
  }
  /// Sets `calibration_map_recording_failed_to_start` (no 156) and returns `*this`.
  LogData&& set_calibration_map_recording_failed_to_start(logs::CalibrationMapRecordingFailedToStart&& calibration_map_recording_failed_to_start) && noexcept {
    return std::move(set_calibration_map_recording_failed_to_start(std::move(calibration_map_recording_failed_to_start)));
  }

  // Field `detection_pipeline_requested_reset_info` (no 157).
  // -----

  /// No documentation.
  ///
  /// Field no: 157.
  constexpr const logs::DetectionPipelineRequestedResetInfo& detection_pipeline_requested_reset_info() const& noexcept HORUS_LIFETIME_BOUND {
    return detection_pipeline_requested_reset_info_;
  }

  /// If `detection_pipeline_requested_reset_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 157.
  logs::DetectionPipelineRequestedResetInfo detection_pipeline_requested_reset_info() && noexcept {
    if (!set_fields_[156]) {
      return {};
    }
    return std::move(detection_pipeline_requested_reset_info_);
  }

  /// No documentation.
  ///
  /// Field no: 157.
  logs::DetectionPipelineRequestedResetInfo& mutable_detection_pipeline_requested_reset_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kDetectionPipelineRequestedResetInfo;
    set_fields_[156] = true;
    return detection_pipeline_requested_reset_info_;
  }

  /// Returns whether `detection_pipeline_requested_reset_info` (no 157) is set.
  constexpr bool has_detection_pipeline_requested_reset_info() const noexcept { return set_fields_[156]; }

  /// Clears `detection_pipeline_requested_reset_info` (no 157).
  void clear_detection_pipeline_requested_reset_info() & noexcept {
    data_ = {};
    set_fields_[156] = false;
    detection_pipeline_requested_reset_info_ = {};
  }

  /// Sets `detection_pipeline_requested_reset_info` (no 157) and returns `*this`.
  LogData& set_detection_pipeline_requested_reset_info(logs::DetectionPipelineRequestedResetInfo&& detection_pipeline_requested_reset_info) & noexcept {
    clear_data();
    data_ = DataOneof::kDetectionPipelineRequestedResetInfo;
    set_fields_[156] = true;
    detection_pipeline_requested_reset_info_ = std::move(detection_pipeline_requested_reset_info);
    return *this;
  }
  /// Sets `detection_pipeline_requested_reset_info` (no 157) and returns `*this`.
  LogData&& set_detection_pipeline_requested_reset_info(logs::DetectionPipelineRequestedResetInfo&& detection_pipeline_requested_reset_info) && noexcept {
    return std::move(set_detection_pipeline_requested_reset_info(std::move(detection_pipeline_requested_reset_info)));
  }

  // Field `preprocessing_service_pipeline_unavailable` (no 158).
  // -----

  /// No documentation.
  ///
  /// Field no: 158.
  constexpr const logs::PreprocessingServicePipelineUnavailable& preprocessing_service_pipeline_unavailable() const& noexcept HORUS_LIFETIME_BOUND {
    return preprocessing_service_pipeline_unavailable_;
  }

  /// If `preprocessing_service_pipeline_unavailable` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 158.
  logs::PreprocessingServicePipelineUnavailable preprocessing_service_pipeline_unavailable() && noexcept {
    if (!set_fields_[157]) {
      return {};
    }
    return std::move(preprocessing_service_pipeline_unavailable_);
  }

  /// No documentation.
  ///
  /// Field no: 158.
  logs::PreprocessingServicePipelineUnavailable& mutable_preprocessing_service_pipeline_unavailable() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kPreprocessingServicePipelineUnavailable;
    set_fields_[157] = true;
    return preprocessing_service_pipeline_unavailable_;
  }

  /// Returns whether `preprocessing_service_pipeline_unavailable` (no 158) is set.
  constexpr bool has_preprocessing_service_pipeline_unavailable() const noexcept { return set_fields_[157]; }

  /// Clears `preprocessing_service_pipeline_unavailable` (no 158).
  void clear_preprocessing_service_pipeline_unavailable() & noexcept {
    data_ = {};
    set_fields_[157] = false;
    preprocessing_service_pipeline_unavailable_ = {};
  }

  /// Sets `preprocessing_service_pipeline_unavailable` (no 158) and returns `*this`.
  LogData& set_preprocessing_service_pipeline_unavailable(logs::PreprocessingServicePipelineUnavailable&& preprocessing_service_pipeline_unavailable) & noexcept {
    clear_data();
    data_ = DataOneof::kPreprocessingServicePipelineUnavailable;
    set_fields_[157] = true;
    preprocessing_service_pipeline_unavailable_ = std::move(preprocessing_service_pipeline_unavailable);
    return *this;
  }
  /// Sets `preprocessing_service_pipeline_unavailable` (no 158) and returns `*this`.
  LogData&& set_preprocessing_service_pipeline_unavailable(logs::PreprocessingServicePipelineUnavailable&& preprocessing_service_pipeline_unavailable) && noexcept {
    return std::move(set_preprocessing_service_pipeline_unavailable(std::move(preprocessing_service_pipeline_unavailable)));
  }

  // Field `circular_recording_disabled_warning` (no 159).
  // -----

  /// No documentation.
  ///
  /// Field no: 159.
  constexpr const logs::CircularRecordingDisabledWarning& circular_recording_disabled_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return circular_recording_disabled_warning_;
  }

  /// If `circular_recording_disabled_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 159.
  logs::CircularRecordingDisabledWarning circular_recording_disabled_warning() && noexcept {
    if (!set_fields_[158]) {
      return {};
    }
    return std::move(circular_recording_disabled_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 159.
  logs::CircularRecordingDisabledWarning& mutable_circular_recording_disabled_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCircularRecordingDisabledWarning;
    set_fields_[158] = true;
    return circular_recording_disabled_warning_;
  }

  /// Returns whether `circular_recording_disabled_warning` (no 159) is set.
  constexpr bool has_circular_recording_disabled_warning() const noexcept { return set_fields_[158]; }

  /// Clears `circular_recording_disabled_warning` (no 159).
  void clear_circular_recording_disabled_warning() & noexcept {
    data_ = {};
    set_fields_[158] = false;
    circular_recording_disabled_warning_ = {};
  }

  /// Sets `circular_recording_disabled_warning` (no 159) and returns `*this`.
  LogData& set_circular_recording_disabled_warning(logs::CircularRecordingDisabledWarning&& circular_recording_disabled_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kCircularRecordingDisabledWarning;
    set_fields_[158] = true;
    circular_recording_disabled_warning_ = std::move(circular_recording_disabled_warning);
    return *this;
  }
  /// Sets `circular_recording_disabled_warning` (no 159) and returns `*this`.
  LogData&& set_circular_recording_disabled_warning(logs::CircularRecordingDisabledWarning&& circular_recording_disabled_warning) && noexcept {
    return std::move(set_circular_recording_disabled_warning(std::move(circular_recording_disabled_warning)));
  }

  // Field `snapshot_already_running_warning` (no 160).
  // -----

  /// No documentation.
  ///
  /// Field no: 160.
  constexpr const logs::SnapshotAlreadyRunningWarning& snapshot_already_running_warning() const& noexcept HORUS_LIFETIME_BOUND {
    return snapshot_already_running_warning_;
  }

  /// If `snapshot_already_running_warning` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 160.
  logs::SnapshotAlreadyRunningWarning snapshot_already_running_warning() && noexcept {
    if (!set_fields_[159]) {
      return {};
    }
    return std::move(snapshot_already_running_warning_);
  }

  /// No documentation.
  ///
  /// Field no: 160.
  logs::SnapshotAlreadyRunningWarning& mutable_snapshot_already_running_warning() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kSnapshotAlreadyRunningWarning;
    set_fields_[159] = true;
    return snapshot_already_running_warning_;
  }

  /// Returns whether `snapshot_already_running_warning` (no 160) is set.
  constexpr bool has_snapshot_already_running_warning() const noexcept { return set_fields_[159]; }

  /// Clears `snapshot_already_running_warning` (no 160).
  void clear_snapshot_already_running_warning() & noexcept {
    data_ = {};
    set_fields_[159] = false;
    snapshot_already_running_warning_ = {};
  }

  /// Sets `snapshot_already_running_warning` (no 160) and returns `*this`.
  LogData& set_snapshot_already_running_warning(logs::SnapshotAlreadyRunningWarning&& snapshot_already_running_warning) & noexcept {
    clear_data();
    data_ = DataOneof::kSnapshotAlreadyRunningWarning;
    set_fields_[159] = true;
    snapshot_already_running_warning_ = std::move(snapshot_already_running_warning);
    return *this;
  }
  /// Sets `snapshot_already_running_warning` (no 160) and returns `*this`.
  LogData&& set_snapshot_already_running_warning(logs::SnapshotAlreadyRunningWarning&& snapshot_already_running_warning) && noexcept {
    return std::move(set_snapshot_already_running_warning(std::move(snapshot_already_running_warning)));
  }

  // Field `active_project_changed_info` (no 161).
  // -----

  /// No documentation.
  ///
  /// Field no: 161.
  constexpr const logs::ActiveProjectChangedInfo& active_project_changed_info() const& noexcept HORUS_LIFETIME_BOUND {
    return active_project_changed_info_;
  }

  /// If `active_project_changed_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 161.
  logs::ActiveProjectChangedInfo active_project_changed_info() && noexcept {
    if (!set_fields_[160]) {
      return {};
    }
    return std::move(active_project_changed_info_);
  }

  /// No documentation.
  ///
  /// Field no: 161.
  logs::ActiveProjectChangedInfo& mutable_active_project_changed_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kActiveProjectChangedInfo;
    set_fields_[160] = true;
    return active_project_changed_info_;
  }

  /// Returns whether `active_project_changed_info` (no 161) is set.
  constexpr bool has_active_project_changed_info() const noexcept { return set_fields_[160]; }

  /// Clears `active_project_changed_info` (no 161).
  void clear_active_project_changed_info() & noexcept {
    data_ = {};
    set_fields_[160] = false;
    active_project_changed_info_ = {};
  }

  /// Sets `active_project_changed_info` (no 161) and returns `*this`.
  LogData& set_active_project_changed_info(logs::ActiveProjectChangedInfo&& active_project_changed_info) & noexcept {
    clear_data();
    data_ = DataOneof::kActiveProjectChangedInfo;
    set_fields_[160] = true;
    active_project_changed_info_ = std::move(active_project_changed_info);
    return *this;
  }
  /// Sets `active_project_changed_info` (no 161) and returns `*this`.
  LogData&& set_active_project_changed_info(logs::ActiveProjectChangedInfo&& active_project_changed_info) && noexcept {
    return std::move(set_active_project_changed_info(std::move(active_project_changed_info)));
  }

  // Field `project_config_updated_info` (no 162).
  // -----

  /// No documentation.
  ///
  /// Field no: 162.
  constexpr const logs::ProjectConfigUpdatedInfo& project_config_updated_info() const& noexcept HORUS_LIFETIME_BOUND {
    return project_config_updated_info_;
  }

  /// If `project_config_updated_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 162.
  logs::ProjectConfigUpdatedInfo project_config_updated_info() && noexcept {
    if (!set_fields_[161]) {
      return {};
    }
    return std::move(project_config_updated_info_);
  }

  /// No documentation.
  ///
  /// Field no: 162.
  logs::ProjectConfigUpdatedInfo& mutable_project_config_updated_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kProjectConfigUpdatedInfo;
    set_fields_[161] = true;
    return project_config_updated_info_;
  }

  /// Returns whether `project_config_updated_info` (no 162) is set.
  constexpr bool has_project_config_updated_info() const noexcept { return set_fields_[161]; }

  /// Clears `project_config_updated_info` (no 162).
  void clear_project_config_updated_info() & noexcept {
    data_ = {};
    set_fields_[161] = false;
    project_config_updated_info_ = {};
  }

  /// Sets `project_config_updated_info` (no 162) and returns `*this`.
  LogData& set_project_config_updated_info(logs::ProjectConfigUpdatedInfo&& project_config_updated_info) & noexcept {
    clear_data();
    data_ = DataOneof::kProjectConfigUpdatedInfo;
    set_fields_[161] = true;
    project_config_updated_info_ = std::move(project_config_updated_info);
    return *this;
  }
  /// Sets `project_config_updated_info` (no 162) and returns `*this`.
  LogData&& set_project_config_updated_info(logs::ProjectConfigUpdatedInfo&& project_config_updated_info) && noexcept {
    return std::move(set_project_config_updated_info(std::move(project_config_updated_info)));
  }

  // Field `invalid_lidar_timestamp` (no 163).
  // -----

  /// No documentation.
  ///
  /// Field no: 163.
  constexpr const logs::InvalidLidarTimestamp& invalid_lidar_timestamp() const& noexcept HORUS_LIFETIME_BOUND {
    return invalid_lidar_timestamp_;
  }

  /// If `invalid_lidar_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 163.
  logs::InvalidLidarTimestamp invalid_lidar_timestamp() && noexcept {
    if (!set_fields_[162]) {
      return {};
    }
    return std::move(invalid_lidar_timestamp_);
  }

  /// No documentation.
  ///
  /// Field no: 163.
  logs::InvalidLidarTimestamp& mutable_invalid_lidar_timestamp() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kInvalidLidarTimestamp;
    set_fields_[162] = true;
    return invalid_lidar_timestamp_;
  }

  /// Returns whether `invalid_lidar_timestamp` (no 163) is set.
  constexpr bool has_invalid_lidar_timestamp() const noexcept { return set_fields_[162]; }

  /// Clears `invalid_lidar_timestamp` (no 163).
  void clear_invalid_lidar_timestamp() & noexcept {
    data_ = {};
    set_fields_[162] = false;
    invalid_lidar_timestamp_ = {};
  }

  /// Sets `invalid_lidar_timestamp` (no 163) and returns `*this`.
  LogData& set_invalid_lidar_timestamp(logs::InvalidLidarTimestamp&& invalid_lidar_timestamp) & noexcept {
    clear_data();
    data_ = DataOneof::kInvalidLidarTimestamp;
    set_fields_[162] = true;
    invalid_lidar_timestamp_ = std::move(invalid_lidar_timestamp);
    return *this;
  }
  /// Sets `invalid_lidar_timestamp` (no 163) and returns `*this`.
  LogData&& set_invalid_lidar_timestamp(logs::InvalidLidarTimestamp&& invalid_lidar_timestamp) && noexcept {
    return std::move(set_invalid_lidar_timestamp(std::move(invalid_lidar_timestamp)));
  }

  // Field `calibration_accumulating_points_info` (no 164).
  // -----

  /// No documentation.
  ///
  /// Field no: 164.
  constexpr const logs::CalibrationAccumulatingPointsInfo& calibration_accumulating_points_info() const& noexcept HORUS_LIFETIME_BOUND {
    return calibration_accumulating_points_info_;
  }

  /// If `calibration_accumulating_points_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 164.
  logs::CalibrationAccumulatingPointsInfo calibration_accumulating_points_info() && noexcept {
    if (!set_fields_[163]) {
      return {};
    }
    return std::move(calibration_accumulating_points_info_);
  }

  /// No documentation.
  ///
  /// Field no: 164.
  logs::CalibrationAccumulatingPointsInfo& mutable_calibration_accumulating_points_info() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kCalibrationAccumulatingPointsInfo;
    set_fields_[163] = true;
    return calibration_accumulating_points_info_;
  }

  /// Returns whether `calibration_accumulating_points_info` (no 164) is set.
  constexpr bool has_calibration_accumulating_points_info() const noexcept { return set_fields_[163]; }

  /// Clears `calibration_accumulating_points_info` (no 164).
  void clear_calibration_accumulating_points_info() & noexcept {
    data_ = {};
    set_fields_[163] = false;
    calibration_accumulating_points_info_ = {};
  }

  /// Sets `calibration_accumulating_points_info` (no 164) and returns `*this`.
  LogData& set_calibration_accumulating_points_info(logs::CalibrationAccumulatingPointsInfo&& calibration_accumulating_points_info) & noexcept {
    clear_data();
    data_ = DataOneof::kCalibrationAccumulatingPointsInfo;
    set_fields_[163] = true;
    calibration_accumulating_points_info_ = std::move(calibration_accumulating_points_info);
    return *this;
  }
  /// Sets `calibration_accumulating_points_info` (no 164) and returns `*this`.
  LogData&& set_calibration_accumulating_points_info(logs::CalibrationAccumulatingPointsInfo&& calibration_accumulating_points_info) && noexcept {
    return std::move(set_calibration_accumulating_points_info(std::move(calibration_accumulating_points_info)));
  }

  // Field `sparse_noise_filter_usage_non_rotational_lidars` (no 165).
  // -----

  /// No documentation.
  ///
  /// Field no: 165.
  constexpr const logs::SparseNoiseFilterUsageNonRotationalLidars& sparse_noise_filter_usage_non_rotational_lidars() const& noexcept HORUS_LIFETIME_BOUND {
    return sparse_noise_filter_usage_non_rotational_lidars_;
  }

  /// If `sparse_noise_filter_usage_non_rotational_lidars` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 165.
  logs::SparseNoiseFilterUsageNonRotationalLidars sparse_noise_filter_usage_non_rotational_lidars() && noexcept {
    if (!set_fields_[164]) {
      return {};
    }
    return std::move(sparse_noise_filter_usage_non_rotational_lidars_);
  }

  /// No documentation.
  ///
  /// Field no: 165.
  logs::SparseNoiseFilterUsageNonRotationalLidars& mutable_sparse_noise_filter_usage_non_rotational_lidars() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kSparseNoiseFilterUsageNonRotationalLidars;
    set_fields_[164] = true;
    return sparse_noise_filter_usage_non_rotational_lidars_;
  }

  /// Returns whether `sparse_noise_filter_usage_non_rotational_lidars` (no 165) is set.
  constexpr bool has_sparse_noise_filter_usage_non_rotational_lidars() const noexcept { return set_fields_[164]; }

  /// Clears `sparse_noise_filter_usage_non_rotational_lidars` (no 165).
  void clear_sparse_noise_filter_usage_non_rotational_lidars() & noexcept {
    data_ = {};
    set_fields_[164] = false;
    sparse_noise_filter_usage_non_rotational_lidars_ = {};
  }

  /// Sets `sparse_noise_filter_usage_non_rotational_lidars` (no 165) and returns `*this`.
  LogData& set_sparse_noise_filter_usage_non_rotational_lidars(logs::SparseNoiseFilterUsageNonRotationalLidars&& sparse_noise_filter_usage_non_rotational_lidars) & noexcept {
    clear_data();
    data_ = DataOneof::kSparseNoiseFilterUsageNonRotationalLidars;
    set_fields_[164] = true;
    sparse_noise_filter_usage_non_rotational_lidars_ = std::move(sparse_noise_filter_usage_non_rotational_lidars);
    return *this;
  }
  /// Sets `sparse_noise_filter_usage_non_rotational_lidars` (no 165) and returns `*this`.
  LogData&& set_sparse_noise_filter_usage_non_rotational_lidars(logs::SparseNoiseFilterUsageNonRotationalLidars&& sparse_noise_filter_usage_non_rotational_lidars) && noexcept {
    return std::move(set_sparse_noise_filter_usage_non_rotational_lidars(std::move(sparse_noise_filter_usage_non_rotational_lidars)));
  }

  // Field `file_write_error` (no 166).
  // -----

  /// No documentation.
  ///
  /// Field no: 166.
  constexpr const logs::FileWriteError& file_write_error() const& noexcept HORUS_LIFETIME_BOUND {
    return file_write_error_;
  }

  /// If `file_write_error` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 166.
  logs::FileWriteError file_write_error() && noexcept {
    if (!set_fields_[165]) {
      return {};
    }
    return std::move(file_write_error_);
  }

  /// No documentation.
  ///
  /// Field no: 166.
  logs::FileWriteError& mutable_file_write_error() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFileWriteError;
    set_fields_[165] = true;
    return file_write_error_;
  }

  /// Returns whether `file_write_error` (no 166) is set.
  constexpr bool has_file_write_error() const noexcept { return set_fields_[165]; }

  /// Clears `file_write_error` (no 166).
  void clear_file_write_error() & noexcept {
    data_ = {};
    set_fields_[165] = false;
    file_write_error_ = {};
  }

  /// Sets `file_write_error` (no 166) and returns `*this`.
  LogData& set_file_write_error(logs::FileWriteError&& file_write_error) & noexcept {
    clear_data();
    data_ = DataOneof::kFileWriteError;
    set_fields_[165] = true;
    file_write_error_ = std::move(file_write_error);
    return *this;
  }
  /// Sets `file_write_error` (no 166) and returns `*this`.
  LogData&& set_file_write_error(logs::FileWriteError&& file_write_error) && noexcept {
    return std::move(set_file_write_error(std::move(file_write_error)));
  }

  // Field `license_forbidden_feature` (no 167).
  // -----

  /// No documentation.
  ///
  /// Field no: 167.
  constexpr const logs::LicenseForbiddenFeature& license_forbidden_feature() const& noexcept HORUS_LIFETIME_BOUND {
    return license_forbidden_feature_;
  }

  /// If `license_forbidden_feature` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 167.
  logs::LicenseForbiddenFeature license_forbidden_feature() && noexcept {
    if (!set_fields_[166]) {
      return {};
    }
    return std::move(license_forbidden_feature_);
  }

  /// No documentation.
  ///
  /// Field no: 167.
  logs::LicenseForbiddenFeature& mutable_license_forbidden_feature() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kLicenseForbiddenFeature;
    set_fields_[166] = true;
    return license_forbidden_feature_;
  }

  /// Returns whether `license_forbidden_feature` (no 167) is set.
  constexpr bool has_license_forbidden_feature() const noexcept { return set_fields_[166]; }

  /// Clears `license_forbidden_feature` (no 167).
  void clear_license_forbidden_feature() & noexcept {
    data_ = {};
    set_fields_[166] = false;
    license_forbidden_feature_ = {};
  }

  /// Sets `license_forbidden_feature` (no 167) and returns `*this`.
  LogData& set_license_forbidden_feature(logs::LicenseForbiddenFeature&& license_forbidden_feature) & noexcept {
    clear_data();
    data_ = DataOneof::kLicenseForbiddenFeature;
    set_fields_[166] = true;
    license_forbidden_feature_ = std::move(license_forbidden_feature);
    return *this;
  }
  /// Sets `license_forbidden_feature` (no 167) and returns `*this`.
  LogData&& set_license_forbidden_feature(logs::LicenseForbiddenFeature&& license_forbidden_feature) && noexcept {
    return std::move(set_license_forbidden_feature(std::move(license_forbidden_feature)));
  }

  // Field `failed_to_update_configuration` (no 168).
  // -----

  /// No documentation.
  ///
  /// Field no: 168.
  constexpr const logs::FailedToUpdateConfiguration& failed_to_update_configuration() const& noexcept HORUS_LIFETIME_BOUND {
    return failed_to_update_configuration_;
  }

  /// If `failed_to_update_configuration` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 168.
  logs::FailedToUpdateConfiguration failed_to_update_configuration() && noexcept {
    if (!set_fields_[167]) {
      return {};
    }
    return std::move(failed_to_update_configuration_);
  }

  /// No documentation.
  ///
  /// Field no: 168.
  logs::FailedToUpdateConfiguration& mutable_failed_to_update_configuration() & noexcept HORUS_LIFETIME_BOUND {
    clear_data();
    data_ = DataOneof::kFailedToUpdateConfiguration;
    set_fields_[167] = true;
    return failed_to_update_configuration_;
  }

  /// Returns whether `failed_to_update_configuration` (no 168) is set.
  constexpr bool has_failed_to_update_configuration() const noexcept { return set_fields_[167]; }

  /// Clears `failed_to_update_configuration` (no 168).
  void clear_failed_to_update_configuration() & noexcept {
    data_ = {};
    set_fields_[167] = false;
    failed_to_update_configuration_ = {};
  }

  /// Sets `failed_to_update_configuration` (no 168) and returns `*this`.
  LogData& set_failed_to_update_configuration(logs::FailedToUpdateConfiguration&& failed_to_update_configuration) & noexcept {
    clear_data();
    data_ = DataOneof::kFailedToUpdateConfiguration;
    set_fields_[167] = true;
    failed_to_update_configuration_ = std::move(failed_to_update_configuration);
    return *this;
  }
  /// Sets `failed_to_update_configuration` (no 168) and returns `*this`.
  LogData&& set_failed_to_update_configuration(logs::FailedToUpdateConfiguration&& failed_to_update_configuration) && noexcept {
    return std::move(set_failed_to_update_configuration(std::move(failed_to_update_configuration)));
  }

  // Oneof `data`.
  // -----

  /// Return value of `data_case()`.
  enum class DataOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see generic()
    kGeneric = 1,
    /// @see oom()
    kOom = 2,
    /// @see rpc_connection_error()
    kRpcConnectionError = 3,
    /// @see invalid_project_name()
    kInvalidProjectName = 4,
    /// @see project_not_found()
    kProjectNotFound = 5,
    /// @see project_already_exists()
    kProjectAlreadyExists = 6,
    /// @see invalid_configuration()
    kInvalidConfiguration = 7,
    /// @see entity_not_found()
    kEntityNotFound = 8,
    /// @see active_project_cannot_be_deleted()
    kActiveProjectCannotBeDeleted = 9,
    /// @see rpc_disconnection_error()
    kRpcDisconnectionError = 10,
    /// @see dropped_logs()
    kDroppedLogs = 11,
    /// @see opened_project()
    kOpenedProject = 12,
    /// @see created_project()
    kCreatedProject = 13,
    /// @see config_unavailable()
    kConfigUnavailable = 14,
    /// @see invalid_request()
    kInvalidRequest = 15,
    /// @see sanity_check_error()
    kSanityCheckError = 16,
    /// @see bag_failed_to_open()
    kBagFailedToOpen = 17,
    /// @see bag_failed_to_close()
    kBagFailedToClose = 18,
    /// @see bag_conversion_failed()
    kBagConversionFailed = 19,
    /// @see bag_failed_to_write()
    kBagFailedToWrite = 20,
    /// @see calibration_error()
    kCalibrationError = 21,
    /// @see project_manager_failed_to_start_recording()
    kProjectManagerFailedToStartRecording = 22,
    /// @see project_manager_failed_to_stop_recording()
    kProjectManagerFailedToStopRecording = 23,
    /// @see service_connection_timed_out()
    kServiceConnectionTimedOut = 24,
    /// @see bag_recorder_already_running()
    kBagRecorderAlreadyRunning = 25,
    /// @see license_server_connection_error()
    kLicenseServerConnectionError = 26,
    /// @see license_error()
    kLicenseError = 27,
    /// @see license_not_found_error()
    kLicenseNotFoundError = 145,
    /// @see license_expired_error()
    kLicenseExpiredError = 146,
    /// @see license_exceeded_error()
    kLicenseExceededError = 147,
    /// @see license_host_machine_error()
    kLicenseHostMachineError = 28,
    /// @see license_privilege_error()
    kLicensePrivilegeError = 148,
    /// @see license_active_info()
    kLicenseActiveInfo = 149,
    /// @see multiple_licenses_warning()
    kMultipleLicensesWarning = 150,
    /// @see license_current_license_status_info()
    kLicenseCurrentLicenseStatusInfo = 29,
    /// @see bag_recording_stopped_info()
    kBagRecordingStoppedInfo = 30,
    /// @see bag_recording_failed_to_start()
    kBagRecordingFailedToStart = 31,
    /// @see bag_recording_started_info()
    kBagRecordingStartedInfo = 32,
    /// @see replay_restarted_info()
    kReplayRestartedInfo = 33,
    /// @see input_source_change_requested_info()
    kInputSourceChangeRequestedInfo = 34,
    /// @see input_source_switched_info()
    kInputSourceSwitchedInfo = 35,
    /// @see rpc_timeout_warning()
    kRpcTimeoutWarning = 36,
    /// @see cannot_write_log_file()
    kCannotWriteLogFile = 37,
    /// @see point_cloud_parsing_failure_warning()
    kPointCloudParsingFailureWarning = 38,
    /// @see lidar_is_dead()
    kLidarIsDead = 39,
    /// @see lidar_is_not_dead_anymore()
    kLidarIsNotDeadAnymore = 40,
    /// @see lidar_is_obstructed()
    kLidarIsObstructed = 41,
    /// @see lidar_is_not_obstructed_anymore()
    kLidarIsNotObstructedAnymore = 42,
    /// @see lidar_is_tilted()
    kLidarIsTilted = 43,
    /// @see lidar_is_not_tilted_anymore()
    kLidarIsNotTiltedAnymore = 44,
    /// @see lidar_has_been_automatically_recalibrated()
    kLidarHasBeenAutomaticallyRecalibrated = 45,
    /// @see received_first_data_for_lidar()
    kReceivedFirstDataForLidar = 46,
    /// @see termination_failure_error()
    kTerminationFailureError = 47,
    /// @see frame_processing_error()
    kFrameProcessingError = 48,
    /// @see thread_pool_unavailable_error()
    kThreadPoolUnavailableError = 49,
    /// @see invalid_argument()
    kInvalidArgument = 50,
    /// @see component_initialization_failure_fatal()
    kComponentInitializationFailureFatal = 51,
    /// @see unhandled_enum_case_error()
    kUnhandledEnumCaseError = 52,
    /// @see bag_empty_error()
    kBagEmptyError = 53,
    /// @see discarding_data_error()
    kDiscardingDataError = 54,
    /// @see discarding_data_warning()
    kDiscardingDataWarning = 55,
    /// @see nothing_to_process()
    kNothingToProcess = 56,
    /// @see invalid_component_configuration()
    kInvalidComponentConfiguration = 57,
    /// @see channel_receiver_not_found_warning()
    kChannelReceiverNotFoundWarning = 58,
    /// @see model_load_failure()
    kModelLoadFailure = 59,
    /// @see model_execution_failure_error()
    kModelExecutionFailureError = 60,
    /// @see service_ready_info()
    kServiceReadyInfo = 61,
    /// @see model_preparing_info()
    kModelPreparingInfo = 62,
    /// @see model_initialized_info()
    kModelInitializedInfo = 63,
    /// @see model_initialization_failure_warning()
    kModelInitializationFailureWarning = 64,
    /// @see ros_spinner_stopped_warning()
    kRosSpinnerStoppedWarning = 65,
    /// @see actor_system_unavailable_error()
    kActorSystemUnavailableError = 66,
    /// @see config_node_not_found_error()
    kConfigNodeNotFoundError = 67,
    /// @see bag_timestamp_out_of_order_error()
    kBagTimestampOutOfOrderError = 68,
    /// @see bag_replay_unexpected_timestamp_error()
    kBagReplayUnexpectedTimestampError = 69,
    /// @see websocket_closed_info()
    kWebsocketClosedInfo = 70,
    /// @see websocket_opened_info()
    kWebsocketOpenedInfo = 71,
    /// @see subscriber_disconnected_info()
    kSubscriberDisconnectedInfo = 72,
    /// @see thread_pool_slowing_down_warning()
    kThreadPoolSlowingDownWarning = 73,
    /// @see thread_pool_not_responding_warning()
    kThreadPoolNotRespondingWarning = 74,
    /// @see thread_pool_broken_promise_warning()
    kThreadPoolBrokenPromiseWarning = 75,
    /// @see box_fitting_points_below_base_warning()
    kBoxFittingPointsBelowBaseWarning = 76,
    /// @see failed_to_remove_stale_points_warning()
    kFailedToRemoveStalePointsWarning = 77,
    /// @see irregular_broadcasting_period_warning()
    kIrregularBroadcastingPeriodWarning = 78,
    /// @see clusterer_points_out_of_range_warning()
    kClustererPointsOutOfRangeWarning = 79,
    /// @see internal_error()
    kInternalError = 80,
    /// @see internal_fatal()
    kInternalFatal = 81,
    /// @see service_starting_info()
    kServiceStartingInfo = 82,
    /// @see config_node_not_found_fatal()
    kConfigNodeNotFoundFatal = 83,
    /// @see service_setup_error()
    kServiceSetupError = 84,
    /// @see filesystem_error()
    kFilesystemError = 85,
    /// @see invalid_preset_warning()
    kInvalidPresetWarning = 86,
    /// @see websocket_failed_clear_pending_error()
    kWebsocketFailedClearPendingError = 87,
    /// @see websocket_failed_to_stop_error()
    kWebsocketFailedToStopError = 88,
    /// @see websocket_failed_to_create_error()
    kWebsocketFailedToCreateError = 89,
    /// @see unexpected_rpc_error()
    kUnexpectedRpcError = 90,
    /// @see license_poll_failed()
    kLicensePollFailed = 91,
    /// @see license_expired_warning()
    kLicenseExpiredWarning = 92,
    /// @see license_usage_exceeded_warning()
    kLicenseUsageExceededWarning = 93,
    /// @see static_thread_pool_slow_task_warning()
    kStaticThreadPoolSlowTaskWarning = 94,
    /// @see rpc_unsupported_service_warning()
    kRpcUnsupportedServiceWarning = 95,
    /// @see websocket_handler_problem()
    kWebsocketHandlerProblem = 96,
    /// @see websocket_deserialize_error()
    kWebsocketDeserializeError = 97,
    /// @see websocket_expired_rpc_endpoint_error()
    kWebsocketExpiredRpcEndpointError = 98,
    /// @see websocket_queue_overloaded_warning()
    kWebsocketQueueOverloadedWarning = 99,
    /// @see rpc_failed_to_notify_warning()
    kRpcFailedToNotifyWarning = 100,
    /// @see config_subscription_failed_warning()
    kConfigSubscriptionFailedWarning = 101,
    /// @see thread_pool_clamped_workers_warning()
    kThreadPoolClampedWorkersWarning = 102,
    /// @see stopping_horus_bag_recorder_already_stopped()
    kStoppingHorusBagRecorderAlreadyStopped = 103,
    /// @see recorder_config_update_while_running()
    kRecorderConfigUpdateWhileRunning = 104,
    /// @see clamping_data_warning()
    kClampingDataWarning = 105,
    /// @see lidar_incompatible_values()
    kLidarIncompatibleValues = 106,
    /// @see cannot_determine_container_id_error()
    kCannotDetermineContainerIdError = 107,
    /// @see started_lidar_driver()
    kStartedLidarDriver = 108,
    /// @see cannot_start_lidar_driver()
    kCannotStartLidarDriver = 109,
    /// @see stopped_lidar_driver()
    kStoppedLidarDriver = 110,
    /// @see cannot_stop_lidar_driver()
    kCannotStopLidarDriver = 111,
    /// @see restarted_lidar_driver()
    kRestartedLidarDriver = 112,
    /// @see cannot_restart_lidar_driver()
    kCannotRestartLidarDriver = 113,
    /// @see removed_unused_lidar_driver()
    kRemovedUnusedLidarDriver = 114,
    /// @see cannot_remove_unused_lidar_driver()
    kCannotRemoveUnusedLidarDriver = 115,
    /// @see lidar_driver_gc_failure()
    kLidarDriverGcFailure = 116,
    /// @see id_space_exhausted()
    kIdSpaceExhausted = 117,
    /// @see preprocessing_to_point_aggregator_points_skipped()
    kPreprocessingToPointAggregatorPointsSkipped = 118,
    /// @see min_msg_interval_less_than_threshold()
    kMinMsgIntervalLessThanThreshold = 119,
    /// @see failed_to_cleanup_ros_warning()
    kFailedToCleanupRosWarning = 120,
    /// @see rpc_disconnected_warning()
    kRpcDisconnectedWarning = 121,
    /// @see rpc_unhandled_error()
    kRpcUnhandledError = 122,
    /// @see time_diff_out_of_range_warning()
    kTimeDiffOutOfRangeWarning = 123,
    /// @see tensorrt_log()
    kTensorrtLog = 124,
    /// @see building_tensorrt_engine_info()
    kBuildingTensorrtEngineInfo = 125,
    /// @see loading_tensorrt_engine_info()
    kLoadingTensorrtEngineInfo = 126,
    /// @see calibration_map_not_found()
    kCalibrationMapNotFound = 127,
    /// @see calibration_map_not_valid()
    kCalibrationMapNotValid = 128,
    /// @see calibration_map_path_already_exists()
    kCalibrationMapPathAlreadyExists = 129,
    /// @see failed_to_save_calibration_map()
    kFailedToSaveCalibrationMap = 130,
    /// @see failed_to_remove_calibration_map()
    kFailedToRemoveCalibrationMap = 131,
    /// @see failed_to_iterate_in_directory()
    kFailedToIterateInDirectory = 132,
    /// @see map_based_calibration_without_map_loading()
    kMapBasedCalibrationWithoutMapLoading = 133,
    /// @see map_based_calibration_already_running()
    kMapBasedCalibrationAlreadyRunning = 134,
    /// @see cancel_map_based_calibration_not_running()
    kCancelMapBasedCalibrationNotRunning = 135,
    /// @see bag_stream_not_found()
    kBagStreamNotFound = 136,
    /// @see evaluation_bag_started_info()
    kEvaluationBagStartedInfo = 137,
    /// @see evaluation_bag_finished_info()
    kEvaluationBagFinishedInfo = 138,
    /// @see bag_not_found()
    kBagNotFound = 139,
    /// @see building_pipeline_info()
    kBuildingPipelineInfo = 140,
    /// @see bag_is_not_evaluation()
    kBagIsNotEvaluation = 141,
    /// @see horus_bag_running()
    kHorusBagRunning = 142,
    /// @see auto_ground_calibration_warning()
    kAutoGroundCalibrationWarning = 143,
    /// @see auto_ground_calibration_error()
    kAutoGroundCalibrationError = 144,
    /// @see object_detector_not_loaded_warning()
    kObjectDetectorNotLoadedWarning = 151,
    /// @see calibration_is_running_error()
    kCalibrationIsRunningError = 152,
    /// @see model_init_in_progress_info()
    kModelInitInProgressInfo = 153,
    /// @see rpc_timeout_with_resolution_warning()
    kRpcTimeoutWithResolutionWarning = 154,
    /// @see calibration_was_cancelled_info()
    kCalibrationWasCancelledInfo = 155,
    /// @see calibration_map_recording_failed_to_start()
    kCalibrationMapRecordingFailedToStart = 156,
    /// @see detection_pipeline_requested_reset_info()
    kDetectionPipelineRequestedResetInfo = 157,
    /// @see preprocessing_service_pipeline_unavailable()
    kPreprocessingServicePipelineUnavailable = 158,
    /// @see circular_recording_disabled_warning()
    kCircularRecordingDisabledWarning = 159,
    /// @see snapshot_already_running_warning()
    kSnapshotAlreadyRunningWarning = 160,
    /// @see active_project_changed_info()
    kActiveProjectChangedInfo = 161,
    /// @see project_config_updated_info()
    kProjectConfigUpdatedInfo = 162,
    /// @see invalid_lidar_timestamp()
    kInvalidLidarTimestamp = 163,
    /// @see calibration_accumulating_points_info()
    kCalibrationAccumulatingPointsInfo = 164,
    /// @see sparse_noise_filter_usage_non_rotational_lidars()
    kSparseNoiseFilterUsageNonRotationalLidars = 165,
    /// @see file_write_error()
    kFileWriteError = 166,
    /// @see license_forbidden_feature()
    kLicenseForbiddenFeature = 167,
    /// @see failed_to_update_configuration()
    kFailedToUpdateConfiguration = 168,
  };

  /// Returns the current case set in `data`.
  constexpr DataOneof data_case() const noexcept {
    return data_;
  }

  /// Clears the oneof value in `data`.
  void clear_data() noexcept {
    switch (data_) {
      case DataOneof::kGeneric: {
        clear_generic();
        break;
      }
      case DataOneof::kOom: {
        clear_oom();
        break;
      }
      case DataOneof::kRpcConnectionError: {
        clear_rpc_connection_error();
        break;
      }
      case DataOneof::kInvalidProjectName: {
        clear_invalid_project_name();
        break;
      }
      case DataOneof::kProjectNotFound: {
        clear_project_not_found();
        break;
      }
      case DataOneof::kProjectAlreadyExists: {
        clear_project_already_exists();
        break;
      }
      case DataOneof::kInvalidConfiguration: {
        clear_invalid_configuration();
        break;
      }
      case DataOneof::kEntityNotFound: {
        clear_entity_not_found();
        break;
      }
      case DataOneof::kActiveProjectCannotBeDeleted: {
        clear_active_project_cannot_be_deleted();
        break;
      }
      case DataOneof::kRpcDisconnectionError: {
        clear_rpc_disconnection_error();
        break;
      }
      case DataOneof::kDroppedLogs: {
        clear_dropped_logs();
        break;
      }
      case DataOneof::kOpenedProject: {
        clear_opened_project();
        break;
      }
      case DataOneof::kCreatedProject: {
        clear_created_project();
        break;
      }
      case DataOneof::kConfigUnavailable: {
        clear_config_unavailable();
        break;
      }
      case DataOneof::kInvalidRequest: {
        clear_invalid_request();
        break;
      }
      case DataOneof::kSanityCheckError: {
        clear_sanity_check_error();
        break;
      }
      case DataOneof::kBagFailedToOpen: {
        clear_bag_failed_to_open();
        break;
      }
      case DataOneof::kBagFailedToClose: {
        clear_bag_failed_to_close();
        break;
      }
      case DataOneof::kBagConversionFailed: {
        clear_bag_conversion_failed();
        break;
      }
      case DataOneof::kBagFailedToWrite: {
        clear_bag_failed_to_write();
        break;
      }
      case DataOneof::kCalibrationError: {
        clear_calibration_error();
        break;
      }
      case DataOneof::kProjectManagerFailedToStartRecording: {
        clear_project_manager_failed_to_start_recording();
        break;
      }
      case DataOneof::kProjectManagerFailedToStopRecording: {
        clear_project_manager_failed_to_stop_recording();
        break;
      }
      case DataOneof::kServiceConnectionTimedOut: {
        clear_service_connection_timed_out();
        break;
      }
      case DataOneof::kBagRecorderAlreadyRunning: {
        clear_bag_recorder_already_running();
        break;
      }
      case DataOneof::kLicenseServerConnectionError: {
        clear_license_server_connection_error();
        break;
      }
      case DataOneof::kLicenseError: {
        clear_license_error();
        break;
      }
      case DataOneof::kLicenseNotFoundError: {
        clear_license_not_found_error();
        break;
      }
      case DataOneof::kLicenseExpiredError: {
        clear_license_expired_error();
        break;
      }
      case DataOneof::kLicenseExceededError: {
        clear_license_exceeded_error();
        break;
      }
      case DataOneof::kLicenseHostMachineError: {
        clear_license_host_machine_error();
        break;
      }
      case DataOneof::kLicensePrivilegeError: {
        clear_license_privilege_error();
        break;
      }
      case DataOneof::kLicenseActiveInfo: {
        clear_license_active_info();
        break;
      }
      case DataOneof::kMultipleLicensesWarning: {
        clear_multiple_licenses_warning();
        break;
      }
      case DataOneof::kLicenseCurrentLicenseStatusInfo: {
        clear_license_current_license_status_info();
        break;
      }
      case DataOneof::kBagRecordingStoppedInfo: {
        clear_bag_recording_stopped_info();
        break;
      }
      case DataOneof::kBagRecordingFailedToStart: {
        clear_bag_recording_failed_to_start();
        break;
      }
      case DataOneof::kBagRecordingStartedInfo: {
        clear_bag_recording_started_info();
        break;
      }
      case DataOneof::kReplayRestartedInfo: {
        clear_replay_restarted_info();
        break;
      }
      case DataOneof::kInputSourceChangeRequestedInfo: {
        clear_input_source_change_requested_info();
        break;
      }
      case DataOneof::kInputSourceSwitchedInfo: {
        clear_input_source_switched_info();
        break;
      }
      case DataOneof::kRpcTimeoutWarning: {
        clear_rpc_timeout_warning();
        break;
      }
      case DataOneof::kCannotWriteLogFile: {
        clear_cannot_write_log_file();
        break;
      }
      case DataOneof::kPointCloudParsingFailureWarning: {
        clear_point_cloud_parsing_failure_warning();
        break;
      }
      case DataOneof::kLidarIsDead: {
        clear_lidar_is_dead();
        break;
      }
      case DataOneof::kLidarIsNotDeadAnymore: {
        clear_lidar_is_not_dead_anymore();
        break;
      }
      case DataOneof::kLidarIsObstructed: {
        clear_lidar_is_obstructed();
        break;
      }
      case DataOneof::kLidarIsNotObstructedAnymore: {
        clear_lidar_is_not_obstructed_anymore();
        break;
      }
      case DataOneof::kLidarIsTilted: {
        clear_lidar_is_tilted();
        break;
      }
      case DataOneof::kLidarIsNotTiltedAnymore: {
        clear_lidar_is_not_tilted_anymore();
        break;
      }
      case DataOneof::kLidarHasBeenAutomaticallyRecalibrated: {
        clear_lidar_has_been_automatically_recalibrated();
        break;
      }
      case DataOneof::kReceivedFirstDataForLidar: {
        clear_received_first_data_for_lidar();
        break;
      }
      case DataOneof::kTerminationFailureError: {
        clear_termination_failure_error();
        break;
      }
      case DataOneof::kFrameProcessingError: {
        clear_frame_processing_error();
        break;
      }
      case DataOneof::kThreadPoolUnavailableError: {
        clear_thread_pool_unavailable_error();
        break;
      }
      case DataOneof::kInvalidArgument: {
        clear_invalid_argument();
        break;
      }
      case DataOneof::kComponentInitializationFailureFatal: {
        clear_component_initialization_failure_fatal();
        break;
      }
      case DataOneof::kUnhandledEnumCaseError: {
        clear_unhandled_enum_case_error();
        break;
      }
      case DataOneof::kBagEmptyError: {
        clear_bag_empty_error();
        break;
      }
      case DataOneof::kDiscardingDataError: {
        clear_discarding_data_error();
        break;
      }
      case DataOneof::kDiscardingDataWarning: {
        clear_discarding_data_warning();
        break;
      }
      case DataOneof::kNothingToProcess: {
        clear_nothing_to_process();
        break;
      }
      case DataOneof::kInvalidComponentConfiguration: {
        clear_invalid_component_configuration();
        break;
      }
      case DataOneof::kChannelReceiverNotFoundWarning: {
        clear_channel_receiver_not_found_warning();
        break;
      }
      case DataOneof::kModelLoadFailure: {
        clear_model_load_failure();
        break;
      }
      case DataOneof::kModelExecutionFailureError: {
        clear_model_execution_failure_error();
        break;
      }
      case DataOneof::kServiceReadyInfo: {
        clear_service_ready_info();
        break;
      }
      case DataOneof::kModelPreparingInfo: {
        clear_model_preparing_info();
        break;
      }
      case DataOneof::kModelInitializedInfo: {
        clear_model_initialized_info();
        break;
      }
      case DataOneof::kModelInitializationFailureWarning: {
        clear_model_initialization_failure_warning();
        break;
      }
      case DataOneof::kRosSpinnerStoppedWarning: {
        clear_ros_spinner_stopped_warning();
        break;
      }
      case DataOneof::kActorSystemUnavailableError: {
        clear_actor_system_unavailable_error();
        break;
      }
      case DataOneof::kConfigNodeNotFoundError: {
        clear_config_node_not_found_error();
        break;
      }
      case DataOneof::kBagTimestampOutOfOrderError: {
        clear_bag_timestamp_out_of_order_error();
        break;
      }
      case DataOneof::kBagReplayUnexpectedTimestampError: {
        clear_bag_replay_unexpected_timestamp_error();
        break;
      }
      case DataOneof::kWebsocketClosedInfo: {
        clear_websocket_closed_info();
        break;
      }
      case DataOneof::kWebsocketOpenedInfo: {
        clear_websocket_opened_info();
        break;
      }
      case DataOneof::kSubscriberDisconnectedInfo: {
        clear_subscriber_disconnected_info();
        break;
      }
      case DataOneof::kThreadPoolSlowingDownWarning: {
        clear_thread_pool_slowing_down_warning();
        break;
      }
      case DataOneof::kThreadPoolNotRespondingWarning: {
        clear_thread_pool_not_responding_warning();
        break;
      }
      case DataOneof::kThreadPoolBrokenPromiseWarning: {
        clear_thread_pool_broken_promise_warning();
        break;
      }
      case DataOneof::kBoxFittingPointsBelowBaseWarning: {
        clear_box_fitting_points_below_base_warning();
        break;
      }
      case DataOneof::kFailedToRemoveStalePointsWarning: {
        clear_failed_to_remove_stale_points_warning();
        break;
      }
      case DataOneof::kIrregularBroadcastingPeriodWarning: {
        clear_irregular_broadcasting_period_warning();
        break;
      }
      case DataOneof::kClustererPointsOutOfRangeWarning: {
        clear_clusterer_points_out_of_range_warning();
        break;
      }
      case DataOneof::kInternalError: {
        clear_internal_error();
        break;
      }
      case DataOneof::kInternalFatal: {
        clear_internal_fatal();
        break;
      }
      case DataOneof::kServiceStartingInfo: {
        clear_service_starting_info();
        break;
      }
      case DataOneof::kConfigNodeNotFoundFatal: {
        clear_config_node_not_found_fatal();
        break;
      }
      case DataOneof::kServiceSetupError: {
        clear_service_setup_error();
        break;
      }
      case DataOneof::kFilesystemError: {
        clear_filesystem_error();
        break;
      }
      case DataOneof::kInvalidPresetWarning: {
        clear_invalid_preset_warning();
        break;
      }
      case DataOneof::kWebsocketFailedClearPendingError: {
        clear_websocket_failed_clear_pending_error();
        break;
      }
      case DataOneof::kWebsocketFailedToStopError: {
        clear_websocket_failed_to_stop_error();
        break;
      }
      case DataOneof::kWebsocketFailedToCreateError: {
        clear_websocket_failed_to_create_error();
        break;
      }
      case DataOneof::kUnexpectedRpcError: {
        clear_unexpected_rpc_error();
        break;
      }
      case DataOneof::kLicensePollFailed: {
        clear_license_poll_failed();
        break;
      }
      case DataOneof::kLicenseExpiredWarning: {
        clear_license_expired_warning();
        break;
      }
      case DataOneof::kLicenseUsageExceededWarning: {
        clear_license_usage_exceeded_warning();
        break;
      }
      case DataOneof::kStaticThreadPoolSlowTaskWarning: {
        clear_static_thread_pool_slow_task_warning();
        break;
      }
      case DataOneof::kRpcUnsupportedServiceWarning: {
        clear_rpc_unsupported_service_warning();
        break;
      }
      case DataOneof::kWebsocketHandlerProblem: {
        clear_websocket_handler_problem();
        break;
      }
      case DataOneof::kWebsocketDeserializeError: {
        clear_websocket_deserialize_error();
        break;
      }
      case DataOneof::kWebsocketExpiredRpcEndpointError: {
        clear_websocket_expired_rpc_endpoint_error();
        break;
      }
      case DataOneof::kWebsocketQueueOverloadedWarning: {
        clear_websocket_queue_overloaded_warning();
        break;
      }
      case DataOneof::kRpcFailedToNotifyWarning: {
        clear_rpc_failed_to_notify_warning();
        break;
      }
      case DataOneof::kConfigSubscriptionFailedWarning: {
        clear_config_subscription_failed_warning();
        break;
      }
      case DataOneof::kThreadPoolClampedWorkersWarning: {
        clear_thread_pool_clamped_workers_warning();
        break;
      }
      case DataOneof::kStoppingHorusBagRecorderAlreadyStopped: {
        clear_stopping_horus_bag_recorder_already_stopped();
        break;
      }
      case DataOneof::kRecorderConfigUpdateWhileRunning: {
        clear_recorder_config_update_while_running();
        break;
      }
      case DataOneof::kClampingDataWarning: {
        clear_clamping_data_warning();
        break;
      }
      case DataOneof::kLidarIncompatibleValues: {
        clear_lidar_incompatible_values();
        break;
      }
      case DataOneof::kCannotDetermineContainerIdError: {
        clear_cannot_determine_container_id_error();
        break;
      }
      case DataOneof::kStartedLidarDriver: {
        clear_started_lidar_driver();
        break;
      }
      case DataOneof::kCannotStartLidarDriver: {
        clear_cannot_start_lidar_driver();
        break;
      }
      case DataOneof::kStoppedLidarDriver: {
        clear_stopped_lidar_driver();
        break;
      }
      case DataOneof::kCannotStopLidarDriver: {
        clear_cannot_stop_lidar_driver();
        break;
      }
      case DataOneof::kRestartedLidarDriver: {
        clear_restarted_lidar_driver();
        break;
      }
      case DataOneof::kCannotRestartLidarDriver: {
        clear_cannot_restart_lidar_driver();
        break;
      }
      case DataOneof::kRemovedUnusedLidarDriver: {
        clear_removed_unused_lidar_driver();
        break;
      }
      case DataOneof::kCannotRemoveUnusedLidarDriver: {
        clear_cannot_remove_unused_lidar_driver();
        break;
      }
      case DataOneof::kLidarDriverGcFailure: {
        clear_lidar_driver_gc_failure();
        break;
      }
      case DataOneof::kIdSpaceExhausted: {
        clear_id_space_exhausted();
        break;
      }
      case DataOneof::kPreprocessingToPointAggregatorPointsSkipped: {
        clear_preprocessing_to_point_aggregator_points_skipped();
        break;
      }
      case DataOneof::kMinMsgIntervalLessThanThreshold: {
        clear_min_msg_interval_less_than_threshold();
        break;
      }
      case DataOneof::kFailedToCleanupRosWarning: {
        clear_failed_to_cleanup_ros_warning();
        break;
      }
      case DataOneof::kRpcDisconnectedWarning: {
        clear_rpc_disconnected_warning();
        break;
      }
      case DataOneof::kRpcUnhandledError: {
        clear_rpc_unhandled_error();
        break;
      }
      case DataOneof::kTimeDiffOutOfRangeWarning: {
        clear_time_diff_out_of_range_warning();
        break;
      }
      case DataOneof::kTensorrtLog: {
        clear_tensorrt_log();
        break;
      }
      case DataOneof::kBuildingTensorrtEngineInfo: {
        clear_building_tensorrt_engine_info();
        break;
      }
      case DataOneof::kLoadingTensorrtEngineInfo: {
        clear_loading_tensorrt_engine_info();
        break;
      }
      case DataOneof::kCalibrationMapNotFound: {
        clear_calibration_map_not_found();
        break;
      }
      case DataOneof::kCalibrationMapNotValid: {
        clear_calibration_map_not_valid();
        break;
      }
      case DataOneof::kCalibrationMapPathAlreadyExists: {
        clear_calibration_map_path_already_exists();
        break;
      }
      case DataOneof::kFailedToSaveCalibrationMap: {
        clear_failed_to_save_calibration_map();
        break;
      }
      case DataOneof::kFailedToRemoveCalibrationMap: {
        clear_failed_to_remove_calibration_map();
        break;
      }
      case DataOneof::kFailedToIterateInDirectory: {
        clear_failed_to_iterate_in_directory();
        break;
      }
      case DataOneof::kMapBasedCalibrationWithoutMapLoading: {
        clear_map_based_calibration_without_map_loading();
        break;
      }
      case DataOneof::kMapBasedCalibrationAlreadyRunning: {
        clear_map_based_calibration_already_running();
        break;
      }
      case DataOneof::kCancelMapBasedCalibrationNotRunning: {
        clear_cancel_map_based_calibration_not_running();
        break;
      }
      case DataOneof::kBagStreamNotFound: {
        clear_bag_stream_not_found();
        break;
      }
      case DataOneof::kEvaluationBagStartedInfo: {
        clear_evaluation_bag_started_info();
        break;
      }
      case DataOneof::kEvaluationBagFinishedInfo: {
        clear_evaluation_bag_finished_info();
        break;
      }
      case DataOneof::kBagNotFound: {
        clear_bag_not_found();
        break;
      }
      case DataOneof::kBuildingPipelineInfo: {
        clear_building_pipeline_info();
        break;
      }
      case DataOneof::kBagIsNotEvaluation: {
        clear_bag_is_not_evaluation();
        break;
      }
      case DataOneof::kHorusBagRunning: {
        clear_horus_bag_running();
        break;
      }
      case DataOneof::kAutoGroundCalibrationWarning: {
        clear_auto_ground_calibration_warning();
        break;
      }
      case DataOneof::kAutoGroundCalibrationError: {
        clear_auto_ground_calibration_error();
        break;
      }
      case DataOneof::kObjectDetectorNotLoadedWarning: {
        clear_object_detector_not_loaded_warning();
        break;
      }
      case DataOneof::kCalibrationIsRunningError: {
        clear_calibration_is_running_error();
        break;
      }
      case DataOneof::kModelInitInProgressInfo: {
        clear_model_init_in_progress_info();
        break;
      }
      case DataOneof::kRpcTimeoutWithResolutionWarning: {
        clear_rpc_timeout_with_resolution_warning();
        break;
      }
      case DataOneof::kCalibrationWasCancelledInfo: {
        clear_calibration_was_cancelled_info();
        break;
      }
      case DataOneof::kCalibrationMapRecordingFailedToStart: {
        clear_calibration_map_recording_failed_to_start();
        break;
      }
      case DataOneof::kDetectionPipelineRequestedResetInfo: {
        clear_detection_pipeline_requested_reset_info();
        break;
      }
      case DataOneof::kPreprocessingServicePipelineUnavailable: {
        clear_preprocessing_service_pipeline_unavailable();
        break;
      }
      case DataOneof::kCircularRecordingDisabledWarning: {
        clear_circular_recording_disabled_warning();
        break;
      }
      case DataOneof::kSnapshotAlreadyRunningWarning: {
        clear_snapshot_already_running_warning();
        break;
      }
      case DataOneof::kActiveProjectChangedInfo: {
        clear_active_project_changed_info();
        break;
      }
      case DataOneof::kProjectConfigUpdatedInfo: {
        clear_project_config_updated_info();
        break;
      }
      case DataOneof::kInvalidLidarTimestamp: {
        clear_invalid_lidar_timestamp();
        break;
      }
      case DataOneof::kCalibrationAccumulatingPointsInfo: {
        clear_calibration_accumulating_points_info();
        break;
      }
      case DataOneof::kSparseNoiseFilterUsageNonRotationalLidars: {
        clear_sparse_noise_filter_usage_non_rotational_lidars();
        break;
      }
      case DataOneof::kFileWriteError: {
        clear_file_write_error();
        break;
      }
      case DataOneof::kLicenseForbiddenFeature: {
        clear_license_forbidden_feature();
        break;
      }
      case DataOneof::kFailedToUpdateConfiguration: {
        clear_failed_to_update_configuration();
        break;
      }
      case DataOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see generic()
  logs::Generic generic_{};
  /// @see oom()
  logs::Oom oom_{};
  /// @see rpc_connection_error()
  logs::RpcConnectionError rpc_connection_error_{};
  /// @see invalid_project_name()
  logs::InvalidProjectName invalid_project_name_{};
  /// @see project_not_found()
  logs::ProjectNotFound project_not_found_{};
  /// @see project_already_exists()
  logs::ProjectAlreadyExists project_already_exists_{};
  /// @see invalid_configuration()
  logs::InvalidConfiguration invalid_configuration_{};
  /// @see entity_not_found()
  logs::EntityNotFound entity_not_found_{};
  /// @see active_project_cannot_be_deleted()
  logs::ActiveProjectCannotBeDeleted active_project_cannot_be_deleted_{};
  /// @see rpc_disconnection_error()
  logs::RpcDisconnectionError rpc_disconnection_error_{};
  /// @see dropped_logs()
  logs::DroppedLogs dropped_logs_{};
  /// @see opened_project()
  logs::OpenedProject opened_project_{};
  /// @see created_project()
  logs::CreatedProject created_project_{};
  /// @see config_unavailable()
  logs::ConfigUnavailable config_unavailable_{};
  /// @see invalid_request()
  logs::InvalidRequest invalid_request_{};
  /// @see sanity_check_error()
  logs::SanityCheckError sanity_check_error_{};
  /// @see bag_failed_to_open()
  logs::BagFailedToOpen bag_failed_to_open_{};
  /// @see bag_failed_to_close()
  logs::BagFailedToClose bag_failed_to_close_{};
  /// @see bag_conversion_failed()
  logs::BagConversionFailed bag_conversion_failed_{};
  /// @see bag_failed_to_write()
  logs::BagFailedToWrite bag_failed_to_write_{};
  /// @see calibration_error()
  logs::CalibrationError calibration_error_{};
  /// @see project_manager_failed_to_start_recording()
  logs::ProjectManagerFailedToStartRecording project_manager_failed_to_start_recording_{};
  /// @see project_manager_failed_to_stop_recording()
  logs::ProjectManagerFailedToStopRecording project_manager_failed_to_stop_recording_{};
  /// @see service_connection_timed_out()
  logs::ServiceConnectionTimedOut service_connection_timed_out_{};
  /// @see bag_recorder_already_running()
  logs::BagRecorderAlreadyRunning bag_recorder_already_running_{};
  /// @see license_server_connection_error()
  logs::LicenseServerConnectionError license_server_connection_error_{};
  /// @see license_error()
  logs::LicenseError license_error_{};
  /// @see license_not_found_error()
  logs::LicenseNotFoundError license_not_found_error_{};
  /// @see license_expired_error()
  logs::LicenseExpiredError license_expired_error_{};
  /// @see license_exceeded_error()
  logs::LicenseExceededError license_exceeded_error_{};
  /// @see license_host_machine_error()
  logs::LicenseHostMachineError license_host_machine_error_{};
  /// @see license_privilege_error()
  logs::LicensePrivilegeError license_privilege_error_{};
  /// @see license_active_info()
  logs::LicenseActiveInfo license_active_info_{};
  /// @see multiple_licenses_warning()
  logs::MultipleLicensesWarning multiple_licenses_warning_{};
  /// @see license_current_license_status_info()
  logs::LicenseCurrentLicenseStatusInfo license_current_license_status_info_{};
  /// @see bag_recording_stopped_info()
  logs::BagRecordingStoppedInfo bag_recording_stopped_info_{};
  /// @see bag_recording_failed_to_start()
  logs::BagRecordingFailedToStart bag_recording_failed_to_start_{};
  /// @see bag_recording_started_info()
  logs::BagRecordingStartedInfo bag_recording_started_info_{};
  /// @see replay_restarted_info()
  logs::ReplayRestartedInfo replay_restarted_info_{};
  /// @see input_source_change_requested_info()
  logs::InputSourceChangeRequestedInfo input_source_change_requested_info_{};
  /// @see input_source_switched_info()
  logs::InputSourceSwitchedInfo input_source_switched_info_{};
  /// @see rpc_timeout_warning()
  logs::RpcTimeoutWarning rpc_timeout_warning_{};
  /// @see cannot_write_log_file()
  logs::CannotWriteLogFile cannot_write_log_file_{};
  /// @see point_cloud_parsing_failure_warning()
  logs::PointCloudParsingFailureWarning point_cloud_parsing_failure_warning_{};
  /// @see lidar_is_dead()
  logs::LidarIsDead lidar_is_dead_{};
  /// @see lidar_is_not_dead_anymore()
  logs::LidarIsNotDeadAnymore lidar_is_not_dead_anymore_{};
  /// @see lidar_is_obstructed()
  logs::LidarIsObstructed lidar_is_obstructed_{};
  /// @see lidar_is_not_obstructed_anymore()
  logs::LidarIsNotObstructedAnymore lidar_is_not_obstructed_anymore_{};
  /// @see lidar_is_tilted()
  logs::LidarIsTilted lidar_is_tilted_{};
  /// @see lidar_is_not_tilted_anymore()
  logs::LidarIsNotTiltedAnymore lidar_is_not_tilted_anymore_{};
  /// @see lidar_has_been_automatically_recalibrated()
  logs::LidarHasBeenAutomaticallyRecalibrated lidar_has_been_automatically_recalibrated_{};
  /// @see received_first_data_for_lidar()
  logs::ReceivedFirstDataForLidar received_first_data_for_lidar_{};
  /// @see termination_failure_error()
  logs::TerminationFailureError termination_failure_error_{};
  /// @see frame_processing_error()
  logs::FrameProcessingError frame_processing_error_{};
  /// @see thread_pool_unavailable_error()
  logs::ThreadPoolUnavailableError thread_pool_unavailable_error_{};
  /// @see invalid_argument()
  logs::InvalidArgument invalid_argument_{};
  /// @see component_initialization_failure_fatal()
  logs::ComponentInitializationFailureFatal component_initialization_failure_fatal_{};
  /// @see unhandled_enum_case_error()
  logs::UnhandledEnumCaseError unhandled_enum_case_error_{};
  /// @see bag_empty_error()
  logs::BagEmptyError bag_empty_error_{};
  /// @see discarding_data_error()
  logs::DiscardingDataError discarding_data_error_{};
  /// @see discarding_data_warning()
  logs::DiscardingDataWarning discarding_data_warning_{};
  /// @see nothing_to_process()
  logs::NothingToProcess nothing_to_process_{};
  /// @see invalid_component_configuration()
  logs::InvalidComponentConfiguration invalid_component_configuration_{};
  /// @see channel_receiver_not_found_warning()
  logs::ChannelReceiverNotFoundWarning channel_receiver_not_found_warning_{};
  /// @see model_load_failure()
  logs::ModelLoadFailure model_load_failure_{};
  /// @see model_execution_failure_error()
  logs::ModelExecutionFailureError model_execution_failure_error_{};
  /// @see service_ready_info()
  logs::ServiceReadyInfo service_ready_info_{};
  /// @see model_preparing_info()
  logs::ModelPreparingInfo model_preparing_info_{};
  /// @see model_initialized_info()
  logs::ModelInitializedInfo model_initialized_info_{};
  /// @see model_initialization_failure_warning()
  logs::ModelInitializationFailureWarning model_initialization_failure_warning_{};
  /// @see ros_spinner_stopped_warning()
  logs::RosSpinnerStoppedWarning ros_spinner_stopped_warning_{};
  /// @see actor_system_unavailable_error()
  logs::ActorSystemUnavailableError actor_system_unavailable_error_{};
  /// @see config_node_not_found_error()
  logs::ConfigNodeNotFoundError config_node_not_found_error_{};
  /// @see bag_timestamp_out_of_order_error()
  logs::BagTimestampOutOfOrderError bag_timestamp_out_of_order_error_{};
  /// @see bag_replay_unexpected_timestamp_error()
  logs::BagReplayUnexpectedTimestampError bag_replay_unexpected_timestamp_error_{};
  /// @see websocket_closed_info()
  logs::WebsocketClosedInfo websocket_closed_info_{};
  /// @see websocket_opened_info()
  logs::WebsocketOpenedInfo websocket_opened_info_{};
  /// @see subscriber_disconnected_info()
  logs::SubscriberDisconnectedInfo subscriber_disconnected_info_{};
  /// @see thread_pool_slowing_down_warning()
  logs::ThreadPoolSlowingDownWarning thread_pool_slowing_down_warning_{};
  /// @see thread_pool_not_responding_warning()
  logs::ThreadPoolNotRespondingWarning thread_pool_not_responding_warning_{};
  /// @see thread_pool_broken_promise_warning()
  logs::ThreadPoolBrokenPromiseWarning thread_pool_broken_promise_warning_{};
  /// @see box_fitting_points_below_base_warning()
  logs::BoxFittingPointsBelowBaseWarning box_fitting_points_below_base_warning_{};
  /// @see failed_to_remove_stale_points_warning()
  logs::FailedToRemoveStalePointsWarning failed_to_remove_stale_points_warning_{};
  /// @see irregular_broadcasting_period_warning()
  logs::IrregularBroadcastingPeriodWarning irregular_broadcasting_period_warning_{};
  /// @see clusterer_points_out_of_range_warning()
  logs::ClustererPointsOutOfRangeWarning clusterer_points_out_of_range_warning_{};
  /// @see internal_error()
  logs::InternalError internal_error_{};
  /// @see internal_fatal()
  logs::InternalFatal internal_fatal_{};
  /// @see service_starting_info()
  logs::ServiceStartingInfo service_starting_info_{};
  /// @see config_node_not_found_fatal()
  logs::ConfigNodeNotFoundFatal config_node_not_found_fatal_{};
  /// @see service_setup_error()
  logs::ServiceSetupError service_setup_error_{};
  /// @see filesystem_error()
  logs::FilesystemError filesystem_error_{};
  /// @see invalid_preset_warning()
  logs::InvalidPresetWarning invalid_preset_warning_{};
  /// @see websocket_failed_clear_pending_error()
  logs::WebsocketFailedClearPendingError websocket_failed_clear_pending_error_{};
  /// @see websocket_failed_to_stop_error()
  logs::WebsocketFailedToStopError websocket_failed_to_stop_error_{};
  /// @see websocket_failed_to_create_error()
  logs::WebsocketFailedToCreateError websocket_failed_to_create_error_{};
  /// @see unexpected_rpc_error()
  logs::UnexpectedRpcError unexpected_rpc_error_{};
  /// @see license_poll_failed()
  logs::LicensePollFailed license_poll_failed_{};
  /// @see license_expired_warning()
  logs::LicenseExpiredWarning license_expired_warning_{};
  /// @see license_usage_exceeded_warning()
  logs::LicenseUsageExceededWarning license_usage_exceeded_warning_{};
  /// @see static_thread_pool_slow_task_warning()
  logs::StaticThreadPoolSlowTaskWarning static_thread_pool_slow_task_warning_{};
  /// @see rpc_unsupported_service_warning()
  logs::RpcUnsupportedServiceWarning rpc_unsupported_service_warning_{};
  /// @see websocket_handler_problem()
  logs::WebsocketHandlerProblem websocket_handler_problem_{};
  /// @see websocket_deserialize_error()
  logs::WebsocketDeserializeError websocket_deserialize_error_{};
  /// @see websocket_expired_rpc_endpoint_error()
  logs::WebsocketExpiredRpcEndpointError websocket_expired_rpc_endpoint_error_{};
  /// @see websocket_queue_overloaded_warning()
  logs::WebsocketQueueOverloadedWarning websocket_queue_overloaded_warning_{};
  /// @see rpc_failed_to_notify_warning()
  logs::RpcFailedToNotifyWarning rpc_failed_to_notify_warning_{};
  /// @see config_subscription_failed_warning()
  logs::ConfigSubscriptionFailedWarning config_subscription_failed_warning_{};
  /// @see thread_pool_clamped_workers_warning()
  logs::ThreadPoolClampedWorkersWarning thread_pool_clamped_workers_warning_{};
  /// @see stopping_horus_bag_recorder_already_stopped()
  logs::StoppingHorusBagRecorderAlreadyStopped stopping_horus_bag_recorder_already_stopped_{};
  /// @see recorder_config_update_while_running()
  logs::RecorderConfigUpdateWhileRunning recorder_config_update_while_running_{};
  /// @see clamping_data_warning()
  logs::ClampingDataWarning clamping_data_warning_{};
  /// @see lidar_incompatible_values()
  logs::LidarIncompatibleValues lidar_incompatible_values_{};
  /// @see cannot_determine_container_id_error()
  logs::CannotDetermineContainerIdError cannot_determine_container_id_error_{};
  /// @see started_lidar_driver()
  logs::StartedLidarDriver started_lidar_driver_{};
  /// @see cannot_start_lidar_driver()
  logs::CannotStartLidarDriver cannot_start_lidar_driver_{};
  /// @see stopped_lidar_driver()
  logs::StoppedLidarDriver stopped_lidar_driver_{};
  /// @see cannot_stop_lidar_driver()
  logs::CannotStopLidarDriver cannot_stop_lidar_driver_{};
  /// @see restarted_lidar_driver()
  logs::RestartedLidarDriver restarted_lidar_driver_{};
  /// @see cannot_restart_lidar_driver()
  logs::CannotRestartLidarDriver cannot_restart_lidar_driver_{};
  /// @see removed_unused_lidar_driver()
  logs::RemovedUnusedLidarDriver removed_unused_lidar_driver_{};
  /// @see cannot_remove_unused_lidar_driver()
  logs::CannotRemoveUnusedLidarDriver cannot_remove_unused_lidar_driver_{};
  /// @see lidar_driver_gc_failure()
  logs::LidarDriverGcFailure lidar_driver_gc_failure_{};
  /// @see id_space_exhausted()
  logs::IdSpaceExhausted id_space_exhausted_{};
  /// @see preprocessing_to_point_aggregator_points_skipped()
  logs::PreprocessingToPointAggregatorPointsSkipped preprocessing_to_point_aggregator_points_skipped_{};
  /// @see min_msg_interval_less_than_threshold()
  logs::MinMsgIntervalLessThanThreshold min_msg_interval_less_than_threshold_{};
  /// @see failed_to_cleanup_ros_warning()
  logs::FailedToCleanupRosWarning failed_to_cleanup_ros_warning_{};
  /// @see rpc_disconnected_warning()
  logs::RpcDisconnectedWarning rpc_disconnected_warning_{};
  /// @see rpc_unhandled_error()
  logs::RpcUnhandledError rpc_unhandled_error_{};
  /// @see time_diff_out_of_range_warning()
  logs::TimeDiffOutOfRangeWarning time_diff_out_of_range_warning_{};
  /// @see tensorrt_log()
  logs::TensorrtLog tensorrt_log_{};
  /// @see building_tensorrt_engine_info()
  logs::BuildingTensorrtEngineInfo building_tensorrt_engine_info_{};
  /// @see loading_tensorrt_engine_info()
  logs::LoadingTensorrtEngineInfo loading_tensorrt_engine_info_{};
  /// @see calibration_map_not_found()
  logs::CalibrationMapNotFound calibration_map_not_found_{};
  /// @see calibration_map_not_valid()
  logs::CalibrationMapNotValid calibration_map_not_valid_{};
  /// @see calibration_map_path_already_exists()
  logs::CalibrationMapPathAlreadyExists calibration_map_path_already_exists_{};
  /// @see failed_to_save_calibration_map()
  logs::FailedToSaveCalibrationMap failed_to_save_calibration_map_{};
  /// @see failed_to_remove_calibration_map()
  logs::FailedToRemoveCalibrationMap failed_to_remove_calibration_map_{};
  /// @see failed_to_iterate_in_directory()
  logs::FailedToIterateInDirectory failed_to_iterate_in_directory_{};
  /// @see map_based_calibration_without_map_loading()
  logs::MapBasedCalibrationWithoutMapLoading map_based_calibration_without_map_loading_{};
  /// @see map_based_calibration_already_running()
  logs::MapBasedCalibrationAlreadyRunning map_based_calibration_already_running_{};
  /// @see cancel_map_based_calibration_not_running()
  logs::CancelMapBasedCalibrationNotRunning cancel_map_based_calibration_not_running_{};
  /// @see bag_stream_not_found()
  logs::BagStreamNotFound bag_stream_not_found_{};
  /// @see evaluation_bag_started_info()
  logs::EvaluationBagStartedInfo evaluation_bag_started_info_{};
  /// @see evaluation_bag_finished_info()
  logs::EvaluationBagFinishedInfo evaluation_bag_finished_info_{};
  /// @see bag_not_found()
  logs::BagNotFound bag_not_found_{};
  /// @see building_pipeline_info()
  logs::BuildingPipelineInfo building_pipeline_info_{};
  /// @see bag_is_not_evaluation()
  logs::BagIsNotEvaluation bag_is_not_evaluation_{};
  /// @see horus_bag_running()
  logs::HorusBagRunning horus_bag_running_{};
  /// @see auto_ground_calibration_warning()
  logs::AutoGroundCalibrationWarning auto_ground_calibration_warning_{};
  /// @see auto_ground_calibration_error()
  logs::AutoGroundCalibrationError auto_ground_calibration_error_{};
  /// @see object_detector_not_loaded_warning()
  logs::ObjectDetectorNotLoadedWarning object_detector_not_loaded_warning_{};
  /// @see calibration_is_running_error()
  logs::CalibrationIsRunningError calibration_is_running_error_{};
  /// @see model_init_in_progress_info()
  logs::ModelInitInProgressInfo model_init_in_progress_info_{};
  /// @see rpc_timeout_with_resolution_warning()
  logs::RpcTimeoutWithResolutionWarning rpc_timeout_with_resolution_warning_{};
  /// @see calibration_was_cancelled_info()
  logs::CalibrationWasCancelledInfo calibration_was_cancelled_info_{};
  /// @see calibration_map_recording_failed_to_start()
  logs::CalibrationMapRecordingFailedToStart calibration_map_recording_failed_to_start_{};
  /// @see detection_pipeline_requested_reset_info()
  logs::DetectionPipelineRequestedResetInfo detection_pipeline_requested_reset_info_{};
  /// @see preprocessing_service_pipeline_unavailable()
  logs::PreprocessingServicePipelineUnavailable preprocessing_service_pipeline_unavailable_{};
  /// @see circular_recording_disabled_warning()
  logs::CircularRecordingDisabledWarning circular_recording_disabled_warning_{};
  /// @see snapshot_already_running_warning()
  logs::SnapshotAlreadyRunningWarning snapshot_already_running_warning_{};
  /// @see active_project_changed_info()
  logs::ActiveProjectChangedInfo active_project_changed_info_{};
  /// @see project_config_updated_info()
  logs::ProjectConfigUpdatedInfo project_config_updated_info_{};
  /// @see invalid_lidar_timestamp()
  logs::InvalidLidarTimestamp invalid_lidar_timestamp_{};
  /// @see calibration_accumulating_points_info()
  logs::CalibrationAccumulatingPointsInfo calibration_accumulating_points_info_{};
  /// @see sparse_noise_filter_usage_non_rotational_lidars()
  logs::SparseNoiseFilterUsageNonRotationalLidars sparse_noise_filter_usage_non_rotational_lidars_{};
  /// @see file_write_error()
  logs::FileWriteError file_write_error_{};
  /// @see license_forbidden_feature()
  logs::LicenseForbiddenFeature license_forbidden_feature_{};
  /// @see failed_to_update_configuration()
  logs::FailedToUpdateConfiguration failed_to_update_configuration_{};

  /// @see data_case()
  DataOneof data_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<168> set_fields_;
};

/// A log message notifying users about some status.
///
/// Source: horus/pb/logs/message.proto:9:1
class LogMessage final : public PbMessage {
 public:

  /// Constructs a default-initialized `LogMessage`.
  LogMessage() noexcept = default;

  /// Move constructor.
  LogMessage(LogMessage&&) noexcept = default;
  /// Move assignment operator.
  LogMessage& operator=(LogMessage&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LogMessage(const LogMessage& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LogMessage& operator=(const LogMessage&) = delete;

  /// Default destructor.
  ~LogMessage() noexcept final = default;

  /// Creates a `LogMessage` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LogMessage(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LogMessage`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LogMessage"; }

  /// The full name of the message: `horus.pb.LogMessage`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `metadata` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const LogMetadata& metadata() const& noexcept HORUS_LIFETIME_BOUND {
    return metadata_;
  }

  /// If `metadata` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  LogMetadata metadata() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(metadata_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  LogMetadata& mutable_metadata() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return metadata_;
  }

  /// Returns whether `metadata` (no 1) is set.
  constexpr bool has_metadata() const noexcept { return set_fields_[0]; }

  /// Clears `metadata` (no 1).
  void clear_metadata() & noexcept {
    set_fields_[0] = false;
    metadata_ = {};
  }

  /// Sets `metadata` (no 1) and returns `*this`.
  LogMessage& set_metadata(LogMetadata&& metadata) & noexcept {
    set_fields_[0] = true;
    metadata_ = std::move(metadata);
    return *this;
  }
  /// Sets `metadata` (no 1) and returns `*this`.
  LogMessage&& set_metadata(LogMetadata&& metadata) && noexcept {
    return std::move(set_metadata(std::move(metadata)));
  }

  // Field `data` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const LogData& data() const& noexcept HORUS_LIFETIME_BOUND {
    return data_;
  }

  /// If `data` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  LogData data() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(data_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  LogData& mutable_data() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return data_;
  }

  /// Returns whether `data` (no 2) is set.
  constexpr bool has_data() const noexcept { return set_fields_[1]; }

  /// Clears `data` (no 2).
  void clear_data() & noexcept {
    set_fields_[1] = false;
    data_ = {};
  }

  /// Sets `data` (no 2) and returns `*this`.
  LogMessage& set_data(LogData&& data) & noexcept {
    set_fields_[1] = true;
    data_ = std::move(data);
    return *this;
  }
  /// Sets `data` (no 2) and returns `*this`.
  LogMessage&& set_data(LogData&& data) && noexcept {
    return std::move(set_data(std::move(data)));
  }

 private:
  /// @see metadata()
  LogMetadata metadata_{};
  /// @see data()
  LogData data_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_LOGS_MESSAGE_PB_H_
