#ifndef HORUS_PB_PROJECT_MANAGER_SERVICE_PB_H_
#define HORUS_PB_PROJECT_MANAGER_SERVICE_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/project_manager/service.proto`.
///
/// Generated by `/opt/actions-runner/_work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/cow_bytes.h"
#include "horus/pb/cow_repeated.h"
#include "horus/pb/license_server/messages_pb.h"
#include "horus/pb/logs/logs_pb.h"
#include "horus/pb/message.h"
#include "horus/pb/preprocessing/messages_pb.h"
#include "horus/pb/serialize.h"
#include "horus/pb/types.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Enum declarations

/// Different actions allowed by a license level
///  Encoded through a bitwise encoding
///
/// Source: horus/pb/project_manager/service.proto:31:1
enum class LicensePrivilege : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// ---------- LEVEL 1 ----------
  ///  Generic privilege granted by each level.
  kLowest = 1,
  /// Allow calls to RPC endpoint Subscribe().
  kSubscribe = 2,
  /// ---------- LEVEL 2 ----------
  ///  Allow calls to license management RPC endpoints:
  ///  GetLicenseStatus, DownloadLicenseKeyFile, UploadLicenseKey
  kLicenseActions = 4,
  /// ---------- LEVEL 3 ----------
  ///  Allow any read action on config.
  kRead = 8,
  /// ---------- LEVEL 4 ----------
  ///  Allow any config changes.
  kWrite = 16,

  /// Unknown value read from the wire.
  kUnknownWireValue = 17,
};

/// Service represented by the node.
///
/// Source: horus/pb/project_manager/service.proto:127:5
enum class GetHealthStatusResponse_NodeHealth_Service : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// No documentation.
  kDetection = 1,
  /// No documentation.
  kLidarRunner = 2,
  /// No documentation.
  kNotification = 3,
  /// No documentation.
  kPointAggregator = 4,
  /// No documentation.
  kPreprocessing = 5,
  /// No documentation.
  kProjectManager = 6,

  /// Unknown value read from the wire.
  kUnknownWireValue = 7,
};

/// Connectivity status.
///
/// Source: horus/pb/project_manager/service.proto:138:5
enum class GetHealthStatusResponse_NodeHealth_Status : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// No documentation.
  kUnreachable = 1,
  /// No documentation.
  kAlive = 2,

  /// Unknown value read from the wire.
  kUnknownWireValue = 3,
};

// MARK: Message forward declarations

class LicenseLevel_Level1;
class LicenseLevel_Level2;
class LicenseLevel_Level3;
class LicenseLevel_Level4;
class LicenseLevel;
class LicenseStatus;
class GetHealthStatusRequest;
class GetHealthStatusResponse_NodeHealth;
class GetHealthStatusResponse_SensorHealth;
class GetHealthStatusResponse_NodeResources;
class GetHealthStatusResponse;

// MARK: Message declarations

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:68:3
class LicenseLevel_Level1 final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseLevel_Level1`.
  LicenseLevel_Level1() noexcept = default;

  /// Move constructor.
  LicenseLevel_Level1(LicenseLevel_Level1&&) noexcept = default;
  /// Move assignment operator.
  LicenseLevel_Level1& operator=(LicenseLevel_Level1&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseLevel_Level1(const LicenseLevel_Level1& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseLevel_Level1& operator=(const LicenseLevel_Level1&) = delete;

  /// Default destructor.
  ~LicenseLevel_Level1() noexcept final = default;

  /// Creates a `LicenseLevel_Level1` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseLevel_Level1(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseLevel.Level1`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseLevel.Level1"; }

  /// The full name of the message: `horus.pb.LicenseLevel.Level1`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_server_unreachable` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::LicenseServerConnectionError& license_server_unreachable() const& noexcept HORUS_LIFETIME_BOUND {
    return license_server_unreachable_;
  }

  /// If `license_server_unreachable` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::LicenseServerConnectionError license_server_unreachable() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_server_unreachable_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::LicenseServerConnectionError& mutable_license_server_unreachable() & noexcept HORUS_LIFETIME_BOUND {
    clear_reason();
    reason_ = ReasonOneof::kLicenseServerUnreachable;
    set_fields_[0] = true;
    return license_server_unreachable_;
  }

  /// Returns whether `license_server_unreachable` (no 1) is set.
  constexpr bool has_license_server_unreachable() const noexcept { return set_fields_[0]; }

  /// Clears `license_server_unreachable` (no 1).
  void clear_license_server_unreachable() & noexcept {
    reason_ = {};
    set_fields_[0] = false;
    license_server_unreachable_ = {};
  }

  /// Sets `license_server_unreachable` (no 1) and returns `*this`.
  LicenseLevel_Level1& set_license_server_unreachable(logs::LicenseServerConnectionError&& license_server_unreachable) & noexcept {
    clear_reason();
    reason_ = ReasonOneof::kLicenseServerUnreachable;
    set_fields_[0] = true;
    license_server_unreachable_ = std::move(license_server_unreachable);
    return *this;
  }
  /// Sets `license_server_unreachable` (no 1) and returns `*this`.
  LicenseLevel_Level1&& set_license_server_unreachable(logs::LicenseServerConnectionError&& license_server_unreachable) && noexcept {
    return std::move(set_license_server_unreachable(std::move(license_server_unreachable)));
  }

  // Oneof `reason`.
  // -----

  /// Return value of `reason_case()`.
  enum class ReasonOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see license_server_unreachable()
    kLicenseServerUnreachable = 1,
  };

  /// Returns the current case set in `reason`.
  constexpr ReasonOneof reason_case() const noexcept {
    return reason_;
  }

  /// Clears the oneof value in `reason`.
  void clear_reason() noexcept {
    switch (reason_) {
      case ReasonOneof::kLicenseServerUnreachable: {
        clear_license_server_unreachable();
        break;
      }
      case ReasonOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see license_server_unreachable()
  logs::LicenseServerConnectionError license_server_unreachable_{};

  /// @see reason_case()
  ReasonOneof reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:73:3
class LicenseLevel_Level2 final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseLevel_Level2`.
  LicenseLevel_Level2() noexcept = default;

  /// Move constructor.
  LicenseLevel_Level2(LicenseLevel_Level2&&) noexcept = default;
  /// Move assignment operator.
  LicenseLevel_Level2& operator=(LicenseLevel_Level2&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseLevel_Level2(const LicenseLevel_Level2& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseLevel_Level2& operator=(const LicenseLevel_Level2&) = delete;

  /// Default destructor.
  ~LicenseLevel_Level2() noexcept final = default;

  /// Creates a `LicenseLevel_Level2` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseLevel_Level2(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseLevel.Level2`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseLevel.Level2"; }

  /// The full name of the message: `horus.pb.LicenseLevel.Level2`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_not_found` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::LicenseNotFoundError& license_not_found() const& noexcept HORUS_LIFETIME_BOUND {
    return license_not_found_;
  }

  /// If `license_not_found` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::LicenseNotFoundError license_not_found() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_not_found_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::LicenseNotFoundError& mutable_license_not_found() & noexcept HORUS_LIFETIME_BOUND {
    clear_reason();
    reason_ = ReasonOneof::kLicenseNotFound;
    set_fields_[0] = true;
    return license_not_found_;
  }

  /// Returns whether `license_not_found` (no 1) is set.
  constexpr bool has_license_not_found() const noexcept { return set_fields_[0]; }

  /// Clears `license_not_found` (no 1).
  void clear_license_not_found() & noexcept {
    reason_ = {};
    set_fields_[0] = false;
    license_not_found_ = {};
  }

  /// Sets `license_not_found` (no 1) and returns `*this`.
  LicenseLevel_Level2& set_license_not_found(logs::LicenseNotFoundError&& license_not_found) & noexcept {
    clear_reason();
    reason_ = ReasonOneof::kLicenseNotFound;
    set_fields_[0] = true;
    license_not_found_ = std::move(license_not_found);
    return *this;
  }
  /// Sets `license_not_found` (no 1) and returns `*this`.
  LicenseLevel_Level2&& set_license_not_found(logs::LicenseNotFoundError&& license_not_found) && noexcept {
    return std::move(set_license_not_found(std::move(license_not_found)));
  }

  // Oneof `reason`.
  // -----

  /// Return value of `reason_case()`.
  enum class ReasonOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see license_not_found()
    kLicenseNotFound = 1,
  };

  /// Returns the current case set in `reason`.
  constexpr ReasonOneof reason_case() const noexcept {
    return reason_;
  }

  /// Clears the oneof value in `reason`.
  void clear_reason() noexcept {
    switch (reason_) {
      case ReasonOneof::kLicenseNotFound: {
        clear_license_not_found();
        break;
      }
      case ReasonOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see license_not_found()
  logs::LicenseNotFoundError license_not_found_{};

  /// @see reason_case()
  ReasonOneof reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:78:3
class LicenseLevel_Level3 final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseLevel_Level3`.
  LicenseLevel_Level3() noexcept = default;

  /// Move constructor.
  LicenseLevel_Level3(LicenseLevel_Level3&&) noexcept = default;
  /// Move assignment operator.
  LicenseLevel_Level3& operator=(LicenseLevel_Level3&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseLevel_Level3(const LicenseLevel_Level3& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseLevel_Level3& operator=(const LicenseLevel_Level3&) = delete;

  /// Default destructor.
  ~LicenseLevel_Level3() noexcept final = default;

  /// Creates a `LicenseLevel_Level3` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseLevel_Level3(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseLevel.Level3`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseLevel.Level3"; }

  /// The full name of the message: `horus.pb.LicenseLevel.Level3`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_expired` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::LicenseExpiredError& license_expired() const& noexcept HORUS_LIFETIME_BOUND {
    return license_expired_;
  }

  /// If `license_expired` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::LicenseExpiredError license_expired() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_expired_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::LicenseExpiredError& mutable_license_expired() & noexcept HORUS_LIFETIME_BOUND {
    clear_reason();
    reason_ = ReasonOneof::kLicenseExpired;
    set_fields_[0] = true;
    return license_expired_;
  }

  /// Returns whether `license_expired` (no 1) is set.
  constexpr bool has_license_expired() const noexcept { return set_fields_[0]; }

  /// Clears `license_expired` (no 1).
  void clear_license_expired() & noexcept {
    reason_ = {};
    set_fields_[0] = false;
    license_expired_ = {};
  }

  /// Sets `license_expired` (no 1) and returns `*this`.
  LicenseLevel_Level3& set_license_expired(logs::LicenseExpiredError&& license_expired) & noexcept {
    clear_reason();
    reason_ = ReasonOneof::kLicenseExpired;
    set_fields_[0] = true;
    license_expired_ = std::move(license_expired);
    return *this;
  }
  /// Sets `license_expired` (no 1) and returns `*this`.
  LicenseLevel_Level3&& set_license_expired(logs::LicenseExpiredError&& license_expired) && noexcept {
    return std::move(set_license_expired(std::move(license_expired)));
  }

  // Field `license_server_disconnected` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const logs::LicenseServerConnectionError& license_server_disconnected() const& noexcept HORUS_LIFETIME_BOUND {
    return license_server_disconnected_;
  }

  /// If `license_server_disconnected` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  logs::LicenseServerConnectionError license_server_disconnected() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(license_server_disconnected_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  logs::LicenseServerConnectionError& mutable_license_server_disconnected() & noexcept HORUS_LIFETIME_BOUND {
    clear_reason();
    reason_ = ReasonOneof::kLicenseServerDisconnected;
    set_fields_[1] = true;
    return license_server_disconnected_;
  }

  /// Returns whether `license_server_disconnected` (no 2) is set.
  constexpr bool has_license_server_disconnected() const noexcept { return set_fields_[1]; }

  /// Clears `license_server_disconnected` (no 2).
  void clear_license_server_disconnected() & noexcept {
    reason_ = {};
    set_fields_[1] = false;
    license_server_disconnected_ = {};
  }

  /// Sets `license_server_disconnected` (no 2) and returns `*this`.
  LicenseLevel_Level3& set_license_server_disconnected(logs::LicenseServerConnectionError&& license_server_disconnected) & noexcept {
    clear_reason();
    reason_ = ReasonOneof::kLicenseServerDisconnected;
    set_fields_[1] = true;
    license_server_disconnected_ = std::move(license_server_disconnected);
    return *this;
  }
  /// Sets `license_server_disconnected` (no 2) and returns `*this`.
  LicenseLevel_Level3&& set_license_server_disconnected(logs::LicenseServerConnectionError&& license_server_disconnected) && noexcept {
    return std::move(set_license_server_disconnected(std::move(license_server_disconnected)));
  }

  // Oneof `reason`.
  // -----

  /// Return value of `reason_case()`.
  enum class ReasonOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see license_expired()
    kLicenseExpired = 1,
    /// @see license_server_disconnected()
    kLicenseServerDisconnected = 2,
  };

  /// Returns the current case set in `reason`.
  constexpr ReasonOneof reason_case() const noexcept {
    return reason_;
  }

  /// Clears the oneof value in `reason`.
  void clear_reason() noexcept {
    switch (reason_) {
      case ReasonOneof::kLicenseExpired: {
        clear_license_expired();
        break;
      }
      case ReasonOneof::kLicenseServerDisconnected: {
        clear_license_server_disconnected();
        break;
      }
      case ReasonOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see license_expired()
  logs::LicenseExpiredError license_expired_{};
  /// @see license_server_disconnected()
  logs::LicenseServerConnectionError license_server_disconnected_{};

  /// @see reason_case()
  ReasonOneof reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:84:3
class LicenseLevel_Level4 final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseLevel_Level4`.
  LicenseLevel_Level4() noexcept = default;

  /// Move constructor.
  LicenseLevel_Level4(LicenseLevel_Level4&&) noexcept = default;
  /// Move assignment operator.
  LicenseLevel_Level4& operator=(LicenseLevel_Level4&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseLevel_Level4(const LicenseLevel_Level4& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseLevel_Level4& operator=(const LicenseLevel_Level4&) = delete;

  /// Default destructor.
  ~LicenseLevel_Level4() noexcept final = default;

  /// Creates a `LicenseLevel_Level4` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseLevel_Level4(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseLevel.Level4`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseLevel.Level4"; }

  /// The full name of the message: `horus.pb.LicenseLevel.Level4`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_active` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const logs::LicenseActiveInfo& license_active() const& noexcept HORUS_LIFETIME_BOUND {
    return license_active_;
  }

  /// If `license_active` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  logs::LicenseActiveInfo license_active() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_active_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  logs::LicenseActiveInfo& mutable_license_active() & noexcept HORUS_LIFETIME_BOUND {
    clear_reason();
    reason_ = ReasonOneof::kLicenseActive;
    set_fields_[0] = true;
    return license_active_;
  }

  /// Returns whether `license_active` (no 1) is set.
  constexpr bool has_license_active() const noexcept { return set_fields_[0]; }

  /// Clears `license_active` (no 1).
  void clear_license_active() & noexcept {
    reason_ = {};
    set_fields_[0] = false;
    license_active_ = {};
  }

  /// Sets `license_active` (no 1) and returns `*this`.
  LicenseLevel_Level4& set_license_active(logs::LicenseActiveInfo&& license_active) & noexcept {
    clear_reason();
    reason_ = ReasonOneof::kLicenseActive;
    set_fields_[0] = true;
    license_active_ = std::move(license_active);
    return *this;
  }
  /// Sets `license_active` (no 1) and returns `*this`.
  LicenseLevel_Level4&& set_license_active(logs::LicenseActiveInfo&& license_active) && noexcept {
    return std::move(set_license_active(std::move(license_active)));
  }

  // Oneof `reason`.
  // -----

  /// Return value of `reason_case()`.
  enum class ReasonOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see license_active()
    kLicenseActive = 1,
  };

  /// Returns the current case set in `reason`.
  constexpr ReasonOneof reason_case() const noexcept {
    return reason_;
  }

  /// Clears the oneof value in `reason`.
  void clear_reason() noexcept {
    switch (reason_) {
      case ReasonOneof::kLicenseActive: {
        clear_license_active();
        break;
      }
      case ReasonOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see license_active()
  logs::LicenseActiveInfo license_active_{};

  /// @see reason_case()
  ReasonOneof reason_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:54:1
class LicenseLevel final : public PbMessage {
 public:
  /// @see LicenseLevel_Level1
  using Level1 = LicenseLevel_Level1;
  /// @see LicenseLevel_Level2
  using Level2 = LicenseLevel_Level2;
  /// @see LicenseLevel_Level3
  using Level3 = LicenseLevel_Level3;
  /// @see LicenseLevel_Level4
  using Level4 = LicenseLevel_Level4;

  /// Constructs a default-initialized `LicenseLevel`.
  LicenseLevel() noexcept = default;

  /// Move constructor.
  LicenseLevel(LicenseLevel&&) noexcept = default;
  /// Move assignment operator.
  LicenseLevel& operator=(LicenseLevel&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseLevel(const LicenseLevel& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseLevel& operator=(const LicenseLevel&) = delete;

  /// Default destructor.
  ~LicenseLevel() noexcept final = default;

  /// Creates a `LicenseLevel` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseLevel(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseLevel`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseLevel"; }

  /// The full name of the message: `horus.pb.LicenseLevel`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `level_1` (no 10).
  // -----

  /// No documentation.
  ///
  /// Field no: 10.
  constexpr const LicenseLevel_Level1& level_1() const& noexcept HORUS_LIFETIME_BOUND {
    return level_1_;
  }

  /// If `level_1` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 10.
  LicenseLevel_Level1 level_1() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(level_1_);
  }

  /// No documentation.
  ///
  /// Field no: 10.
  LicenseLevel_Level1& mutable_level_1() & noexcept HORUS_LIFETIME_BOUND {
    clear_level();
    level_ = LevelOneof::kLevel1;
    set_fields_[0] = true;
    return level_1_;
  }

  /// Returns whether `level_1` (no 10) is set.
  constexpr bool has_level_1() const noexcept { return set_fields_[0]; }

  /// Clears `level_1` (no 10).
  void clear_level_1() & noexcept {
    level_ = {};
    set_fields_[0] = false;
    level_1_ = {};
  }

  /// Sets `level_1` (no 10) and returns `*this`.
  LicenseLevel& set_level_1(LicenseLevel_Level1&& level_1) & noexcept {
    clear_level();
    level_ = LevelOneof::kLevel1;
    set_fields_[0] = true;
    level_1_ = std::move(level_1);
    return *this;
  }
  /// Sets `level_1` (no 10) and returns `*this`.
  LicenseLevel&& set_level_1(LicenseLevel_Level1&& level_1) && noexcept {
    return std::move(set_level_1(std::move(level_1)));
  }

  // Field `level_2` (no 20).
  // -----

  /// No documentation.
  ///
  /// Field no: 20.
  constexpr const LicenseLevel_Level2& level_2() const& noexcept HORUS_LIFETIME_BOUND {
    return level_2_;
  }

  /// If `level_2` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 20.
  LicenseLevel_Level2 level_2() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(level_2_);
  }

  /// No documentation.
  ///
  /// Field no: 20.
  LicenseLevel_Level2& mutable_level_2() & noexcept HORUS_LIFETIME_BOUND {
    clear_level();
    level_ = LevelOneof::kLevel2;
    set_fields_[1] = true;
    return level_2_;
  }

  /// Returns whether `level_2` (no 20) is set.
  constexpr bool has_level_2() const noexcept { return set_fields_[1]; }

  /// Clears `level_2` (no 20).
  void clear_level_2() & noexcept {
    level_ = {};
    set_fields_[1] = false;
    level_2_ = {};
  }

  /// Sets `level_2` (no 20) and returns `*this`.
  LicenseLevel& set_level_2(LicenseLevel_Level2&& level_2) & noexcept {
    clear_level();
    level_ = LevelOneof::kLevel2;
    set_fields_[1] = true;
    level_2_ = std::move(level_2);
    return *this;
  }
  /// Sets `level_2` (no 20) and returns `*this`.
  LicenseLevel&& set_level_2(LicenseLevel_Level2&& level_2) && noexcept {
    return std::move(set_level_2(std::move(level_2)));
  }

  // Field `level_3` (no 30).
  // -----

  /// No documentation.
  ///
  /// Field no: 30.
  constexpr const LicenseLevel_Level3& level_3() const& noexcept HORUS_LIFETIME_BOUND {
    return level_3_;
  }

  /// If `level_3` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 30.
  LicenseLevel_Level3 level_3() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(level_3_);
  }

  /// No documentation.
  ///
  /// Field no: 30.
  LicenseLevel_Level3& mutable_level_3() & noexcept HORUS_LIFETIME_BOUND {
    clear_level();
    level_ = LevelOneof::kLevel3;
    set_fields_[2] = true;
    return level_3_;
  }

  /// Returns whether `level_3` (no 30) is set.
  constexpr bool has_level_3() const noexcept { return set_fields_[2]; }

  /// Clears `level_3` (no 30).
  void clear_level_3() & noexcept {
    level_ = {};
    set_fields_[2] = false;
    level_3_ = {};
  }

  /// Sets `level_3` (no 30) and returns `*this`.
  LicenseLevel& set_level_3(LicenseLevel_Level3&& level_3) & noexcept {
    clear_level();
    level_ = LevelOneof::kLevel3;
    set_fields_[2] = true;
    level_3_ = std::move(level_3);
    return *this;
  }
  /// Sets `level_3` (no 30) and returns `*this`.
  LicenseLevel&& set_level_3(LicenseLevel_Level3&& level_3) && noexcept {
    return std::move(set_level_3(std::move(level_3)));
  }

  // Field `level_4` (no 40).
  // -----

  /// No documentation.
  ///
  /// Field no: 40.
  constexpr const LicenseLevel_Level4& level_4() const& noexcept HORUS_LIFETIME_BOUND {
    return level_4_;
  }

  /// If `level_4` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 40.
  LicenseLevel_Level4 level_4() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(level_4_);
  }

  /// No documentation.
  ///
  /// Field no: 40.
  LicenseLevel_Level4& mutable_level_4() & noexcept HORUS_LIFETIME_BOUND {
    clear_level();
    level_ = LevelOneof::kLevel4;
    set_fields_[3] = true;
    return level_4_;
  }

  /// Returns whether `level_4` (no 40) is set.
  constexpr bool has_level_4() const noexcept { return set_fields_[3]; }

  /// Clears `level_4` (no 40).
  void clear_level_4() & noexcept {
    level_ = {};
    set_fields_[3] = false;
    level_4_ = {};
  }

  /// Sets `level_4` (no 40) and returns `*this`.
  LicenseLevel& set_level_4(LicenseLevel_Level4&& level_4) & noexcept {
    clear_level();
    level_ = LevelOneof::kLevel4;
    set_fields_[3] = true;
    level_4_ = std::move(level_4);
    return *this;
  }
  /// Sets `level_4` (no 40) and returns `*this`.
  LicenseLevel&& set_level_4(LicenseLevel_Level4&& level_4) && noexcept {
    return std::move(set_level_4(std::move(level_4)));
  }

  // Field `privilege` (no 60).
  // -----

  /// Bitset of granted privileges; hard-coded for each level.
  ///  Refers to LicensePrivilege.
  ///
  /// Field no: 60.
  constexpr std::uint32_t privilege() const& noexcept HORUS_LIFETIME_BOUND {
    return privilege_;
  }

  /// Bitset of granted privileges; hard-coded for each level.
  ///  Refers to LicensePrivilege.
  ///
  /// Field no: 60.
  std::uint32_t& mutable_privilege() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[4] = true;
    return privilege_;
  }

  /// Returns whether `privilege` (no 60) is set.
  constexpr bool has_privilege() const noexcept { return set_fields_[4]; }

  /// Clears `privilege` (no 60).
  void clear_privilege() & noexcept {
    set_fields_[4] = false;
    privilege_ = {};
  }

  /// Sets `privilege` (no 60) and returns `*this`.
  LicenseLevel& set_privilege(std::uint32_t privilege) & noexcept {
    set_fields_[4] = true;
    privilege_ = privilege;
    return *this;
  }
  /// Sets `privilege` (no 60) and returns `*this`.
  LicenseLevel&& set_privilege(std::uint32_t privilege) && noexcept {
    return std::move(set_privilege(privilege));
  }

  // Oneof `level`.
  // -----

  /// Return value of `level_case()`.
  enum class LevelOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see level_1()
    kLevel1 = 10,
    /// @see level_2()
    kLevel2 = 20,
    /// @see level_3()
    kLevel3 = 30,
    /// @see level_4()
    kLevel4 = 40,
  };

  /// Returns the current case set in `level`.
  constexpr LevelOneof level_case() const noexcept {
    return level_;
  }

  /// Clears the oneof value in `level`.
  void clear_level() noexcept {
    switch (level_) {
      case LevelOneof::kLevel1: {
        clear_level_1();
        break;
      }
      case LevelOneof::kLevel2: {
        clear_level_2();
        break;
      }
      case LevelOneof::kLevel3: {
        clear_level_3();
        break;
      }
      case LevelOneof::kLevel4: {
        clear_level_4();
        break;
      }
      case LevelOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see level_1()
  LicenseLevel_Level1 level_1_{};
  /// @see level_2()
  LicenseLevel_Level2 level_2_{};
  /// @see level_3()
  LicenseLevel_Level3 level_3_{};
  /// @see level_4()
  LicenseLevel_Level4 level_4_{};
  /// @see privilege()
  std::uint32_t privilege_{};

  /// @see level_case()
  LevelOneof level_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<5> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:91:1
class LicenseStatus final : public PbMessage {
 public:

  /// Constructs a default-initialized `LicenseStatus`.
  LicenseStatus() noexcept = default;

  /// Move constructor.
  LicenseStatus(LicenseStatus&&) noexcept = default;
  /// Move assignment operator.
  LicenseStatus& operator=(LicenseStatus&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LicenseStatus(const LicenseStatus& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LicenseStatus& operator=(const LicenseStatus&) = delete;

  /// Default destructor.
  ~LicenseStatus() noexcept final = default;

  /// Creates a `LicenseStatus` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LicenseStatus(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LicenseStatus`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LicenseStatus"; }

  /// The full name of the message: `horus.pb.LicenseStatus`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_level` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const LicenseLevel& license_level() const& noexcept HORUS_LIFETIME_BOUND {
    return license_level_;
  }

  /// If `license_level` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  LicenseLevel license_level() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_level_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  LicenseLevel& mutable_license_level() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return license_level_;
  }

  /// Returns whether `license_level` (no 1) is set.
  constexpr bool has_license_level() const noexcept { return set_fields_[0]; }

  /// Clears `license_level` (no 1).
  void clear_license_level() & noexcept {
    set_fields_[0] = false;
    license_level_ = {};
  }

  /// Sets `license_level` (no 1) and returns `*this`.
  LicenseStatus& set_license_level(LicenseLevel&& license_level) & noexcept {
    set_fields_[0] = true;
    license_level_ = std::move(license_level);
    return *this;
  }
  /// Sets `license_level` (no 1) and returns `*this`.
  LicenseStatus&& set_license_level(LicenseLevel&& license_level) && noexcept {
    return std::move(set_license_level(std::move(license_level)));
  }

  // Field `license_info` (no 2).
  // -----

  /// If level is inferior to 3, this field is unset
  ///
  /// Field no: 2.
  constexpr const LicenseInfo& license_info() const& noexcept HORUS_LIFETIME_BOUND {
    return license_info_;
  }

  /// If `license_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  LicenseInfo license_info() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(license_info_);
  }

  /// If level is inferior to 3, this field is unset
  ///
  /// Field no: 2.
  LicenseInfo& mutable_license_info() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return license_info_;
  }

  /// Returns whether `license_info` (no 2) is set.
  constexpr bool has_license_info() const noexcept { return set_fields_[1]; }

  /// Clears `license_info` (no 2).
  void clear_license_info() & noexcept {
    set_fields_[1] = false;
    license_info_ = {};
  }

  /// Sets `license_info` (no 2) and returns `*this`.
  LicenseStatus& set_license_info(LicenseInfo&& license_info) & noexcept {
    set_fields_[1] = true;
    license_info_ = std::move(license_info);
    return *this;
  }
  /// Sets `license_info` (no 2) and returns `*this`.
  LicenseStatus&& set_license_info(LicenseInfo&& license_info) && noexcept {
    return std::move(set_license_info(std::move(license_info)));
  }

 private:
  /// @see license_level()
  LicenseLevel license_level_{};
  /// @see license_info()
  LicenseInfo license_info_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/project_manager/service.proto:116:1
class GetHealthStatusRequest final : public PbMessage {
 public:

  /// Constructs a default-initialized `GetHealthStatusRequest`.
  GetHealthStatusRequest() noexcept = default;

  /// Move constructor.
  GetHealthStatusRequest(GetHealthStatusRequest&&) noexcept = default;
  /// Move assignment operator.
  GetHealthStatusRequest& operator=(GetHealthStatusRequest&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit GetHealthStatusRequest(const GetHealthStatusRequest&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  GetHealthStatusRequest& operator=(const GetHealthStatusRequest&) = delete;

  /// Default destructor.
  ~GetHealthStatusRequest() noexcept final = default;

  /// Creates a `GetHealthStatusRequest` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit GetHealthStatusRequest(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.GetHealthStatusRequest`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.GetHealthStatusRequest"; }

  /// The full name of the message: `horus.pb.GetHealthStatusRequest`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Connectivity status of a single node.
///
/// Source: horus/pb/project_manager/service.proto:125:3
class GetHealthStatusResponse_NodeHealth final : public PbMessage {
 public:
  /// @see GetHealthStatusResponse_NodeHealth_Service
  using Service = GetHealthStatusResponse_NodeHealth_Service;
  /// @see GetHealthStatusResponse_NodeHealth_Status
  using Status = GetHealthStatusResponse_NodeHealth_Status;

  /// Constructs a default-initialized `GetHealthStatusResponse_NodeHealth`.
  GetHealthStatusResponse_NodeHealth() noexcept = default;

  /// Move constructor.
  GetHealthStatusResponse_NodeHealth(GetHealthStatusResponse_NodeHealth&&) noexcept = default;
  /// Move assignment operator.
  GetHealthStatusResponse_NodeHealth& operator=(GetHealthStatusResponse_NodeHealth&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit GetHealthStatusResponse_NodeHealth(const GetHealthStatusResponse_NodeHealth& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  GetHealthStatusResponse_NodeHealth& operator=(const GetHealthStatusResponse_NodeHealth&) = delete;

  /// Default destructor.
  ~GetHealthStatusResponse_NodeHealth() noexcept final = default;

  /// Creates a `GetHealthStatusResponse_NodeHealth` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit GetHealthStatusResponse_NodeHealth(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.NodeHealth`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.GetHealthStatusResponse.NodeHealth"; }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.NodeHealth`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `service` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr GetHealthStatusResponse_NodeHealth_Service service() const& noexcept HORUS_LIFETIME_BOUND {
    return service_;
  }

  /// No documentation.
  ///
  /// Field no: 1.
  GetHealthStatusResponse_NodeHealth_Service& mutable_service() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return service_;
  }

  /// Returns whether `service` (no 1) is set.
  constexpr bool has_service() const noexcept { return set_fields_[0]; }

  /// Clears `service` (no 1).
  void clear_service() & noexcept {
    set_fields_[0] = false;
    service_ = {};
  }

  /// Sets `service` (no 1) and returns `*this`.
  GetHealthStatusResponse_NodeHealth& set_service(GetHealthStatusResponse_NodeHealth_Service service) & noexcept {
    set_fields_[0] = true;
    service_ = service;
    return *this;
  }
  /// Sets `service` (no 1) and returns `*this`.
  GetHealthStatusResponse_NodeHealth&& set_service(GetHealthStatusResponse_NodeHealth_Service service) && noexcept {
    return std::move(set_service(service));
  }

  // Field `node_id` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const CowBytes& node_id() const& noexcept HORUS_LIFETIME_BOUND {
    return node_id_;
  }

  /// If `node_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowBytes node_id() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(node_id_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  CowBytes& mutable_node_id() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return node_id_;
  }

  /// Returns whether `node_id` (no 2) is set.
  constexpr bool has_node_id() const noexcept { return set_fields_[1]; }

  /// Clears `node_id` (no 2).
  void clear_node_id() & noexcept {
    set_fields_[1] = false;
    node_id_ = {};
  }

  /// Sets `node_id` (no 2) and returns `*this`.
  GetHealthStatusResponse_NodeHealth& set_node_id(CowBytes&& node_id) & noexcept {
    set_fields_[1] = true;
    node_id_ = std::move(node_id);
    return *this;
  }
  /// Sets `node_id` (no 2) and returns `*this`.
  GetHealthStatusResponse_NodeHealth&& set_node_id(CowBytes&& node_id) && noexcept {
    return std::move(set_node_id(std::move(node_id)));
  }

  // Field `node_status` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr GetHealthStatusResponse_NodeHealth_Status node_status() const& noexcept HORUS_LIFETIME_BOUND {
    return node_status_;
  }

  /// No documentation.
  ///
  /// Field no: 3.
  GetHealthStatusResponse_NodeHealth_Status& mutable_node_status() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return node_status_;
  }

  /// Returns whether `node_status` (no 3) is set.
  constexpr bool has_node_status() const noexcept { return set_fields_[2]; }

  /// Clears `node_status` (no 3).
  void clear_node_status() & noexcept {
    set_fields_[2] = false;
    node_status_ = {};
  }

  /// Sets `node_status` (no 3) and returns `*this`.
  GetHealthStatusResponse_NodeHealth& set_node_status(GetHealthStatusResponse_NodeHealth_Status node_status) & noexcept {
    set_fields_[2] = true;
    node_status_ = node_status;
    return *this;
  }
  /// Sets `node_status` (no 3) and returns `*this`.
  GetHealthStatusResponse_NodeHealth&& set_node_status(GetHealthStatusResponse_NodeHealth_Status node_status) && noexcept {
    return std::move(set_node_status(node_status));
  }

 private:
  /// @see service()
  GetHealthStatusResponse_NodeHealth_Service service_{};
  /// @see node_id()
  CowBytes node_id_{};
  /// @see node_status()
  GetHealthStatusResponse_NodeHealth_Status node_status_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Wraps SensorInfo with node unreachable error
///
/// Source: horus/pb/project_manager/service.proto:149:3
class GetHealthStatusResponse_SensorHealth final : public PbMessage {
 public:

  /// Constructs a default-initialized `GetHealthStatusResponse_SensorHealth`.
  GetHealthStatusResponse_SensorHealth() noexcept = default;

  /// Move constructor.
  GetHealthStatusResponse_SensorHealth(GetHealthStatusResponse_SensorHealth&&) noexcept = default;
  /// Move assignment operator.
  GetHealthStatusResponse_SensorHealth& operator=(GetHealthStatusResponse_SensorHealth&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit GetHealthStatusResponse_SensorHealth(const GetHealthStatusResponse_SensorHealth& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  GetHealthStatusResponse_SensorHealth& operator=(const GetHealthStatusResponse_SensorHealth&) = delete;

  /// Default destructor.
  ~GetHealthStatusResponse_SensorHealth() noexcept final = default;

  /// Creates a `GetHealthStatusResponse_SensorHealth` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit GetHealthStatusResponse_SensorHealth(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.SensorHealth`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.GetHealthStatusResponse.SensorHealth"; }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.SensorHealth`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `preprocessing_node_id` (no 1).
  // -----

  /// ID of the preprocessing node managing the sensor
  ///
  /// Field no: 1.
  constexpr const CowBytes& preprocessing_node_id() const& noexcept HORUS_LIFETIME_BOUND {
    return preprocessing_node_id_;
  }

  /// If `preprocessing_node_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowBytes preprocessing_node_id() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(preprocessing_node_id_);
  }

  /// ID of the preprocessing node managing the sensor
  ///
  /// Field no: 1.
  CowBytes& mutable_preprocessing_node_id() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return preprocessing_node_id_;
  }

  /// Returns whether `preprocessing_node_id` (no 1) is set.
  constexpr bool has_preprocessing_node_id() const noexcept { return set_fields_[0]; }

  /// Clears `preprocessing_node_id` (no 1).
  void clear_preprocessing_node_id() & noexcept {
    set_fields_[0] = false;
    preprocessing_node_id_ = {};
  }

  /// Sets `preprocessing_node_id` (no 1) and returns `*this`.
  GetHealthStatusResponse_SensorHealth& set_preprocessing_node_id(CowBytes&& preprocessing_node_id) & noexcept {
    set_fields_[0] = true;
    preprocessing_node_id_ = std::move(preprocessing_node_id);
    return *this;
  }
  /// Sets `preprocessing_node_id` (no 1) and returns `*this`.
  GetHealthStatusResponse_SensorHealth&& set_preprocessing_node_id(CowBytes&& preprocessing_node_id) && noexcept {
    return std::move(set_preprocessing_node_id(std::move(preprocessing_node_id)));
  }

  // Field `info` (no 2).
  // -----

  /// Info of the sensor
  ///
  /// Field no: 2.
  constexpr const SensorInfo& info() const& noexcept HORUS_LIFETIME_BOUND {
    return info_;
  }

  /// If `info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  SensorInfo info() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(info_);
  }

  /// Info of the sensor
  ///
  /// Field no: 2.
  SensorInfo& mutable_info() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return info_;
  }

  /// Returns whether `info` (no 2) is set.
  constexpr bool has_info() const noexcept { return set_fields_[1]; }

  /// Clears `info` (no 2).
  void clear_info() & noexcept {
    set_fields_[1] = false;
    info_ = {};
  }

  /// Sets `info` (no 2) and returns `*this`.
  GetHealthStatusResponse_SensorHealth& set_info(SensorInfo&& info) & noexcept {
    set_fields_[1] = true;
    info_ = std::move(info);
    return *this;
  }
  /// Sets `info` (no 2) and returns `*this`.
  GetHealthStatusResponse_SensorHealth&& set_info(SensorInfo&& info) && noexcept {
    return std::move(set_info(std::move(info)));
  }

  // Field `timeout` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const logs::ServiceConnectionTimedOut& timeout() const& noexcept HORUS_LIFETIME_BOUND {
    return timeout_;
  }

  /// If `timeout` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  logs::ServiceConnectionTimedOut timeout() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(timeout_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  logs::ServiceConnectionTimedOut& mutable_timeout() & noexcept HORUS_LIFETIME_BOUND {
    clear_node_unreachable_error();
    node_unreachable_error_ = NodeUnreachableErrorOneof::kTimeout;
    set_fields_[2] = true;
    return timeout_;
  }

  /// Returns whether `timeout` (no 3) is set.
  constexpr bool has_timeout() const noexcept { return set_fields_[2]; }

  /// Clears `timeout` (no 3).
  void clear_timeout() & noexcept {
    node_unreachable_error_ = {};
    set_fields_[2] = false;
    timeout_ = {};
  }

  /// Sets `timeout` (no 3) and returns `*this`.
  GetHealthStatusResponse_SensorHealth& set_timeout(logs::ServiceConnectionTimedOut&& timeout) & noexcept {
    clear_node_unreachable_error();
    node_unreachable_error_ = NodeUnreachableErrorOneof::kTimeout;
    set_fields_[2] = true;
    timeout_ = std::move(timeout);
    return *this;
  }
  /// Sets `timeout` (no 3) and returns `*this`.
  GetHealthStatusResponse_SensorHealth&& set_timeout(logs::ServiceConnectionTimedOut&& timeout) && noexcept {
    return std::move(set_timeout(std::move(timeout)));
  }

  // Oneof `node_unreachable_error`.
  // -----

  /// Return value of `node_unreachable_error_case()`.
  enum class NodeUnreachableErrorOneof : std::uint32_t {  // NOLINT(*-enum-size)
    /// No field set in the oneof.
    kNotSet = 0,
    /// @see timeout()
    kTimeout = 3,
  };

  /// Returns the current case set in `node_unreachable_error`.
  constexpr NodeUnreachableErrorOneof node_unreachable_error_case() const noexcept {
    return node_unreachable_error_;
  }

  /// Clears the oneof value in `node_unreachable_error`.
  void clear_node_unreachable_error() noexcept {
    switch (node_unreachable_error_) {
      case NodeUnreachableErrorOneof::kTimeout: {
        clear_timeout();
        break;
      }
      case NodeUnreachableErrorOneof::kNotSet:
      default:
        break;
    }
  }

 private:
  /// @see preprocessing_node_id()
  CowBytes preprocessing_node_id_{};
  /// @see info()
  SensorInfo info_{};
  /// @see timeout()
  logs::ServiceConnectionTimedOut timeout_{};

  /// @see node_unreachable_error_case()
  NodeUnreachableErrorOneof node_unreachable_error_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// Resource usage of each relevant node (preprocessing service & detection
///  service).
///
/// Source: horus/pb/project_manager/service.proto:173:3
class GetHealthStatusResponse_NodeResources final : public PbMessage {
 public:

  /// Constructs a default-initialized `GetHealthStatusResponse_NodeResources`.
  GetHealthStatusResponse_NodeResources() noexcept = default;

  /// Move constructor.
  GetHealthStatusResponse_NodeResources(GetHealthStatusResponse_NodeResources&&) noexcept = default;
  /// Move assignment operator.
  GetHealthStatusResponse_NodeResources& operator=(GetHealthStatusResponse_NodeResources&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit GetHealthStatusResponse_NodeResources(const GetHealthStatusResponse_NodeResources&) noexcept = default;  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  GetHealthStatusResponse_NodeResources& operator=(const GetHealthStatusResponse_NodeResources&) = delete;

  /// Default destructor.
  ~GetHealthStatusResponse_NodeResources() noexcept final = default;

  /// Creates a `GetHealthStatusResponse_NodeResources` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit GetHealthStatusResponse_NodeResources(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final {
    static_cast<void>(writer);
  }

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final {
    reader.SkipMessage();
  }

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.NodeResources`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.GetHealthStatusResponse.NodeResources"; }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse.NodeResources`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

 private:

  /// The set of fields that have been given an explicit value.
  std::bitset<0> set_fields_;
};

/// Report of the health status of horus.
///  It gathers information about:
///  - License
///  - Lidar status
///  - Services connectivity
///
/// Source: horus/pb/project_manager/service.proto:123:1
class GetHealthStatusResponse final : public PbMessage {
 public:
  /// @see GetHealthStatusResponse_NodeHealth
  using NodeHealth = GetHealthStatusResponse_NodeHealth;
  /// @see GetHealthStatusResponse_NodeResources
  using NodeResources = GetHealthStatusResponse_NodeResources;
  /// @see GetHealthStatusResponse_SensorHealth
  using SensorHealth = GetHealthStatusResponse_SensorHealth;

  /// Constructs a default-initialized `GetHealthStatusResponse`.
  GetHealthStatusResponse() noexcept = default;

  /// Move constructor.
  GetHealthStatusResponse(GetHealthStatusResponse&&) noexcept = default;
  /// Move assignment operator.
  GetHealthStatusResponse& operator=(GetHealthStatusResponse&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit GetHealthStatusResponse(const GetHealthStatusResponse& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  GetHealthStatusResponse& operator=(const GetHealthStatusResponse&) = delete;

  /// Default destructor.
  ~GetHealthStatusResponse() noexcept final = default;

  /// Creates a `GetHealthStatusResponse` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit GetHealthStatusResponse(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.GetHealthStatusResponse"; }

  /// The full name of the message: `horus.pb.GetHealthStatusResponse`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `license_status` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const LicenseStatus& license_status() const& noexcept HORUS_LIFETIME_BOUND {
    return license_status_;
  }

  /// If `license_status` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  LicenseStatus license_status() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(license_status_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  LicenseStatus& mutable_license_status() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return license_status_;
  }

  /// Returns whether `license_status` (no 1) is set.
  constexpr bool has_license_status() const noexcept { return set_fields_[0]; }

  /// Clears `license_status` (no 1).
  void clear_license_status() & noexcept {
    set_fields_[0] = false;
    license_status_ = {};
  }

  /// Sets `license_status` (no 1) and returns `*this`.
  GetHealthStatusResponse& set_license_status(LicenseStatus&& license_status) & noexcept {
    set_fields_[0] = true;
    license_status_ = std::move(license_status);
    return *this;
  }
  /// Sets `license_status` (no 1) and returns `*this`.
  GetHealthStatusResponse&& set_license_status(LicenseStatus&& license_status) && noexcept {
    return std::move(set_license_status(std::move(license_status)));
  }

  // Field `sensor_statuses` (no 2).
  // -----

  /// Connectivity status of the sensors.
  ///  If enum status is set to SENSOR_STATUS_UNSPECIFIED, it means that the
  ///  preprocessing node managing the sensor could not be reached.
  ///  This specific value will be interpreted as "Sensor unreachable" by the
  ///  clients.
  ///
  /// Field no: 2.
  constexpr const CowRepeated<GetHealthStatusResponse_SensorHealth>& sensor_statuses() const& noexcept HORUS_LIFETIME_BOUND {
    return sensor_statuses_;
  }

  /// If `sensor_statuses` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowRepeated<GetHealthStatusResponse_SensorHealth> sensor_statuses() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(sensor_statuses_);
  }

  /// Connectivity status of the sensors.
  ///  If enum status is set to SENSOR_STATUS_UNSPECIFIED, it means that the
  ///  preprocessing node managing the sensor could not be reached.
  ///  This specific value will be interpreted as "Sensor unreachable" by the
  ///  clients.
  ///
  /// Field no: 2.
  CowRepeated<GetHealthStatusResponse_SensorHealth>& mutable_sensor_statuses() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return sensor_statuses_;
  }

  /// Returns whether `sensor_statuses` (no 2) is set.
  constexpr bool has_sensor_statuses() const noexcept { return set_fields_[1]; }

  /// Clears `sensor_statuses` (no 2).
  void clear_sensor_statuses() & noexcept {
    set_fields_[1] = false;
    sensor_statuses_ = {};
  }

  /// Sets `sensor_statuses` (no 2) and returns `*this`.
  GetHealthStatusResponse& set_sensor_statuses(CowRepeated<GetHealthStatusResponse_SensorHealth>&& sensor_statuses) & noexcept {
    set_fields_[1] = true;
    sensor_statuses_ = std::move(sensor_statuses);
    return *this;
  }
  /// Sets `sensor_statuses` (no 2) and returns `*this`.
  GetHealthStatusResponse&& set_sensor_statuses(CowRepeated<GetHealthStatusResponse_SensorHealth>&& sensor_statuses) && noexcept {
    return std::move(set_sensor_statuses(std::move(sensor_statuses)));
  }

  // Field `service_statuses` (no 3).
  // -----

  /// Connectivity status of each node.
  ///
  /// Field no: 3.
  constexpr const CowRepeated<GetHealthStatusResponse_NodeHealth>& service_statuses() const& noexcept HORUS_LIFETIME_BOUND {
    return service_statuses_;
  }

  /// If `service_statuses` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  CowRepeated<GetHealthStatusResponse_NodeHealth> service_statuses() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(service_statuses_);
  }

  /// Connectivity status of each node.
  ///
  /// Field no: 3.
  CowRepeated<GetHealthStatusResponse_NodeHealth>& mutable_service_statuses() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return service_statuses_;
  }

  /// Returns whether `service_statuses` (no 3) is set.
  constexpr bool has_service_statuses() const noexcept { return set_fields_[2]; }

  /// Clears `service_statuses` (no 3).
  void clear_service_statuses() & noexcept {
    set_fields_[2] = false;
    service_statuses_ = {};
  }

  /// Sets `service_statuses` (no 3) and returns `*this`.
  GetHealthStatusResponse& set_service_statuses(CowRepeated<GetHealthStatusResponse_NodeHealth>&& service_statuses) & noexcept {
    set_fields_[2] = true;
    service_statuses_ = std::move(service_statuses);
    return *this;
  }
  /// Sets `service_statuses` (no 3) and returns `*this`.
  GetHealthStatusResponse&& set_service_statuses(CowRepeated<GetHealthStatusResponse_NodeHealth>&& service_statuses) && noexcept {
    return std::move(set_service_statuses(std::move(service_statuses)));
  }

  // Field `node_resources` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const CowRepeated<GetHealthStatusResponse_NodeResources>& node_resources() const& noexcept HORUS_LIFETIME_BOUND {
    return node_resources_;
  }

  /// If `node_resources` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  CowRepeated<GetHealthStatusResponse_NodeResources> node_resources() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(node_resources_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  CowRepeated<GetHealthStatusResponse_NodeResources>& mutable_node_resources() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return node_resources_;
  }

  /// Returns whether `node_resources` (no 4) is set.
  constexpr bool has_node_resources() const noexcept { return set_fields_[3]; }

  /// Clears `node_resources` (no 4).
  void clear_node_resources() & noexcept {
    set_fields_[3] = false;
    node_resources_ = {};
  }

  /// Sets `node_resources` (no 4) and returns `*this`.
  GetHealthStatusResponse& set_node_resources(CowRepeated<GetHealthStatusResponse_NodeResources>&& node_resources) & noexcept {
    set_fields_[3] = true;
    node_resources_ = std::move(node_resources);
    return *this;
  }
  /// Sets `node_resources` (no 4) and returns `*this`.
  GetHealthStatusResponse&& set_node_resources(CowRepeated<GetHealthStatusResponse_NodeResources>&& node_resources) && noexcept {
    return std::move(set_node_resources(std::move(node_resources)));
  }

 private:
  /// @see license_status()
  LicenseStatus license_status_{};
  /// @see sensor_statuses()
  CowRepeated<GetHealthStatusResponse_SensorHealth> sensor_statuses_{};
  /// @see service_statuses()
  CowRepeated<GetHealthStatusResponse_NodeHealth> service_statuses_{};
  /// @see node_resources()
  CowRepeated<GetHealthStatusResponse_NodeResources> node_resources_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// MARK: Enum traits

namespace horus {

template <>
class PbEnumTraits<horus::sdk::pb::LicensePrivilege> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.LicensePrivilege`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.LicensePrivilege"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::LicensePrivilege value) noexcept {
    switch (value) {
      case horus::sdk::pb::LicensePrivilege::kUnspecified: {
        return "LICENSE_PRIVILEGE_UNSPECIFIED";
      }
      case horus::sdk::pb::LicensePrivilege::kLowest: {
        return "LOWEST";
      }
      case horus::sdk::pb::LicensePrivilege::kSubscribe: {
        return "SUBSCRIBE";
      }
      case horus::sdk::pb::LicensePrivilege::kLicenseActions: {
        return "LICENSE_ACTIONS";
      }
      case horus::sdk::pb::LicensePrivilege::kRead: {
        return "READ";
      }
      case horus::sdk::pb::LicensePrivilege::kWrite: {
        return "WRITE";
      }
      case horus::sdk::pb::LicensePrivilege::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::LicensePrivilege ValueOf(PbEnum value, horus::sdk::pb::LicensePrivilege default_value = horus::sdk::pb::LicensePrivilege::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::LicensePrivilege::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::LicensePrivilege::kLowest;
      }
      case 2: {
        return horus::sdk::pb::LicensePrivilege::kSubscribe;
      }
      case 4: {
        return horus::sdk::pb::LicensePrivilege::kLicenseActions;
      }
      case 8: {
        return horus::sdk::pb::LicensePrivilege::kRead;
      }
      case 16: {
        return horus::sdk::pb::LicensePrivilege::kWrite;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::LicensePrivilege ValueOf(StringView name, horus::sdk::pb::LicensePrivilege default_value = horus::sdk::pb::LicensePrivilege::kUnknownWireValue) noexcept {
    if (name == "LICENSE_PRIVILEGE_UNSPECIFIED") {
      return horus::sdk::pb::LicensePrivilege::kUnspecified;
    }
    if (name == "LOWEST") {
      return horus::sdk::pb::LicensePrivilege::kLowest;
    }
    if (name == "SUBSCRIBE") {
      return horus::sdk::pb::LicensePrivilege::kSubscribe;
    }
    if (name == "LICENSE_ACTIONS") {
      return horus::sdk::pb::LicensePrivilege::kLicenseActions;
    }
    if (name == "READ") {
      return horus::sdk::pb::LicensePrivilege::kRead;
    }
    if (name == "WRITE") {
      return horus::sdk::pb::LicensePrivilege::kWrite;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::LicensePrivilege> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::LicensePrivilege value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::LicensePrivilege` from `reader`.
  static horus::sdk::pb::LicensePrivilege Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::LicensePrivilege>::ValueOf(reader.Reader().get_enum());
  }
};

template <>
class PbEnumTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.GetHealthStatusResponse.NodeHealth.Service`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.GetHealthStatusResponse.NodeHealth.Service"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service value) noexcept {
    switch (value) {
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnspecified: {
        return "SERVICE_UNSPECIFIED";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kDetection: {
        return "SERVICE_DETECTION";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kLidarRunner: {
        return "SERVICE_LIDAR_RUNNER";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kNotification: {
        return "SERVICE_NOTIFICATION";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPointAggregator: {
        return "SERVICE_POINT_AGGREGATOR";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPreprocessing: {
        return "SERVICE_PREPROCESSING";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kProjectManager: {
        return "SERVICE_PROJECT_MANAGER";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service ValueOf(PbEnum value, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service default_value = horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kDetection;
      }
      case 2: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kLidarRunner;
      }
      case 3: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kNotification;
      }
      case 4: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPointAggregator;
      }
      case 5: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPreprocessing;
      }
      case 6: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kProjectManager;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service ValueOf(StringView name, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service default_value = horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnknownWireValue) noexcept {
    if (name == "SERVICE_UNSPECIFIED") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kUnspecified;
    }
    if (name == "SERVICE_DETECTION") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kDetection;
    }
    if (name == "SERVICE_LIDAR_RUNNER") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kLidarRunner;
    }
    if (name == "SERVICE_NOTIFICATION") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kNotification;
    }
    if (name == "SERVICE_POINT_AGGREGATOR") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPointAggregator;
    }
    if (name == "SERVICE_PREPROCESSING") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kPreprocessing;
    }
    if (name == "SERVICE_PROJECT_MANAGER") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service::kProjectManager;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service` from `reader`.
  static horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Service>::ValueOf(reader.Reader().get_enum());
  }
};

template <>
class PbEnumTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.GetHealthStatusResponse.NodeHealth.Status`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.GetHealthStatusResponse.NodeHealth.Status"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status value) noexcept {
    switch (value) {
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnspecified: {
        return "STATUS_UNSPECIFIED";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnreachable: {
        return "STATUS_UNREACHABLE";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kAlive: {
        return "STATUS_ALIVE";
      }
      case horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status ValueOf(PbEnum value, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status default_value = horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnreachable;
      }
      case 2: {
        return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kAlive;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status ValueOf(StringView name, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status default_value = horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnknownWireValue) noexcept {
    if (name == "STATUS_UNSPECIFIED") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnspecified;
    }
    if (name == "STATUS_UNREACHABLE") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kUnreachable;
    }
    if (name == "STATUS_ALIVE") {
      return horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status::kAlive;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status` from `reader`.
  static horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::GetHealthStatusResponse_NodeHealth_Status>::ValueOf(reader.Reader().get_enum());
  }
};

}  // namespace horus

namespace horus {
namespace sdk {
namespace pb {

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, LicensePrivilege value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<LicensePrivilege>::NameOf(value));
}

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, GetHealthStatusResponse_NodeHealth_Service value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<GetHealthStatusResponse_NodeHealth_Service>::NameOf(value));
}

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, GetHealthStatusResponse_NodeHealth_Status value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<GetHealthStatusResponse_NodeHealth_Status>::NameOf(value));
}

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_PROJECT_MANAGER_SERVICE_PB_H_
