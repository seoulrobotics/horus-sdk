#ifndef HORUS_PB_DETECTION_SERVICE_DETECTION_PB_H_
#define HORUS_PB_DETECTION_SERVICE_DETECTION_PB_H_

/// @file
///
/// C++ type definitions for Protobuf messages in `horus/pb/detection_service/detection.proto`.
///
/// Generated by `/home/runner/work/horus/horus/common/tools/sdk/pb.ts`.

#include <bitset>
#include <cstdint>
#include <utility>

#include "horus/attributes.h"
#include "horus/internal/attributes.h"
#include "horus/pb/config/metadata_pb.h"
#include "horus/pb/cow_repeated.h"
#include "horus/pb/message.h"
#include "horus/pb/point/point_message_pb.h"
#include "horus/pb/serialize.h"
#include "horus/pb/types.h"
#include "horus/strings/string_view.h"

#if HORUS_SDK_USE_PB_NAMESPACE_ALIAS
#include "horus/pb/alias.h"  // IWYU pragma: export
#endif

// NOLINTBEGIN(readability-identifier-length)

namespace horus {
namespace sdk {
namespace pb {

// MARK: Enum declarations

/// The supported object labels.
///
/// Source: horus/pb/detection_service/detection.proto:30:1
enum class ObjectLabel : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kLabelUnspecified = 0,
  /// No documentation.
  kMisc = 1,
  /// No documentation.
  kCar = 2,
  /// No documentation.
  kCyclist = 3,
  /// No documentation.
  kPedestrian = 4,

  /// Unknown value read from the wire.
  kUnknownWireValue = 5,
};

/// The detected object tracking status.
///
/// Source: horus/pb/detection_service/detection.proto:39:1
enum class TrackingStatus : PbEnum {  // NOLINT(*-enum-size)
  /// No documentation.
  kUnspecified = 0,
  /// No documentation.
  kInvalidating = 1,
  /// No documentation.
  kValidating = 2,
  /// No documentation.
  kDrifting = 3,
  /// No documentation.
  kTracking = 4,

  /// Unknown value read from the wire.
  kUnknownWireValue = 5,
};

// MARK: Message forward declarations

class BoundingBox;
class LabeledPointCloud;
class DetectedObject_Classification;
class DetectedObject_Kinematics;
class DetectedObject_Shape;
class DetectedObject_Status;
class DetectedObject;
class DeepLearningObject_Classification;
class DeepLearningObject;
class DetectionEvent_FrameInfo;
class DetectionEvent;

// MARK: Message declarations

/// A bounding box message.
///
/// Source: horus/pb/detection_service/detection.proto:10:1
class BoundingBox final : public PbMessage {
 public:

  /// Constructs a default-initialized `BoundingBox`.
  BoundingBox() noexcept = default;

  /// Move constructor.
  BoundingBox(BoundingBox&&) noexcept = default;
  /// Move assignment operator.
  BoundingBox& operator=(BoundingBox&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit BoundingBox(const BoundingBox& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  BoundingBox& operator=(const BoundingBox&) = delete;

  /// Default destructor.
  ~BoundingBox() noexcept final = default;

  /// Creates a `BoundingBox` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit BoundingBox(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.BoundingBox`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.BoundingBox"; }

  /// The full name of the message: `horus.pb.BoundingBox`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `base` (no 1).
  // -----

  /// The base is defined by the center_x, center_y, and lowest_z in meters
  ///  relevant to the global origin.
  ///
  /// Field no: 1.
  constexpr const Vector3f& base() const& noexcept HORUS_LIFETIME_BOUND {
    return base_;
  }

  /// If `base` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  Vector3f base() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(base_);
  }

  /// The base is defined by the center_x, center_y, and lowest_z in meters
  ///  relevant to the global origin.
  ///
  /// Field no: 1.
  Vector3f& mutable_base() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return base_;
  }

  /// Returns whether `base` (no 1) is set.
  constexpr bool has_base() const noexcept { return set_fields_[0]; }

  /// Clears `base` (no 1).
  void clear_base() & noexcept {
    set_fields_[0] = false;
    base_ = {};
  }

  /// Sets `base` (no 1) and returns `*this`.
  BoundingBox& set_base(Vector3f&& base) & noexcept {
    set_fields_[0] = true;
    base_ = std::move(base);
    return *this;
  }
  /// Sets `base` (no 1) and returns `*this`.
  BoundingBox&& set_base(Vector3f&& base) && noexcept {
    return std::move(set_base(std::move(base)));
  }

  // Field `size` (no 2).
  // -----

  /// The size is defined by the width, height and depth of the box in meters.
  ///
  /// Field no: 2.
  constexpr const Vector3f& size() const& noexcept HORUS_LIFETIME_BOUND {
    return size_;
  }

  /// If `size` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  Vector3f size() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(size_);
  }

  /// The size is defined by the width, height and depth of the box in meters.
  ///
  /// Field no: 2.
  Vector3f& mutable_size() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return size_;
  }

  /// Returns whether `size` (no 2) is set.
  constexpr bool has_size() const noexcept { return set_fields_[1]; }

  /// Clears `size` (no 2).
  void clear_size() & noexcept {
    set_fields_[1] = false;
    size_ = {};
  }

  /// Sets `size` (no 2) and returns `*this`.
  BoundingBox& set_size(Vector3f&& size) & noexcept {
    set_fields_[1] = true;
    size_ = std::move(size);
    return *this;
  }
  /// Sets `size` (no 2) and returns `*this`.
  BoundingBox&& set_size(Vector3f&& size) && noexcept {
    return std::move(set_size(std::move(size)));
  }

  // Field `yaw` (no 3).
  // -----

  /// The yaw of the box in radians.
  ///
  /// Field no: 3.
  constexpr float yaw() const& noexcept HORUS_LIFETIME_BOUND {
    return yaw_;
  }

  /// The yaw of the box in radians.
  ///
  /// Field no: 3.
  float& mutable_yaw() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return yaw_;
  }

  /// Returns whether `yaw` (no 3) is set.
  constexpr bool has_yaw() const noexcept { return set_fields_[2]; }

  /// Clears `yaw` (no 3).
  void clear_yaw() & noexcept {
    set_fields_[2] = false;
    yaw_ = {};
  }

  /// Sets `yaw` (no 3) and returns `*this`.
  BoundingBox& set_yaw(float yaw) & noexcept {
    set_fields_[2] = true;
    yaw_ = yaw;
    return *this;
  }
  /// Sets `yaw` (no 3) and returns `*this`.
  BoundingBox&& set_yaw(float yaw) && noexcept {
    return std::move(set_yaw(yaw));
  }

 private:
  /// @see base()
  Vector3f base_{};
  /// @see size()
  Vector3f size_{};
  /// @see yaw()
  float yaw_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<3> set_fields_;
};

/// A labeled point cloud message.
///
/// Source: horus/pb/detection_service/detection.proto:21:1
class LabeledPointCloud final : public PbMessage {
 public:

  /// Constructs a default-initialized `LabeledPointCloud`.
  LabeledPointCloud() noexcept = default;

  /// Move constructor.
  LabeledPointCloud(LabeledPointCloud&&) noexcept = default;
  /// Move assignment operator.
  LabeledPointCloud& operator=(LabeledPointCloud&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit LabeledPointCloud(const LabeledPointCloud& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  LabeledPointCloud& operator=(const LabeledPointCloud&) = delete;

  /// Default destructor.
  ~LabeledPointCloud() noexcept final = default;

  /// Creates a `LabeledPointCloud` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit LabeledPointCloud(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.LabeledPointCloud`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.LabeledPointCloud"; }

  /// The full name of the message: `horus.pb.LabeledPointCloud`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `point_cloud` (no 1).
  // -----

  /// The point cloud and its metadata.
  ///
  /// Field no: 1.
  constexpr const PointFrame& point_cloud() const& noexcept HORUS_LIFETIME_BOUND {
    return point_cloud_;
  }

  /// If `point_cloud` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  PointFrame point_cloud() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(point_cloud_);
  }

  /// The point cloud and its metadata.
  ///
  /// Field no: 1.
  PointFrame& mutable_point_cloud() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return point_cloud_;
  }

  /// Returns whether `point_cloud` (no 1) is set.
  constexpr bool has_point_cloud() const noexcept { return set_fields_[0]; }

  /// Clears `point_cloud` (no 1).
  void clear_point_cloud() & noexcept {
    set_fields_[0] = false;
    point_cloud_ = {};
  }

  /// Sets `point_cloud` (no 1) and returns `*this`.
  LabeledPointCloud& set_point_cloud(PointFrame&& point_cloud) & noexcept {
    set_fields_[0] = true;
    point_cloud_ = std::move(point_cloud);
    return *this;
  }
  /// Sets `point_cloud` (no 1) and returns `*this`.
  LabeledPointCloud&& set_point_cloud(PointFrame&& point_cloud) && noexcept {
    return std::move(set_point_cloud(std::move(point_cloud)));
  }

  // Field `point_index_to_object_id` (no 2).
  // -----

  /// Attributes for each point defining which `DetectedObject` a point belongs
  ///  to. The int32_t::max is reserved for unassigned points.
  ///
  /// Field no: 2.
  constexpr const UInt32List& point_index_to_object_id() const& noexcept HORUS_LIFETIME_BOUND {
    return point_index_to_object_id_;
  }

  /// If `point_index_to_object_id` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  UInt32List point_index_to_object_id() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(point_index_to_object_id_);
  }

  /// Attributes for each point defining which `DetectedObject` a point belongs
  ///  to. The int32_t::max is reserved for unassigned points.
  ///
  /// Field no: 2.
  UInt32List& mutable_point_index_to_object_id() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return point_index_to_object_id_;
  }

  /// Returns whether `point_index_to_object_id` (no 2) is set.
  constexpr bool has_point_index_to_object_id() const noexcept { return set_fields_[1]; }

  /// Clears `point_index_to_object_id` (no 2).
  void clear_point_index_to_object_id() & noexcept {
    set_fields_[1] = false;
    point_index_to_object_id_ = {};
  }

  /// Sets `point_index_to_object_id` (no 2) and returns `*this`.
  LabeledPointCloud& set_point_index_to_object_id(UInt32List&& point_index_to_object_id) & noexcept {
    set_fields_[1] = true;
    point_index_to_object_id_ = std::move(point_index_to_object_id);
    return *this;
  }
  /// Sets `point_index_to_object_id` (no 2) and returns `*this`.
  LabeledPointCloud&& set_point_index_to_object_id(UInt32List&& point_index_to_object_id) && noexcept {
    return std::move(set_point_index_to_object_id(std::move(point_index_to_object_id)));
  }

 private:
  /// @see point_cloud()
  PointFrame point_cloud_{};
  /// @see point_index_to_object_id()
  UInt32List point_index_to_object_id_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:49:3
class DetectedObject_Classification final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectedObject_Classification`.
  DetectedObject_Classification() noexcept = default;

  /// Move constructor.
  DetectedObject_Classification(DetectedObject_Classification&&) noexcept = default;
  /// Move assignment operator.
  DetectedObject_Classification& operator=(DetectedObject_Classification&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectedObject_Classification(const DetectedObject_Classification& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectedObject_Classification& operator=(const DetectedObject_Classification&) = delete;

  /// Default destructor.
  ~DetectedObject_Classification() noexcept final = default;

  /// Creates a `DetectedObject_Classification` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectedObject_Classification(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectedObject.Classification`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectedObject.Classification"; }

  /// The full name of the message: `horus.pb.DetectedObject.Classification`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `class_label` (no 1).
  // -----

  /// The label of the detected object.
  ///
  /// Field no: 1.
  constexpr ObjectLabel class_label() const& noexcept HORUS_LIFETIME_BOUND {
    return class_label_;
  }

  /// The label of the detected object.
  ///
  /// Field no: 1.
  ObjectLabel& mutable_class_label() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return class_label_;
  }

  /// Returns whether `class_label` (no 1) is set.
  constexpr bool has_class_label() const noexcept { return set_fields_[0]; }

  /// Clears `class_label` (no 1).
  void clear_class_label() & noexcept {
    set_fields_[0] = false;
    class_label_ = {};
  }

  /// Sets `class_label` (no 1) and returns `*this`.
  DetectedObject_Classification& set_class_label(ObjectLabel class_label) & noexcept {
    set_fields_[0] = true;
    class_label_ = class_label;
    return *this;
  }
  /// Sets `class_label` (no 1) and returns `*this`.
  DetectedObject_Classification&& set_class_label(ObjectLabel class_label) && noexcept {
    return std::move(set_class_label(class_label));
  }

  // Field `class_confidence` (no 2).
  // -----

  /// The confidence of the detected object.
  ///
  /// Field no: 2.
  constexpr float class_confidence() const& noexcept HORUS_LIFETIME_BOUND {
    return class_confidence_;
  }

  /// The confidence of the detected object.
  ///
  /// Field no: 2.
  float& mutable_class_confidence() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return class_confidence_;
  }

  /// Returns whether `class_confidence` (no 2) is set.
  constexpr bool has_class_confidence() const noexcept { return set_fields_[1]; }

  /// Clears `class_confidence` (no 2).
  void clear_class_confidence() & noexcept {
    set_fields_[1] = false;
    class_confidence_ = {};
  }

  /// Sets `class_confidence` (no 2) and returns `*this`.
  DetectedObject_Classification& set_class_confidence(float class_confidence) & noexcept {
    set_fields_[1] = true;
    class_confidence_ = class_confidence;
    return *this;
  }
  /// Sets `class_confidence` (no 2) and returns `*this`.
  DetectedObject_Classification&& set_class_confidence(float class_confidence) && noexcept {
    return std::move(set_class_confidence(class_confidence));
  }

 private:
  /// @see class_label()
  ObjectLabel class_label_{};
  /// @see class_confidence()
  float class_confidence_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:56:3
class DetectedObject_Kinematics final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectedObject_Kinematics`.
  DetectedObject_Kinematics() noexcept = default;

  /// Move constructor.
  DetectedObject_Kinematics(DetectedObject_Kinematics&&) noexcept = default;
  /// Move assignment operator.
  DetectedObject_Kinematics& operator=(DetectedObject_Kinematics&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectedObject_Kinematics(const DetectedObject_Kinematics& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectedObject_Kinematics& operator=(const DetectedObject_Kinematics&) = delete;

  /// Default destructor.
  ~DetectedObject_Kinematics() noexcept final = default;

  /// Creates a `DetectedObject_Kinematics` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectedObject_Kinematics(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectedObject.Kinematics`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectedObject.Kinematics"; }

  /// The full name of the message: `horus.pb.DetectedObject.Kinematics`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `linear_velocity` (no 1).
  // -----

  /// The (X, Y) linear velocity in m/s.
  ///
  /// Field no: 1.
  constexpr const Vector2f& linear_velocity() const& noexcept HORUS_LIFETIME_BOUND {
    return linear_velocity_;
  }

  /// If `linear_velocity` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  Vector2f linear_velocity() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(linear_velocity_);
  }

  /// The (X, Y) linear velocity in m/s.
  ///
  /// Field no: 1.
  Vector2f& mutable_linear_velocity() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return linear_velocity_;
  }

  /// Returns whether `linear_velocity` (no 1) is set.
  constexpr bool has_linear_velocity() const noexcept { return set_fields_[0]; }

  /// Clears `linear_velocity` (no 1).
  void clear_linear_velocity() & noexcept {
    set_fields_[0] = false;
    linear_velocity_ = {};
  }

  /// Sets `linear_velocity` (no 1) and returns `*this`.
  DetectedObject_Kinematics& set_linear_velocity(Vector2f&& linear_velocity) & noexcept {
    set_fields_[0] = true;
    linear_velocity_ = std::move(linear_velocity);
    return *this;
  }
  /// Sets `linear_velocity` (no 1) and returns `*this`.
  DetectedObject_Kinematics&& set_linear_velocity(Vector2f&& linear_velocity) && noexcept {
    return std::move(set_linear_velocity(std::move(linear_velocity)));
  }

  // Field `yaw_rate` (no 2).
  // -----

  /// The optional yaw rate in radians.
  ///  The yaw rate is not set if the used tracker uses a constant velocity
  ///  motion model.
  ///
  /// Field no: 2.
  constexpr float yaw_rate() const& noexcept HORUS_LIFETIME_BOUND {
    return yaw_rate_;
  }

  /// The optional yaw rate in radians.
  ///  The yaw rate is not set if the used tracker uses a constant velocity
  ///  motion model.
  ///
  /// Field no: 2.
  float& mutable_yaw_rate() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return yaw_rate_;
  }

  /// Returns whether `yaw_rate` (no 2) is set.
  constexpr bool has_yaw_rate() const noexcept { return set_fields_[1]; }

  /// Clears `yaw_rate` (no 2).
  void clear_yaw_rate() & noexcept {
    set_fields_[1] = false;
    yaw_rate_ = {};
  }

  /// Sets `yaw_rate` (no 2) and returns `*this`.
  DetectedObject_Kinematics& set_yaw_rate(float yaw_rate) & noexcept {
    set_fields_[1] = true;
    yaw_rate_ = yaw_rate;
    return *this;
  }
  /// Sets `yaw_rate` (no 2) and returns `*this`.
  DetectedObject_Kinematics&& set_yaw_rate(float yaw_rate) && noexcept {
    return std::move(set_yaw_rate(yaw_rate));
  }

 private:
  /// @see linear_velocity()
  Vector2f linear_velocity_{};
  /// @see yaw_rate()
  float yaw_rate_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:66:3
class DetectedObject_Shape final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectedObject_Shape`.
  DetectedObject_Shape() noexcept = default;

  /// Move constructor.
  DetectedObject_Shape(DetectedObject_Shape&&) noexcept = default;
  /// Move assignment operator.
  DetectedObject_Shape& operator=(DetectedObject_Shape&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectedObject_Shape(const DetectedObject_Shape& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectedObject_Shape& operator=(const DetectedObject_Shape&) = delete;

  /// Default destructor.
  ~DetectedObject_Shape() noexcept final = default;

  /// Creates a `DetectedObject_Shape` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectedObject_Shape(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectedObject.Shape`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectedObject.Shape"; }

  /// The full name of the message: `horus.pb.DetectedObject.Shape`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `bounding_box` (no 1).
  // -----

  /// The bounding box of the detected object.
  ///
  /// Field no: 1.
  constexpr const BoundingBox& bounding_box() const& noexcept HORUS_LIFETIME_BOUND {
    return bounding_box_;
  }

  /// If `bounding_box` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  BoundingBox bounding_box() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(bounding_box_);
  }

  /// The bounding box of the detected object.
  ///
  /// Field no: 1.
  BoundingBox& mutable_bounding_box() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return bounding_box_;
  }

  /// Returns whether `bounding_box` (no 1) is set.
  constexpr bool has_bounding_box() const noexcept { return set_fields_[0]; }

  /// Clears `bounding_box` (no 1).
  void clear_bounding_box() & noexcept {
    set_fields_[0] = false;
    bounding_box_ = {};
  }

  /// Sets `bounding_box` (no 1) and returns `*this`.
  DetectedObject_Shape& set_bounding_box(BoundingBox&& bounding_box) & noexcept {
    set_fields_[0] = true;
    bounding_box_ = std::move(bounding_box);
    return *this;
  }
  /// Sets `bounding_box` (no 1) and returns `*this`.
  DetectedObject_Shape&& set_bounding_box(BoundingBox&& bounding_box) && noexcept {
    return std::move(set_bounding_box(std::move(bounding_box)));
  }

 private:
  /// @see bounding_box()
  BoundingBox bounding_box_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:71:3
class DetectedObject_Status final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectedObject_Status`.
  DetectedObject_Status() noexcept = default;

  /// Move constructor.
  DetectedObject_Status(DetectedObject_Status&&) noexcept = default;
  /// Move assignment operator.
  DetectedObject_Status& operator=(DetectedObject_Status&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectedObject_Status(const DetectedObject_Status& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectedObject_Status& operator=(const DetectedObject_Status&) = delete;

  /// Default destructor.
  ~DetectedObject_Status() noexcept final = default;

  /// Creates a `DetectedObject_Status` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectedObject_Status(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectedObject.Status`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectedObject.Status"; }

  /// The full name of the message: `horus.pb.DetectedObject.Status`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `id` (no 1).
  // -----

  /// The id of the detected object.
  ///  Set optional to avoid field ellision for id 0 after serialization.
  ///
  /// Field no: 1.
  constexpr std::uint32_t id() const& noexcept HORUS_LIFETIME_BOUND {
    return id_;
  }

  /// The id of the detected object.
  ///  Set optional to avoid field ellision for id 0 after serialization.
  ///
  /// Field no: 1.
  std::uint32_t& mutable_id() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return id_;
  }

  /// Returns whether `id` (no 1) is set.
  constexpr bool has_id() const noexcept { return set_fields_[0]; }

  /// Clears `id` (no 1).
  void clear_id() & noexcept {
    set_fields_[0] = false;
    id_ = {};
  }

  /// Sets `id` (no 1) and returns `*this`.
  DetectedObject_Status& set_id(std::uint32_t id) & noexcept {
    set_fields_[0] = true;
    id_ = id;
    return *this;
  }
  /// Sets `id` (no 1) and returns `*this`.
  DetectedObject_Status&& set_id(std::uint32_t id) && noexcept {
    return std::move(set_id(id));
  }

  // Field `tracking_status` (no 2).
  // -----

  /// The tracking status of the detected object.
  ///
  /// Field no: 2.
  constexpr TrackingStatus tracking_status() const& noexcept HORUS_LIFETIME_BOUND {
    return tracking_status_;
  }

  /// The tracking status of the detected object.
  ///
  /// Field no: 2.
  TrackingStatus& mutable_tracking_status() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return tracking_status_;
  }

  /// Returns whether `tracking_status` (no 2) is set.
  constexpr bool has_tracking_status() const noexcept { return set_fields_[1]; }

  /// Clears `tracking_status` (no 2).
  void clear_tracking_status() & noexcept {
    set_fields_[1] = false;
    tracking_status_ = {};
  }

  /// Sets `tracking_status` (no 2) and returns `*this`.
  DetectedObject_Status& set_tracking_status(TrackingStatus tracking_status) & noexcept {
    set_fields_[1] = true;
    tracking_status_ = tracking_status;
    return *this;
  }
  /// Sets `tracking_status` (no 2) and returns `*this`.
  DetectedObject_Status&& set_tracking_status(TrackingStatus tracking_status) && noexcept {
    return std::move(set_tracking_status(tracking_status));
  }

 private:
  /// @see id()
  std::uint32_t id_{};
  /// @see tracking_status()
  TrackingStatus tracking_status_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// A singular detection object message.
///
/// Source: horus/pb/detection_service/detection.proto:48:1
class DetectedObject final : public PbMessage {
 public:
  /// @see DetectedObject_Classification
  using Classification = DetectedObject_Classification;
  /// @see DetectedObject_Kinematics
  using Kinematics = DetectedObject_Kinematics;
  /// @see DetectedObject_Shape
  using Shape = DetectedObject_Shape;
  /// @see DetectedObject_Status
  using Status = DetectedObject_Status;

  /// Constructs a default-initialized `DetectedObject`.
  DetectedObject() noexcept = default;

  /// Move constructor.
  DetectedObject(DetectedObject&&) noexcept = default;
  /// Move assignment operator.
  DetectedObject& operator=(DetectedObject&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectedObject(const DetectedObject& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectedObject& operator=(const DetectedObject&) = delete;

  /// Default destructor.
  ~DetectedObject() noexcept final = default;

  /// Creates a `DetectedObject` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectedObject(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectedObject`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectedObject"; }

  /// The full name of the message: `horus.pb.DetectedObject`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `classification` (no 1).
  // -----

  /// No documentation.
  ///
  /// Field no: 1.
  constexpr const DetectedObject_Classification& classification() const& noexcept HORUS_LIFETIME_BOUND {
    return classification_;
  }

  /// If `classification` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  DetectedObject_Classification classification() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(classification_);
  }

  /// No documentation.
  ///
  /// Field no: 1.
  DetectedObject_Classification& mutable_classification() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return classification_;
  }

  /// Returns whether `classification` (no 1) is set.
  constexpr bool has_classification() const noexcept { return set_fields_[0]; }

  /// Clears `classification` (no 1).
  void clear_classification() & noexcept {
    set_fields_[0] = false;
    classification_ = {};
  }

  /// Sets `classification` (no 1) and returns `*this`.
  DetectedObject& set_classification(DetectedObject_Classification&& classification) & noexcept {
    set_fields_[0] = true;
    classification_ = std::move(classification);
    return *this;
  }
  /// Sets `classification` (no 1) and returns `*this`.
  DetectedObject&& set_classification(DetectedObject_Classification&& classification) && noexcept {
    return std::move(set_classification(std::move(classification)));
  }

  // Field `kinematics` (no 2).
  // -----

  /// No documentation.
  ///
  /// Field no: 2.
  constexpr const DetectedObject_Kinematics& kinematics() const& noexcept HORUS_LIFETIME_BOUND {
    return kinematics_;
  }

  /// If `kinematics` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  DetectedObject_Kinematics kinematics() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(kinematics_);
  }

  /// No documentation.
  ///
  /// Field no: 2.
  DetectedObject_Kinematics& mutable_kinematics() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return kinematics_;
  }

  /// Returns whether `kinematics` (no 2) is set.
  constexpr bool has_kinematics() const noexcept { return set_fields_[1]; }

  /// Clears `kinematics` (no 2).
  void clear_kinematics() & noexcept {
    set_fields_[1] = false;
    kinematics_ = {};
  }

  /// Sets `kinematics` (no 2) and returns `*this`.
  DetectedObject& set_kinematics(DetectedObject_Kinematics&& kinematics) & noexcept {
    set_fields_[1] = true;
    kinematics_ = std::move(kinematics);
    return *this;
  }
  /// Sets `kinematics` (no 2) and returns `*this`.
  DetectedObject&& set_kinematics(DetectedObject_Kinematics&& kinematics) && noexcept {
    return std::move(set_kinematics(std::move(kinematics)));
  }

  // Field `shape` (no 3).
  // -----

  /// No documentation.
  ///
  /// Field no: 3.
  constexpr const DetectedObject_Shape& shape() const& noexcept HORUS_LIFETIME_BOUND {
    return shape_;
  }

  /// If `shape` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  DetectedObject_Shape shape() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(shape_);
  }

  /// No documentation.
  ///
  /// Field no: 3.
  DetectedObject_Shape& mutable_shape() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return shape_;
  }

  /// Returns whether `shape` (no 3) is set.
  constexpr bool has_shape() const noexcept { return set_fields_[2]; }

  /// Clears `shape` (no 3).
  void clear_shape() & noexcept {
    set_fields_[2] = false;
    shape_ = {};
  }

  /// Sets `shape` (no 3) and returns `*this`.
  DetectedObject& set_shape(DetectedObject_Shape&& shape) & noexcept {
    set_fields_[2] = true;
    shape_ = std::move(shape);
    return *this;
  }
  /// Sets `shape` (no 3) and returns `*this`.
  DetectedObject&& set_shape(DetectedObject_Shape&& shape) && noexcept {
    return std::move(set_shape(std::move(shape)));
  }

  // Field `status` (no 4).
  // -----

  /// No documentation.
  ///
  /// Field no: 4.
  constexpr const DetectedObject_Status& status() const& noexcept HORUS_LIFETIME_BOUND {
    return status_;
  }

  /// If `status` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  DetectedObject_Status status() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(status_);
  }

  /// No documentation.
  ///
  /// Field no: 4.
  DetectedObject_Status& mutable_status() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return status_;
  }

  /// Returns whether `status` (no 4) is set.
  constexpr bool has_status() const noexcept { return set_fields_[3]; }

  /// Clears `status` (no 4).
  void clear_status() & noexcept {
    set_fields_[3] = false;
    status_ = {};
  }

  /// Sets `status` (no 4) and returns `*this`.
  DetectedObject& set_status(DetectedObject_Status&& status) & noexcept {
    set_fields_[3] = true;
    status_ = std::move(status);
    return *this;
  }
  /// Sets `status` (no 4) and returns `*this`.
  DetectedObject&& set_status(DetectedObject_Status&& status) && noexcept {
    return std::move(set_status(std::move(status)));
  }

 private:
  /// @see classification()
  DetectedObject_Classification classification_{};
  /// @see kinematics()
  DetectedObject_Kinematics kinematics_{};
  /// @see shape()
  DetectedObject_Shape shape_{};
  /// @see status()
  DetectedObject_Status status_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:88:3
class DeepLearningObject_Classification final : public PbMessage {
 public:

  /// Constructs a default-initialized `DeepLearningObject_Classification`.
  DeepLearningObject_Classification() noexcept = default;

  /// Move constructor.
  DeepLearningObject_Classification(DeepLearningObject_Classification&&) noexcept = default;
  /// Move assignment operator.
  DeepLearningObject_Classification& operator=(DeepLearningObject_Classification&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DeepLearningObject_Classification(const DeepLearningObject_Classification& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DeepLearningObject_Classification& operator=(const DeepLearningObject_Classification&) = delete;

  /// Default destructor.
  ~DeepLearningObject_Classification() noexcept final = default;

  /// Creates a `DeepLearningObject_Classification` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DeepLearningObject_Classification(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DeepLearningObject.Classification`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DeepLearningObject.Classification"; }

  /// The full name of the message: `horus.pb.DeepLearningObject.Classification`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `class_label` (no 1).
  // -----

  /// The label of the detected object.
  ///
  /// Field no: 1.
  constexpr ObjectLabel class_label() const& noexcept HORUS_LIFETIME_BOUND {
    return class_label_;
  }

  /// The label of the detected object.
  ///
  /// Field no: 1.
  ObjectLabel& mutable_class_label() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return class_label_;
  }

  /// Returns whether `class_label` (no 1) is set.
  constexpr bool has_class_label() const noexcept { return set_fields_[0]; }

  /// Clears `class_label` (no 1).
  void clear_class_label() & noexcept {
    set_fields_[0] = false;
    class_label_ = {};
  }

  /// Sets `class_label` (no 1) and returns `*this`.
  DeepLearningObject_Classification& set_class_label(ObjectLabel class_label) & noexcept {
    set_fields_[0] = true;
    class_label_ = class_label;
    return *this;
  }
  /// Sets `class_label` (no 1) and returns `*this`.
  DeepLearningObject_Classification&& set_class_label(ObjectLabel class_label) && noexcept {
    return std::move(set_class_label(class_label));
  }

  // Field `class_confidence` (no 2).
  // -----

  /// The confidence of the detected object.
  ///
  /// Field no: 2.
  constexpr float class_confidence() const& noexcept HORUS_LIFETIME_BOUND {
    return class_confidence_;
  }

  /// The confidence of the detected object.
  ///
  /// Field no: 2.
  float& mutable_class_confidence() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return class_confidence_;
  }

  /// Returns whether `class_confidence` (no 2) is set.
  constexpr bool has_class_confidence() const noexcept { return set_fields_[1]; }

  /// Clears `class_confidence` (no 2).
  void clear_class_confidence() & noexcept {
    set_fields_[1] = false;
    class_confidence_ = {};
  }

  /// Sets `class_confidence` (no 2) and returns `*this`.
  DeepLearningObject_Classification& set_class_confidence(float class_confidence) & noexcept {
    set_fields_[1] = true;
    class_confidence_ = class_confidence;
    return *this;
  }
  /// Sets `class_confidence` (no 2) and returns `*this`.
  DeepLearningObject_Classification&& set_class_confidence(float class_confidence) && noexcept {
    return std::move(set_class_confidence(class_confidence));
  }

 private:
  /// @see class_label()
  ObjectLabel class_label_{};
  /// @see class_confidence()
  float class_confidence_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// / A deep learning object message.
///
/// Source: horus/pb/detection_service/detection.proto:87:1
class DeepLearningObject final : public PbMessage {
 public:
  /// @see DeepLearningObject_Classification
  using Classification = DeepLearningObject_Classification;

  /// Constructs a default-initialized `DeepLearningObject`.
  DeepLearningObject() noexcept = default;

  /// Move constructor.
  DeepLearningObject(DeepLearningObject&&) noexcept = default;
  /// Move assignment operator.
  DeepLearningObject& operator=(DeepLearningObject&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DeepLearningObject(const DeepLearningObject& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DeepLearningObject& operator=(const DeepLearningObject&) = delete;

  /// Default destructor.
  ~DeepLearningObject() noexcept final = default;

  /// Creates a `DeepLearningObject` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DeepLearningObject(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DeepLearningObject`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DeepLearningObject"; }

  /// The full name of the message: `horus.pb.DeepLearningObject`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `classification` (no 1).
  // -----

  /// The label of the detected object.
  ///
  /// Field no: 1.
  constexpr const DeepLearningObject_Classification& classification() const& noexcept HORUS_LIFETIME_BOUND {
    return classification_;
  }

  /// If `classification` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  DeepLearningObject_Classification classification() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(classification_);
  }

  /// The label of the detected object.
  ///
  /// Field no: 1.
  DeepLearningObject_Classification& mutable_classification() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return classification_;
  }

  /// Returns whether `classification` (no 1) is set.
  constexpr bool has_classification() const noexcept { return set_fields_[0]; }

  /// Clears `classification` (no 1).
  void clear_classification() & noexcept {
    set_fields_[0] = false;
    classification_ = {};
  }

  /// Sets `classification` (no 1) and returns `*this`.
  DeepLearningObject& set_classification(DeepLearningObject_Classification&& classification) & noexcept {
    set_fields_[0] = true;
    classification_ = std::move(classification);
    return *this;
  }
  /// Sets `classification` (no 1) and returns `*this`.
  DeepLearningObject&& set_classification(DeepLearningObject_Classification&& classification) && noexcept {
    return std::move(set_classification(std::move(classification)));
  }

  // Field `bounding_box` (no 2).
  // -----

  /// The bounding box of the detected object.
  ///
  /// Field no: 2.
  constexpr const BoundingBox& bounding_box() const& noexcept HORUS_LIFETIME_BOUND {
    return bounding_box_;
  }

  /// If `bounding_box` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  BoundingBox bounding_box() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(bounding_box_);
  }

  /// The bounding box of the detected object.
  ///
  /// Field no: 2.
  BoundingBox& mutable_bounding_box() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return bounding_box_;
  }

  /// Returns whether `bounding_box` (no 2) is set.
  constexpr bool has_bounding_box() const noexcept { return set_fields_[1]; }

  /// Clears `bounding_box` (no 2).
  void clear_bounding_box() & noexcept {
    set_fields_[1] = false;
    bounding_box_ = {};
  }

  /// Sets `bounding_box` (no 2) and returns `*this`.
  DeepLearningObject& set_bounding_box(BoundingBox&& bounding_box) & noexcept {
    set_fields_[1] = true;
    bounding_box_ = std::move(bounding_box);
    return *this;
  }
  /// Sets `bounding_box` (no 2) and returns `*this`.
  DeepLearningObject&& set_bounding_box(BoundingBox&& bounding_box) && noexcept {
    return std::move(set_bounding_box(std::move(bounding_box)));
  }

 private:
  /// @see classification()
  DeepLearningObject_Classification classification_{};
  /// @see bounding_box()
  BoundingBox bounding_box_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<2> set_fields_;
};

/// No documentation.
///
/// Source: horus/pb/detection_service/detection.proto:103:3
class DetectionEvent_FrameInfo final : public PbMessage {
 public:

  /// Constructs a default-initialized `DetectionEvent_FrameInfo`.
  DetectionEvent_FrameInfo() noexcept = default;

  /// Move constructor.
  DetectionEvent_FrameInfo(DetectionEvent_FrameInfo&&) noexcept = default;
  /// Move assignment operator.
  DetectionEvent_FrameInfo& operator=(DetectionEvent_FrameInfo&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectionEvent_FrameInfo(const DetectionEvent_FrameInfo& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectionEvent_FrameInfo& operator=(const DetectionEvent_FrameInfo&) = delete;

  /// Default destructor.
  ~DetectionEvent_FrameInfo() noexcept final = default;

  /// Creates a `DetectionEvent_FrameInfo` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectionEvent_FrameInfo(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectionEvent.FrameInfo`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectionEvent.FrameInfo"; }

  /// The full name of the message: `horus.pb.DetectionEvent.FrameInfo`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `frame_timestamp` (no 1).
  // -----

  /// The detection frame timestamp.
  ///
  /// Field no: 1.
  constexpr const Timestamp& frame_timestamp() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_timestamp_;
  }

  /// If `frame_timestamp` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  Timestamp frame_timestamp() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(frame_timestamp_);
  }

  /// The detection frame timestamp.
  ///
  /// Field no: 1.
  Timestamp& mutable_frame_timestamp() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return frame_timestamp_;
  }

  /// Returns whether `frame_timestamp` (no 1) is set.
  constexpr bool has_frame_timestamp() const noexcept { return set_fields_[0]; }

  /// Clears `frame_timestamp` (no 1).
  void clear_frame_timestamp() & noexcept {
    set_fields_[0] = false;
    frame_timestamp_ = {};
  }

  /// Sets `frame_timestamp` (no 1) and returns `*this`.
  DetectionEvent_FrameInfo& set_frame_timestamp(Timestamp&& frame_timestamp) & noexcept {
    set_fields_[0] = true;
    frame_timestamp_ = std::move(frame_timestamp);
    return *this;
  }
  /// Sets `frame_timestamp` (no 1) and returns `*this`.
  DetectionEvent_FrameInfo&& set_frame_timestamp(Timestamp&& frame_timestamp) && noexcept {
    return std::move(set_frame_timestamp(std::move(frame_timestamp)));
  }

 private:
  /// @see frame_timestamp()
  Timestamp frame_timestamp_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<1> set_fields_;
};

/// A detection event message.
///
/// Source: horus/pb/detection_service/detection.proto:102:1
class DetectionEvent final : public PbMessage {
 public:
  /// @see DetectionEvent_FrameInfo
  using FrameInfo = DetectionEvent_FrameInfo;

  /// Constructs a default-initialized `DetectionEvent`.
  DetectionEvent() noexcept = default;

  /// Move constructor.
  DetectionEvent(DetectionEvent&&) noexcept = default;
  /// Move assignment operator.
  DetectionEvent& operator=(DetectionEvent&&) noexcept = default;

  /// Constructs a clone of `other`.
  ///
  /// @throws std::bad_alloc If `other` owns heap-allocated data which could not be cloned due to a
  /// lack of available memory.
  explicit DetectionEvent(const DetectionEvent& other) noexcept(false);  // NOLINT(*-explicit-*)

  /// Cannot copy-assign to avoid implicit allocations.
  DetectionEvent& operator=(const DetectionEvent&) = delete;

  /// Default destructor.
  ~DetectionEvent() noexcept final = default;

  /// Creates a `DetectionEvent` whose contents are read from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  explicit DetectionEvent(PbReader& reader) noexcept(false) : PbMessage{} {
    DeserializeFrom(reader);
  }

  /// Serializes the message to `writer`.
  ///
  /// @throws std::bad_alloc If the resulting buffer failed to allocate.
  void SerializeTo(PbWriter& writer) const noexcept(false) final;

  /// Deserializes the message from `reader`.
  ///
  /// @throws InvalidProtobufMessage If the `reader` contains an invalid Protobuf message.
  void DeserializeFrom(PbReader& reader) noexcept(false) final;

  /// Returns whether the message is empty.
  bool IsEmpty() const noexcept final { return set_fields_.none(); }

  /// The full name of the message: `horus.pb.DetectionEvent`.
  static constexpr StringView TypeName() noexcept { return "horus.pb.DetectionEvent"; }

  /// The full name of the message: `horus.pb.DetectionEvent`.
  StringView MessageTypeName() const noexcept final { return TypeName(); }

  // Field `objects` (no 1).
  // -----

  /// The detected objects.
  ///
  /// Field no: 1.
  constexpr const CowRepeated<DetectedObject>& objects() const& noexcept HORUS_LIFETIME_BOUND {
    return objects_;
  }

  /// If `objects` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 1.
  CowRepeated<DetectedObject> objects() && noexcept {
    if (!set_fields_[0]) {
      return {};
    }
    return std::move(objects_);
  }

  /// The detected objects.
  ///
  /// Field no: 1.
  CowRepeated<DetectedObject>& mutable_objects() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[0] = true;
    return objects_;
  }

  /// Returns whether `objects` (no 1) is set.
  constexpr bool has_objects() const noexcept { return set_fields_[0]; }

  /// Clears `objects` (no 1).
  void clear_objects() & noexcept {
    set_fields_[0] = false;
    objects_ = {};
  }

  /// Sets `objects` (no 1) and returns `*this`.
  DetectionEvent& set_objects(CowRepeated<DetectedObject>&& objects) & noexcept {
    set_fields_[0] = true;
    objects_ = std::move(objects);
    return *this;
  }
  /// Sets `objects` (no 1) and returns `*this`.
  DetectionEvent&& set_objects(CowRepeated<DetectedObject>&& objects) && noexcept {
    return std::move(set_objects(std::move(objects)));
  }

  // Field `labeled_point_clouds` (no 2).
  // -----

  /// The labeled point clouds.
  ///
  /// Field no: 2.
  constexpr const CowRepeated<LabeledPointCloud>& labeled_point_clouds() const& noexcept HORUS_LIFETIME_BOUND {
    return labeled_point_clouds_;
  }

  /// If `labeled_point_clouds` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 2.
  CowRepeated<LabeledPointCloud> labeled_point_clouds() && noexcept {
    if (!set_fields_[1]) {
      return {};
    }
    return std::move(labeled_point_clouds_);
  }

  /// The labeled point clouds.
  ///
  /// Field no: 2.
  CowRepeated<LabeledPointCloud>& mutable_labeled_point_clouds() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[1] = true;
    return labeled_point_clouds_;
  }

  /// Returns whether `labeled_point_clouds` (no 2) is set.
  constexpr bool has_labeled_point_clouds() const noexcept { return set_fields_[1]; }

  /// Clears `labeled_point_clouds` (no 2).
  void clear_labeled_point_clouds() & noexcept {
    set_fields_[1] = false;
    labeled_point_clouds_ = {};
  }

  /// Sets `labeled_point_clouds` (no 2) and returns `*this`.
  DetectionEvent& set_labeled_point_clouds(CowRepeated<LabeledPointCloud>&& labeled_point_clouds) & noexcept {
    set_fields_[1] = true;
    labeled_point_clouds_ = std::move(labeled_point_clouds);
    return *this;
  }
  /// Sets `labeled_point_clouds` (no 2) and returns `*this`.
  DetectionEvent&& set_labeled_point_clouds(CowRepeated<LabeledPointCloud>&& labeled_point_clouds) && noexcept {
    return std::move(set_labeled_point_clouds(std::move(labeled_point_clouds)));
  }

  // Field `frame_info` (no 3).
  // -----

  /// The frame info of the detection event.
  ///
  /// Field no: 3.
  constexpr const DetectionEvent_FrameInfo& frame_info() const& noexcept HORUS_LIFETIME_BOUND {
    return frame_info_;
  }

  /// If `frame_info` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 3.
  DetectionEvent_FrameInfo frame_info() && noexcept {
    if (!set_fields_[2]) {
      return {};
    }
    return std::move(frame_info_);
  }

  /// The frame info of the detection event.
  ///
  /// Field no: 3.
  DetectionEvent_FrameInfo& mutable_frame_info() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[2] = true;
    return frame_info_;
  }

  /// Returns whether `frame_info` (no 3) is set.
  constexpr bool has_frame_info() const noexcept { return set_fields_[2]; }

  /// Clears `frame_info` (no 3).
  void clear_frame_info() & noexcept {
    set_fields_[2] = false;
    frame_info_ = {};
  }

  /// Sets `frame_info` (no 3) and returns `*this`.
  DetectionEvent& set_frame_info(DetectionEvent_FrameInfo&& frame_info) & noexcept {
    set_fields_[2] = true;
    frame_info_ = std::move(frame_info);
    return *this;
  }
  /// Sets `frame_info` (no 3) and returns `*this`.
  DetectionEvent&& set_frame_info(DetectionEvent_FrameInfo&& frame_info) && noexcept {
    return std::move(set_frame_info(std::move(frame_info)));
  }

  // Field `raw_deep_learning_objects` (no 4).
  // -----

  /// The raw deep learning bounding boxes.
  ///
  /// Field no: 4.
  constexpr const CowRepeated<DeepLearningObject>& raw_deep_learning_objects() const& noexcept HORUS_LIFETIME_BOUND {
    return raw_deep_learning_objects_;
  }

  /// If `raw_deep_learning_objects` is set, moves it out of the message (without marking it as unset).
  ///
  /// Otherwise, returns a default-initialized value.
  ///
  /// Field no: 4.
  CowRepeated<DeepLearningObject> raw_deep_learning_objects() && noexcept {
    if (!set_fields_[3]) {
      return {};
    }
    return std::move(raw_deep_learning_objects_);
  }

  /// The raw deep learning bounding boxes.
  ///
  /// Field no: 4.
  CowRepeated<DeepLearningObject>& mutable_raw_deep_learning_objects() & noexcept HORUS_LIFETIME_BOUND {
    set_fields_[3] = true;
    return raw_deep_learning_objects_;
  }

  /// Returns whether `raw_deep_learning_objects` (no 4) is set.
  constexpr bool has_raw_deep_learning_objects() const noexcept { return set_fields_[3]; }

  /// Clears `raw_deep_learning_objects` (no 4).
  void clear_raw_deep_learning_objects() & noexcept {
    set_fields_[3] = false;
    raw_deep_learning_objects_ = {};
  }

  /// Sets `raw_deep_learning_objects` (no 4) and returns `*this`.
  DetectionEvent& set_raw_deep_learning_objects(CowRepeated<DeepLearningObject>&& raw_deep_learning_objects) & noexcept {
    set_fields_[3] = true;
    raw_deep_learning_objects_ = std::move(raw_deep_learning_objects);
    return *this;
  }
  /// Sets `raw_deep_learning_objects` (no 4) and returns `*this`.
  DetectionEvent&& set_raw_deep_learning_objects(CowRepeated<DeepLearningObject>&& raw_deep_learning_objects) && noexcept {
    return std::move(set_raw_deep_learning_objects(std::move(raw_deep_learning_objects)));
  }

 private:
  /// @see objects()
  CowRepeated<DetectedObject> objects_{};
  /// @see labeled_point_clouds()
  CowRepeated<LabeledPointCloud> labeled_point_clouds_{};
  /// @see frame_info()
  DetectionEvent_FrameInfo frame_info_{};
  /// @see raw_deep_learning_objects()
  CowRepeated<DeepLearningObject> raw_deep_learning_objects_{};

  /// The set of fields that have been given an explicit value.
  std::bitset<4> set_fields_;
};

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// MARK: Enum traits

namespace horus {

template <>
class PbEnumTraits<horus::sdk::pb::ObjectLabel> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.ObjectLabel`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.ObjectLabel"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::ObjectLabel value) noexcept {
    switch (value) {
      case horus::sdk::pb::ObjectLabel::kLabelUnspecified: {
        return "LABEL_UNSPECIFIED";
      }
      case horus::sdk::pb::ObjectLabel::kMisc: {
        return "MISC";
      }
      case horus::sdk::pb::ObjectLabel::kCar: {
        return "CAR";
      }
      case horus::sdk::pb::ObjectLabel::kCyclist: {
        return "CYCLIST";
      }
      case horus::sdk::pb::ObjectLabel::kPedestrian: {
        return "PEDESTRIAN";
      }
      case horus::sdk::pb::ObjectLabel::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ObjectLabel ValueOf(PbEnum value, horus::sdk::pb::ObjectLabel default_value = horus::sdk::pb::ObjectLabel::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::ObjectLabel::kLabelUnspecified;
      }
      case 1: {
        return horus::sdk::pb::ObjectLabel::kMisc;
      }
      case 2: {
        return horus::sdk::pb::ObjectLabel::kCar;
      }
      case 3: {
        return horus::sdk::pb::ObjectLabel::kCyclist;
      }
      case 4: {
        return horus::sdk::pb::ObjectLabel::kPedestrian;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::ObjectLabel ValueOf(StringView name, horus::sdk::pb::ObjectLabel default_value = horus::sdk::pb::ObjectLabel::kUnknownWireValue) noexcept {
    if (name == "LABEL_UNSPECIFIED") {
      return horus::sdk::pb::ObjectLabel::kLabelUnspecified;
    }
    if (name == "MISC") {
      return horus::sdk::pb::ObjectLabel::kMisc;
    }
    if (name == "CAR") {
      return horus::sdk::pb::ObjectLabel::kCar;
    }
    if (name == "CYCLIST") {
      return horus::sdk::pb::ObjectLabel::kCyclist;
    }
    if (name == "PEDESTRIAN") {
      return horus::sdk::pb::ObjectLabel::kPedestrian;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::ObjectLabel> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::ObjectLabel value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::ObjectLabel` from `reader`.
  static horus::sdk::pb::ObjectLabel Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::ObjectLabel>::ValueOf(reader.Reader().get_enum());
  }
};

template <>
class PbEnumTraits<horus::sdk::pb::TrackingStatus> final {
 public:
  /// The full name of the enum: `horus.sdk.pb.TrackingStatus`.
  static constexpr StringView EnumName() noexcept { return "horus.sdk.pb.TrackingStatus"; }

  /// Returns the name of the given enumerator, or an empty string.
  static constexpr StringView NameOf(horus::sdk::pb::TrackingStatus value) noexcept {
    switch (value) {
      case horus::sdk::pb::TrackingStatus::kUnspecified: {
        return "TRACKING_STATUS_UNSPECIFIED";
      }
      case horus::sdk::pb::TrackingStatus::kInvalidating: {
        return "INVALIDATING";
      }
      case horus::sdk::pb::TrackingStatus::kValidating: {
        return "VALIDATING";
      }
      case horus::sdk::pb::TrackingStatus::kDrifting: {
        return "DRIFTING";
      }
      case horus::sdk::pb::TrackingStatus::kTracking: {
        return "TRACKING";
      }
      case horus::sdk::pb::TrackingStatus::kUnknownWireValue:
      default: {
        return "";
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::TrackingStatus ValueOf(PbEnum value, horus::sdk::pb::TrackingStatus default_value = horus::sdk::pb::TrackingStatus::kUnknownWireValue) noexcept {
    switch (value) {
      case 0: {
        return horus::sdk::pb::TrackingStatus::kUnspecified;
      }
      case 1: {
        return horus::sdk::pb::TrackingStatus::kInvalidating;
      }
      case 2: {
        return horus::sdk::pb::TrackingStatus::kValidating;
      }
      case 3: {
        return horus::sdk::pb::TrackingStatus::kDrifting;
      }
      case 4: {
        return horus::sdk::pb::TrackingStatus::kTracking;
      }
      default: {
        return default_value;
      }
    }
  }

  /// Returns the value corresponding to the given name, or `default_value`.
  static constexpr horus::sdk::pb::TrackingStatus ValueOf(StringView name, horus::sdk::pb::TrackingStatus default_value = horus::sdk::pb::TrackingStatus::kUnknownWireValue) noexcept {
    if (name == "TRACKING_STATUS_UNSPECIFIED") {
      return horus::sdk::pb::TrackingStatus::kUnspecified;
    }
    if (name == "INVALIDATING") {
      return horus::sdk::pb::TrackingStatus::kInvalidating;
    }
    if (name == "VALIDATING") {
      return horus::sdk::pb::TrackingStatus::kValidating;
    }
    if (name == "DRIFTING") {
      return horus::sdk::pb::TrackingStatus::kDrifting;
    }
    if (name == "TRACKING") {
      return horus::sdk::pb::TrackingStatus::kTracking;
    }
    return default_value;
  }
};

template <>
class PbTraits<horus::sdk::pb::TrackingStatus> final {
 public:
  /// Serializes `value` into `writer`.
  static void Serialize(PbWriter& writer, PbTag tag, horus::sdk::pb::TrackingStatus value) {
    writer.Writer().add_enum(tag, static_cast<PbEnum>(value));
  }

  /// Deserializes `horus::sdk::pb::TrackingStatus` from `reader`.
  static horus::sdk::pb::TrackingStatus Deserialize(PbReader& reader) {
    return PbEnumTraits<horus::sdk::pb::TrackingStatus>::ValueOf(reader.Reader().get_enum());
  }
};

}  // namespace horus

namespace horus {
namespace sdk {
namespace pb {

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, ObjectLabel value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<ObjectLabel>::NameOf(value));
}

/// Appends `value` to `sink`.
template <class Sink>
void HorusStringify(Sink& sink, TrackingStatus value) noexcept(noexcept(sink.Append(StringView{}))) {
  sink.Append(PbEnumTraits<TrackingStatus>::NameOf(value));
}

}  // namespace pb
}  // namespace sdk
}  // namespace horus

// NOLINTEND(readability-identifier-length)

#endif  // HORUS_PB_DETECTION_SERVICE_DETECTION_PB_H_
