/// @file
///
/// Code generator which generates forward declarations and layout information for libuv types.

#include <uv.h>

#include <fstream>
#include <iostream>

int main(int const argc, char const* const* const argv) {
  if (argc != 2) {
    // NOLINTNEXTLINE(*-pointer-arithmetic)
    std::cerr << "Usage: " << argv[0] << " <output_file>\n";
    return 1;
  }

  // NOLINTNEXTLINE(*-pointer-arithmetic)
  std::ofstream out{argv[1]};

  out << R"(/// @file
///
/// Forward declarations and layouts of libuv types.
///
/// Automatically generated by `uv_handles_generator.cpp`. Do not edit.

#ifndef HORUS_EVENT_LOOP_UV_HANDLES_H_
#define HORUS_EVENT_LOOP_UV_HANDLES_H_

#include <cstddef>

// MARK: Forward declarations
//

extern "C" {

// `uv_async_s` is the `struct` defined by libuv, but `uv_async_t` is the `typedef` which is
// exposed publicly. We therefore need to declare both `uv_*_s` (without giving it a definition)
// and `uv_*_t` (which is a `typedef` to the earlier `uv_*_s`).
//
// Note: a struct may only have a single *definition*, but it may have multiple *declarations*. An
// alias can have multiple definitions, as long as they point to the same type.
)";

  auto const forward_declare_uv_handle = [&out](char const* const type, char const* const doc) {
    out << "\n"
        << "/// See https://docs.libuv.org/en/v1.x/" << doc << ".\n"
        << "struct uv_" << type << "_s;\n"
        << "/// See https://docs.libuv.org/en/v1.x/" << doc << ".\n"
        << "using uv_" << type << "_t = uv_" << type << "_s;\n";
  };

  forward_declare_uv_handle("async", "async.html");
  forward_declare_uv_handle("handle", "handle.html");
  forward_declare_uv_handle("loop", "loop.html");
  forward_declare_uv_handle("req", "request.html");
  forward_declare_uv_handle("signal", "signal.html");
  forward_declare_uv_handle("tcp", "tcp.html");
  forward_declare_uv_handle("timer", "timer.html");
  forward_declare_uv_handle("work", "threadpool.html");

  out << R"(
}

namespace horus {
namespace horus_internal {

/// Static layout type.
template <std::size_t Size, std::size_t Align>
struct Layout {
  /// Size of the described type in bytes.
  static constexpr std::size_t kSize{Size};
  /// Alignment of the described type in bytes.
  static constexpr std::size_t kAlign{Align};
};

/// Hard-coded layouts of libuv handle types.
template <class T>
struct LayoutOf;
)";

// NOLINTNEXTLINE(*-macro-usage)
#define ADD_UV_HANDLE_LAYOUT(TYPE)                                                        \
  out << "template <>\n"                                                                  \
      << "struct LayoutOf<" #TYPE "> : Layout<" << sizeof(TYPE) << "U, " << alignof(TYPE) \
      << "U> {};\n"

  ADD_UV_HANDLE_LAYOUT(uv_async_t);
  ADD_UV_HANDLE_LAYOUT(uv_loop_t);
  ADD_UV_HANDLE_LAYOUT(uv_req_t);
  ADD_UV_HANDLE_LAYOUT(uv_signal_t);
  ADD_UV_HANDLE_LAYOUT(uv_tcp_t);
  ADD_UV_HANDLE_LAYOUT(uv_timer_t);
  ADD_UV_HANDLE_LAYOUT(uv_work_t);

  out << R"(
}  // namespace horus_internal
}  // namespace horus

#endif  // HORUS_EVENT_LOOP_UV_HANDLES_H_
)";

  return 0;
}
